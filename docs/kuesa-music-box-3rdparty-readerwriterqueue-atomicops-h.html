<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- music-box.qdoc -->
  <title>Kuesa Music Box QML Example | Kuesa Runtime 1.2</title>
<link rel='stylesheet' href='style/bootstrap.min.css'> <link rel='stylesheet' href='style/dracula.css'> <link rel='stylesheet' href='style/style.css'><script type='text/javascript' src='scripts/jquery.slim.min.js'></script> <script type='text/javascript' src='scripts/bootstrap.bundle.min.js'></script> <script type='text/javascript' src='scripts/highlight.pack.js'></script> <script type='text/javascript' src='scripts/clipboard.min.js'></script> <script type='text/javascript' src='scripts/script.js'></script></head>
<div id="title"> <div class="logo"> <a href="https://www.kdab.com" target=”_blank” class="ui-link"> <img src="images/kdab-logo.png" alt="KDAB Logo"> </a> </div> <div class="header"> <h1>Kuesa Runtime</h1> </div> </div> <div id="breadcrumbs"><ul><li><a href="index.html">Kuesa Runtime 1.2</a></li>
<li><a href="kuesa-overview.html#kuesa-runtime">Kuesa Runtime</a></li>
<li>Kuesa Music Box QML Example</li>
<li id="buildversion"><a href="kuesa-overview.html#kuesa-runtime">Kuesa Runtime 1.2 Reference Documentation</a></li>
</ul></div><div class='doc-content'><h1 class="title">Kuesa Music Box QML Example</h1>
<span class="subtitle"></span>
<pre class="cpp">

  <span class="comment">// ©2013-2016 Cameron Desrochers.</span>
  <span class="comment">// Distributed under the simplified BSD license (see the license file that</span>
  <span class="comment">// should have come with this header).</span>
  <span class="comment">// Uses Jeff Preshing's semaphore implementation (under the terms of its</span>
  <span class="comment">// separate zlib license, embedded below).</span>

  <span class="preprocessor">#pragma once</span>

  <span class="comment">// Provides portable (VC++2010+, Intel ICC 13, GCC 4.7+, and anything C++11 compliant) implementation</span>
  <span class="comment">// of low-level memory barriers, plus a few semi-portable utility macros (for inlining and alignment).</span>
  <span class="comment">// Also has a basic atomic type (limited to hardware-supported atomics with no memory ordering guarantees).</span>
  <span class="comment">// Uses the AE_* prefix for macros (historical reasons), and the &quot;moodycamel&quot; namespace for symbols.</span>

  <span class="preprocessor">#include &lt;cassert&gt;</span>
  <span class="preprocessor">#include &lt;type_traits&gt;</span>
  <span class="preprocessor">#include &lt;cerrno&gt;</span>
  <span class="preprocessor">#include &lt;cstdint&gt;</span>
  <span class="preprocessor">#include &lt;ctime&gt;</span>

  <span class="comment">// Platform detection</span>
  <span class="preprocessor">#if defined(__INTEL_COMPILER)</span>
  <span class="preprocessor">#define AE_ICC</span>
  <span class="preprocessor">#elif defined(_MSC_VER)</span>
  <span class="preprocessor">#define AE_VCPP</span>
  <span class="preprocessor">#elif defined(__GNUC__)</span>
  <span class="preprocessor">#define AE_GCC</span>
  <span class="preprocessor">#endif</span>

  <span class="preprocessor">#if defined(_M_IA64) || defined(__ia64__)</span>
  <span class="preprocessor">#define AE_ARCH_IA64</span>
  <span class="preprocessor">#elif defined(_WIN64) || defined(__amd64__) || defined(_M_X64) || defined(__x86_64__)</span>
  <span class="preprocessor">#define AE_ARCH_X64</span>
  <span class="preprocessor">#elif defined(_M_IX86) || defined(__i386__)</span>
  <span class="preprocessor">#define AE_ARCH_X86</span>
  <span class="preprocessor">#elif defined(_M_PPC) || defined(__powerpc__)</span>
  <span class="preprocessor">#define AE_ARCH_PPC</span>
  <span class="preprocessor">#else</span>
  <span class="preprocessor">#define AE_ARCH_UNKNOWN</span>
  <span class="preprocessor">#endif</span>

  <span class="comment">// AE_UNUSED</span>
  <span class="preprocessor">#define AE_UNUSED(x) ((void)x)</span>

  <span class="comment">// AE_NO_TSAN</span>
  <span class="preprocessor">#if defined(__has_feature)</span>
  <span class="preprocessor">#if __has_feature(thread_sanitizer)</span>
  <span class="preprocessor">#define AE_NO_TSAN __attribute__((no_sanitize(&quot;thread&quot;)))</span>
  <span class="preprocessor">#else</span>
  <span class="preprocessor">#define AE_NO_TSAN</span>
  <span class="preprocessor">#endif</span>
  <span class="preprocessor">#else</span>
  <span class="preprocessor">#define AE_NO_TSAN</span>
  <span class="preprocessor">#endif</span>

  <span class="comment">// AE_FORCEINLINE</span>
  <span class="preprocessor">#if defined(AE_VCPP) || defined(AE_ICC)</span>
  <span class="preprocessor">#define AE_FORCEINLINE __forceinline</span>
  <span class="preprocessor">#elif defined(AE_GCC)</span>
  <span class="comment">//#define AE_FORCEINLINE __attribute__((always_inline))</span>
  <span class="preprocessor">#define AE_FORCEINLINE inline</span>
  <span class="preprocessor">#else</span>
  <span class="preprocessor">#define AE_FORCEINLINE inline</span>
  <span class="preprocessor">#endif</span>

  <span class="comment">// AE_ALIGN</span>
  <span class="preprocessor">#if defined(AE_VCPP) || defined(AE_ICC)</span>
  <span class="preprocessor">#define AE_ALIGN(x) __declspec(align(x))</span>
  <span class="preprocessor">#elif defined(AE_GCC)</span>
  <span class="preprocessor">#define AE_ALIGN(x) __attribute__((aligned(x)))</span>
  <span class="preprocessor">#else</span>
  <span class="comment">// Assume GCC compliant syntax...</span>
  <span class="preprocessor">#define AE_ALIGN(x) __attribute__((aligned(x)))</span>
  <span class="preprocessor">#endif</span>

  <span class="comment">// Portable atomic fences implemented below:</span>

  <span class="keyword">namespace</span> moodycamel {

  <span class="keyword">enum</span> memory_order {
          memory_order_relaxed<span class="operator">,</span>
          memory_order_acquire<span class="operator">,</span>
          memory_order_release<span class="operator">,</span>
          memory_order_acq_rel<span class="operator">,</span>
          memory_order_seq_cst<span class="operator">,</span>

          <span class="comment">// memory_order_sync: Forces a full sync:</span>
          <span class="comment">// #LoadLoad, #LoadStore, #StoreStore, and most significantly, #StoreLoad</span>
          memory_order_sync <span class="operator">=</span> memory_order_seq_cst
  };

  }    <span class="comment">// end namespace moodycamel</span>

  <span class="preprocessor">#if (defined(AE_VCPP) &amp;&amp; (_MSC_VER &lt; 1700 || defined(__cplusplus_cli))) || (defined(AE_ICC) &amp;&amp; __INTEL_COMPILER &lt; 1600)</span>
  <span class="comment">// VS2010 and ICC13 don't support std::atomic_*_fence, implement our own fences</span>

  <span class="preprocessor">#include &lt;intrin.h&gt;</span>

  <span class="preprocessor">#if defined(AE_ARCH_X64) || defined(AE_ARCH_X86)</span>
  <span class="preprocessor">#define AeFullSync _mm_mfence</span>
  <span class="preprocessor">#define AeLiteSync _mm_mfence</span>
  <span class="preprocessor">#elif defined(AE_ARCH_IA64)</span>
  <span class="preprocessor">#define AeFullSync __mf</span>
  <span class="preprocessor">#define AeLiteSync __mf</span>
  <span class="preprocessor">#elif defined(AE_ARCH_PPC)</span>
  <span class="preprocessor">#include &lt;ppcintrinsics.h&gt;</span>
  <span class="preprocessor">#define AeFullSync __sync</span>
  <span class="preprocessor">#define AeLiteSync __lwsync</span>
  <span class="preprocessor">#endif</span>

  <span class="preprocessor">#ifdef AE_VCPP</span>
  <span class="preprocessor">#pragma warning(push)</span>
  <span class="preprocessor">#pragma warning(disable: 4365)          // Disable erroneous 'conversion from long to unsigned int, signed/unsigned mismatch' error when using `assert`</span>
  <span class="preprocessor">#ifdef __cplusplus_cli</span>
  <span class="preprocessor">#pragma managed(push, off)</span>
  <span class="preprocessor">#endif</span>
  <span class="preprocessor">#endif</span>

  <span class="keyword">namespace</span> moodycamel {

  AE_FORCEINLINE <span class="type">void</span> compiler_fence(memory_order order) AE_NO_TSAN
  {
          <span class="keyword">switch</span> (order) {
                  <span class="keyword">case</span> memory_order_relaxed: <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acquire: _ReadBarrier(); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_release: _WriteBarrier(); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acq_rel: _ReadWriteBarrier(); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_seq_cst: _ReadWriteBarrier(); <span class="keyword">break</span>;
                  <span class="keyword">default</span>: assert(<span class="keyword">false</span>);
          }
  }

  <span class="comment">// x86/x64 have a strong memory model -- all loads and stores have</span>
  <span class="comment">// acquire and release semantics automatically (so only need compiler</span>
  <span class="comment">// barriers for those).</span>
  <span class="preprocessor">#if defined(AE_ARCH_X86) || defined(AE_ARCH_X64)</span>
  AE_FORCEINLINE <span class="type">void</span> fence(memory_order order) AE_NO_TSAN
  {
          <span class="keyword">switch</span> (order) {
                  <span class="keyword">case</span> memory_order_relaxed: <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acquire: _ReadBarrier(); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_release: _WriteBarrier(); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acq_rel: _ReadWriteBarrier(); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_seq_cst:
                          _ReadWriteBarrier();
                          AeFullSync();
                          _ReadWriteBarrier();
                          <span class="keyword">break</span>;
                  <span class="keyword">default</span>: assert(<span class="keyword">false</span>);
          }
  }
  <span class="preprocessor">#else</span>
  AE_FORCEINLINE <span class="type">void</span> fence(memory_order order) AE_NO_TSAN
  {
          <span class="comment">// Non-specialized arch, use heavier memory barriers everywhere just in case :-(</span>
          <span class="keyword">switch</span> (order) {
                  <span class="keyword">case</span> memory_order_relaxed:
                          <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acquire:
                          _ReadBarrier();
                          AeLiteSync();
                          _ReadBarrier();
                          <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_release:
                          _WriteBarrier();
                          AeLiteSync();
                          _WriteBarrier();
                          <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acq_rel:
                          _ReadWriteBarrier();
                          AeLiteSync();
                          _ReadWriteBarrier();
                          <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_seq_cst:
                          _ReadWriteBarrier();
                          AeFullSync();
                          _ReadWriteBarrier();
                          <span class="keyword">break</span>;
                  <span class="keyword">default</span>: assert(<span class="keyword">false</span>);
          }
  }
  <span class="preprocessor">#endif</span>
  }    <span class="comment">// end namespace moodycamel</span>
  <span class="preprocessor">#else</span>
  <span class="comment">// Use standard library of atomics</span>
  <span class="preprocessor">#include &lt;atomic&gt;</span>

  <span class="keyword">namespace</span> moodycamel {

  AE_FORCEINLINE <span class="type">void</span> compiler_fence(memory_order order) AE_NO_TSAN
  {
          <span class="keyword">switch</span> (order) {
                  <span class="keyword">case</span> memory_order_relaxed: <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acquire: std<span class="operator">::</span>atomic_signal_fence(std<span class="operator">::</span>memory_order_acquire); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_release: std<span class="operator">::</span>atomic_signal_fence(std<span class="operator">::</span>memory_order_release); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acq_rel: std<span class="operator">::</span>atomic_signal_fence(std<span class="operator">::</span>memory_order_acq_rel); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_seq_cst: std<span class="operator">::</span>atomic_signal_fence(std<span class="operator">::</span>memory_order_seq_cst); <span class="keyword">break</span>;
                  <span class="keyword">default</span>: assert(<span class="keyword">false</span>);
          }
  }

  AE_FORCEINLINE <span class="type">void</span> fence(memory_order order) AE_NO_TSAN
  {
          <span class="keyword">switch</span> (order) {
                  <span class="keyword">case</span> memory_order_relaxed: <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acquire: std<span class="operator">::</span>atomic_thread_fence(std<span class="operator">::</span>memory_order_acquire); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_release: std<span class="operator">::</span>atomic_thread_fence(std<span class="operator">::</span>memory_order_release); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_acq_rel: std<span class="operator">::</span>atomic_thread_fence(std<span class="operator">::</span>memory_order_acq_rel); <span class="keyword">break</span>;
                  <span class="keyword">case</span> memory_order_seq_cst: std<span class="operator">::</span>atomic_thread_fence(std<span class="operator">::</span>memory_order_seq_cst); <span class="keyword">break</span>;
                  <span class="keyword">default</span>: assert(<span class="keyword">false</span>);
          }
  }

  }    <span class="comment">// end namespace moodycamel</span>

  <span class="preprocessor">#endif</span>

  <span class="preprocessor">#if !defined(AE_VCPP) || (_MSC_VER &gt;= 1700 &amp;&amp; !defined(__cplusplus_cli))</span>
  <span class="preprocessor">#define AE_USE_STD_ATOMIC_FOR_WEAK_ATOMIC</span>
  <span class="preprocessor">#endif</span>

  <span class="preprocessor">#ifdef AE_USE_STD_ATOMIC_FOR_WEAK_ATOMIC</span>
  <span class="preprocessor">#include &lt;atomic&gt;</span>
  <span class="preprocessor">#endif</span>
  <span class="preprocessor">#include &lt;utility&gt;</span>

  <span class="comment">// WARNING: *NOT* A REPLACEMENT FOR std::atomic. READ CAREFULLY:</span>
  <span class="comment">// Provides basic support for atomic variables -- no memory ordering guarantees are provided.</span>
  <span class="comment">// The guarantee of atomicity is only made for types that already have atomic load and store guarantees</span>
  <span class="comment">// at the hardware level -- on most platforms this generally means aligned pointers and integers (only).</span>
  <span class="keyword">namespace</span> moodycamel {
  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
  <span class="keyword">class</span> weak_atomic
  {
  <span class="keyword">public</span>:
          AE_NO_TSAN weak_atomic() { }
  <span class="preprocessor">#ifdef AE_VCPP</span>
  <span class="preprocessor">#pragma warning(push)</span>
  <span class="preprocessor">#pragma warning(disable: 4100)          // Get rid of (erroneous) 'unreferenced formal parameter' warning</span>
  <span class="preprocessor">#endif</span>
          <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> U<span class="operator">&gt;</span> AE_NO_TSAN weak_atomic(U<span class="operator">&amp;</span><span class="operator">&amp;</span> x) : value(std<span class="operator">::</span>forward<span class="operator">&lt;</span>U<span class="operator">&gt;</span>(x)) {  }
  <span class="preprocessor">#ifdef __cplusplus_cli</span>
          <span class="comment">// Work around bug with universal reference/nullptr combination that only appears when /clr is on</span>
          AE_NO_TSAN weak_atomic(nullptr_t) : value(nullptr) {  }
  <span class="preprocessor">#endif</span>
          AE_NO_TSAN weak_atomic(weak_atomic <span class="keyword">const</span><span class="operator">&amp;</span> other) : value(other<span class="operator">.</span>load()) {  }
          AE_NO_TSAN weak_atomic(weak_atomic<span class="operator">&amp;</span><span class="operator">&amp;</span> other) : value(std<span class="operator">::</span>move(other<span class="operator">.</span>load())) {  }
  <span class="preprocessor">#ifdef AE_VCPP</span>
  <span class="preprocessor">#pragma warning(pop)</span>
  <span class="preprocessor">#endif</span>

          AE_FORCEINLINE <span class="keyword">operator</span> T() <span class="keyword">const</span> AE_NO_TSAN { <span class="keyword">return</span> load(); }

  <span class="preprocessor">#ifndef AE_USE_STD_ATOMIC_FOR_WEAK_ATOMIC</span>
          <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> U<span class="operator">&gt;</span> AE_FORCEINLINE weak_atomic <span class="keyword">const</span><span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span>(U<span class="operator">&amp;</span><span class="operator">&amp;</span> x) AE_NO_TSAN { value <span class="operator">=</span> std<span class="operator">::</span>forward<span class="operator">&lt;</span>U<span class="operator">&gt;</span>(x); <span class="keyword">return</span> <span class="operator">*</span><span class="keyword">this</span>; }
          AE_FORCEINLINE weak_atomic <span class="keyword">const</span><span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span>(weak_atomic <span class="keyword">const</span><span class="operator">&amp;</span> other) AE_NO_TSAN { value <span class="operator">=</span> other<span class="operator">.</span>value; <span class="keyword">return</span> <span class="operator">*</span><span class="keyword">this</span>; }

          AE_FORCEINLINE T load() <span class="keyword">const</span> AE_NO_TSAN { <span class="keyword">return</span> value; }

          AE_FORCEINLINE T fetch_add_acquire(T increment) AE_NO_TSAN
          {
  <span class="preprocessor">#if defined(AE_ARCH_X64) || defined(AE_ARCH_X86)</span>
                  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(T) <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) <span class="keyword">return</span> _InterlockedExchangeAdd((<span class="type">long</span> <span class="keyword">volatile</span><span class="operator">*</span>)<span class="operator">&amp;</span>value<span class="operator">,</span> (<span class="type">long</span>)increment);
  <span class="preprocessor">#if defined(_M_AMD64)</span>
                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(T) <span class="operator">=</span><span class="operator">=</span> <span class="number">8</span>) <span class="keyword">return</span> _InterlockedExchangeAdd64((<span class="type">long</span> <span class="type">long</span> <span class="keyword">volatile</span><span class="operator">*</span>)<span class="operator">&amp;</span>value<span class="operator">,</span> (<span class="type">long</span> <span class="type">long</span>)increment);
  <span class="preprocessor">#endif</span>
  <span class="preprocessor">#else</span>
  <span class="preprocessor">#error Unsupported platform</span>
  <span class="preprocessor">#endif</span>
                  assert(<span class="keyword">false</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="string">&quot;T must be either a 32 or 64 bit type&quot;</span>);
                  <span class="keyword">return</span> value;
          }

          AE_FORCEINLINE T fetch_add_release(T increment) AE_NO_TSAN
          {
  <span class="preprocessor">#if defined(AE_ARCH_X64) || defined(AE_ARCH_X86)</span>
                  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(T) <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) <span class="keyword">return</span> _InterlockedExchangeAdd((<span class="type">long</span> <span class="keyword">volatile</span><span class="operator">*</span>)<span class="operator">&amp;</span>value<span class="operator">,</span> (<span class="type">long</span>)increment);
  <span class="preprocessor">#if defined(_M_AMD64)</span>
                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(T) <span class="operator">=</span><span class="operator">=</span> <span class="number">8</span>) <span class="keyword">return</span> _InterlockedExchangeAdd64((<span class="type">long</span> <span class="type">long</span> <span class="keyword">volatile</span><span class="operator">*</span>)<span class="operator">&amp;</span>value<span class="operator">,</span> (<span class="type">long</span> <span class="type">long</span>)increment);
  <span class="preprocessor">#endif</span>
  <span class="preprocessor">#else</span>
  <span class="preprocessor">#error Unsupported platform</span>
  <span class="preprocessor">#endif</span>
                  assert(<span class="keyword">false</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="string">&quot;T must be either a 32 or 64 bit type&quot;</span>);
                  <span class="keyword">return</span> value;
          }
  <span class="preprocessor">#else</span>
          <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> U<span class="operator">&gt;</span>
          AE_FORCEINLINE weak_atomic <span class="keyword">const</span><span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span>(U<span class="operator">&amp;</span><span class="operator">&amp;</span> x) AE_NO_TSAN
          {
                  value<span class="operator">.</span>store(std<span class="operator">::</span>forward<span class="operator">&lt;</span>U<span class="operator">&gt;</span>(x)<span class="operator">,</span> std<span class="operator">::</span>memory_order_relaxed);
                  <span class="keyword">return</span> <span class="operator">*</span><span class="keyword">this</span>;
          }

          AE_FORCEINLINE weak_atomic <span class="keyword">const</span><span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span>(weak_atomic <span class="keyword">const</span><span class="operator">&amp;</span> other) AE_NO_TSAN
          {
                  value<span class="operator">.</span>store(other<span class="operator">.</span>value<span class="operator">.</span>load(std<span class="operator">::</span>memory_order_relaxed)<span class="operator">,</span> std<span class="operator">::</span>memory_order_relaxed);
                  <span class="keyword">return</span> <span class="operator">*</span><span class="keyword">this</span>;
          }

          AE_FORCEINLINE T load() <span class="keyword">const</span> AE_NO_TSAN { <span class="keyword">return</span> value<span class="operator">.</span>load(std<span class="operator">::</span>memory_order_relaxed); }

          AE_FORCEINLINE T fetch_add_acquire(T increment) AE_NO_TSAN
          {
                  <span class="keyword">return</span> value<span class="operator">.</span>fetch_add(increment<span class="operator">,</span> std<span class="operator">::</span>memory_order_acquire);
          }

          AE_FORCEINLINE T fetch_add_release(T increment) AE_NO_TSAN
          {
                  <span class="keyword">return</span> value<span class="operator">.</span>fetch_add(increment<span class="operator">,</span> std<span class="operator">::</span>memory_order_release);
          }
  <span class="preprocessor">#endif</span>

  <span class="keyword">private</span>:
  <span class="preprocessor">#ifndef AE_USE_STD_ATOMIC_FOR_WEAK_ATOMIC</span>
          <span class="comment">// No std::atomic support, but still need to circumvent compiler optimizations.</span>
          <span class="comment">// `volatile` will make memory access slow, but is guaranteed to be reliable.</span>
          <span class="keyword">volatile</span> T value;
  <span class="preprocessor">#else</span>
          std<span class="operator">::</span>atomic<span class="operator">&lt;</span>T<span class="operator">&gt;</span> value;
  <span class="preprocessor">#endif</span>
  };

  }       <span class="comment">// end namespace moodycamel</span>

  <span class="comment">// Portable single-producer, single-consumer semaphore below:</span>

  <span class="preprocessor">#if defined(_WIN32)</span>
  <span class="comment">// Avoid including windows.h in a header; we only need a handful of</span>
  <span class="comment">// items, so we'll redeclare them here (this is relatively safe since</span>
  <span class="comment">// the API generally has to remain stable between Windows versions).</span>
  <span class="comment">// I know this is an ugly hack but it still beats polluting the global</span>
  <span class="comment">// namespace with thousands of generic names or adding a .cpp for nothing.</span>
  <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> {
          <span class="keyword">struct</span> _SECURITY_ATTRIBUTES;
          __declspec(dllimport) <span class="type">void</span><span class="operator">*</span> __stdcall CreateSemaphoreW(_SECURITY_ATTRIBUTES<span class="operator">*</span> lpSemaphoreAttributes<span class="operator">,</span> <span class="type">long</span> lInitialCount<span class="operator">,</span> <span class="type">long</span> lMaximumCount<span class="operator">,</span> <span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="operator">*</span> lpName);
          __declspec(dllimport) <span class="type">int</span> __stdcall CloseHandle(<span class="type">void</span><span class="operator">*</span> hObject);
          __declspec(dllimport) <span class="type">unsigned</span> <span class="type">long</span> __stdcall WaitForSingleObject(<span class="type">void</span><span class="operator">*</span> hHandle<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">long</span> dwMilliseconds);
          __declspec(dllimport) <span class="type">int</span> __stdcall ReleaseSemaphore(<span class="type">void</span><span class="operator">*</span> hSemaphore<span class="operator">,</span> <span class="type">long</span> lReleaseCount<span class="operator">,</span> <span class="type">long</span><span class="operator">*</span> lpPreviousCount);
  }
  <span class="preprocessor">#elif defined(__MACH__)</span>
  <span class="preprocessor">#include &lt;mach/mach.h&gt;</span>
  <span class="preprocessor">#elif defined(__unix__)</span>
  <span class="preprocessor">#include &lt;semaphore.h&gt;</span>
  <span class="preprocessor">#endif</span>

  <span class="keyword">namespace</span> moodycamel
  {
          <span class="comment">// Code in the spsc_sema namespace below is an adaptation of Jeff Preshing's</span>
          <span class="comment">// portable + lightweight semaphore implementations, originally from</span>
          <span class="comment">// https://github.com/preshing/cpp11-on-multicore/blob/master/common/sema.h</span>
          <span class="comment">// LICENSE:</span>
          <span class="comment">// Copyright (c) 2015 Jeff Preshing</span>
          <span class="comment">//</span>
          <span class="comment">// This software is provided 'as-is', without any express or implied</span>
          <span class="comment">// warranty. In no event will the authors be held liable for any damages</span>
          <span class="comment">// arising from the use of this software.</span>
          <span class="comment">//</span>
          <span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
          <span class="comment">// including commercial applications, and to alter it and redistribute it</span>
          <span class="comment">// freely, subject to the following restrictions:</span>
          <span class="comment">//</span>
          <span class="comment">// 1. The origin of this software must not be misrepresented; you must not</span>
          <span class="comment">//    claim that you wrote the original software. If you use this software</span>
          <span class="comment">//    in a product, an acknowledgement in the product documentation would be</span>
          <span class="comment">//    appreciated but is not required.</span>
          <span class="comment">// 2. Altered source versions must be plainly marked as such, and must not be</span>
          <span class="comment">//    misrepresented as being the original software.</span>
          <span class="comment">// 3. This notice may not be removed or altered from any source distribution.</span>
          <span class="keyword">namespace</span> spsc_sema
          {
  <span class="preprocessor">#if defined(_WIN32)</span>
                  <span class="keyword">class</span> Semaphore
                  {
                  <span class="keyword">private</span>:
                      <span class="type">void</span><span class="operator">*</span> m_hSema;

                      Semaphore(<span class="keyword">const</span> Semaphore<span class="operator">&amp;</span> other);
                      Semaphore<span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span>(<span class="keyword">const</span> Semaphore<span class="operator">&amp;</span> other);

                  <span class="keyword">public</span>:
                      AE_NO_TSAN Semaphore(<span class="type">int</span> initialCount <span class="operator">=</span> <span class="number">0</span>)
                      {
                          assert(initialCount <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>);
                          <span class="keyword">const</span> <span class="type">long</span> maxLong <span class="operator">=</span> <span class="number">0x7fffffff</span>;
                          m_hSema <span class="operator">=</span> CreateSemaphoreW(nullptr<span class="operator">,</span> initialCount<span class="operator">,</span> maxLong<span class="operator">,</span> nullptr);
                      }

                      AE_NO_TSAN <span class="operator">~</span>Semaphore()
                      {
                          CloseHandle(m_hSema);
                      }

                      <span class="type">void</span> wait() AE_NO_TSAN
                      {
                          <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">long</span> infinite <span class="operator">=</span> <span class="number">0xffffffff</span>;
                          WaitForSingleObject(m_hSema<span class="operator">,</span> infinite);
                      }

                          bool try_wait() AE_NO_TSAN
                          {
                                  <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">long</span> RC_WAIT_TIMEOUT <span class="operator">=</span> <span class="number">0x00000102</span>;
                                  <span class="keyword">return</span> WaitForSingleObject(m_hSema<span class="operator">,</span> <span class="number">0</span>) <span class="operator">!</span><span class="operator">=</span> RC_WAIT_TIMEOUT;
                          }

                          bool timed_wait(std<span class="operator">::</span>uint64_t usecs) AE_NO_TSAN
                          {
                                  <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">long</span> RC_WAIT_TIMEOUT <span class="operator">=</span> <span class="number">0x00000102</span>;
                                  <span class="keyword">return</span> WaitForSingleObject(m_hSema<span class="operator">,</span> (<span class="type">unsigned</span> <span class="type">long</span>)(usecs <span class="operator">/</span> <span class="number">1000</span>)) <span class="operator">!</span><span class="operator">=</span> RC_WAIT_TIMEOUT;
                          }

                      <span class="type">void</span> signal(<span class="type">int</span> count <span class="operator">=</span> <span class="number">1</span>) AE_NO_TSAN
                      {
                          ReleaseSemaphore(m_hSema<span class="operator">,</span> count<span class="operator">,</span> nullptr);
                      }
                  };
  <span class="preprocessor">#elif defined(__MACH__)</span>
                  <span class="comment">//---------------------------------------------------------</span>
                  <span class="comment">// Semaphore (Apple iOS and OSX)</span>
                  <span class="comment">// Can't use POSIX semaphores due to http://lists.apple.com/archives/darwin-kernel/2009/Apr/msg00010.html</span>
                  <span class="comment">//---------------------------------------------------------</span>
                  <span class="keyword">class</span> Semaphore
                  {
                  <span class="keyword">private</span>:
                      semaphore_t m_sema;

                      Semaphore(<span class="keyword">const</span> Semaphore<span class="operator">&amp;</span> other);
                      Semaphore<span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span>(<span class="keyword">const</span> Semaphore<span class="operator">&amp;</span> other);

                  <span class="keyword">public</span>:
                      AE_NO_TSAN Semaphore(<span class="type">int</span> initialCount <span class="operator">=</span> <span class="number">0</span>)
                      {
                          assert(initialCount <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>);
                          semaphore_create(mach_task_self()<span class="operator">,</span> <span class="operator">&amp;</span>m_sema<span class="operator">,</span> SYNC_POLICY_FIFO<span class="operator">,</span> initialCount);
                      }

                      AE_NO_TSAN <span class="operator">~</span>Semaphore()
                      {
                          semaphore_destroy(mach_task_self()<span class="operator">,</span> m_sema);
                      }

                      <span class="type">void</span> wait() AE_NO_TSAN
                      {
                          semaphore_wait(m_sema);
                      }

                          bool try_wait() AE_NO_TSAN
                          {
                                  <span class="keyword">return</span> timed_wait(<span class="number">0</span>);
                          }

                          bool timed_wait(std<span class="operator">::</span>int64_t timeout_usecs) AE_NO_TSAN
                          {
                                  mach_timespec_t ts;
                                  ts<span class="operator">.</span>tv_sec <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type">unsigned</span> <span class="type">int</span><span class="operator">&gt;</span>(timeout_usecs <span class="operator">/</span> <span class="number">1000000</span>);
                                  ts<span class="operator">.</span>tv_nsec <span class="operator">=</span> (timeout_usecs <span class="operator">%</span> <span class="number">1000000</span>) <span class="operator">*</span> <span class="number">1000</span>;

                                  <span class="comment">// added in OSX 10.10: https://developer.apple.com/library/prerelease/mac/documentation/General/Reference/APIDiffsMacOSX10_10SeedDiff/modules/Darwin.html</span>
                                  kern_return_t rc <span class="operator">=</span> semaphore_timedwait(m_sema<span class="operator">,</span> ts);

                                  <span class="keyword">return</span> rc <span class="operator">!</span><span class="operator">=</span> KERN_OPERATION_TIMED_OUT <span class="operator">&amp;</span><span class="operator">&amp;</span> rc <span class="operator">!</span><span class="operator">=</span> KERN_ABORTED;
                          }

                      <span class="type">void</span> signal() AE_NO_TSAN
                      {
                          semaphore_signal(m_sema);
                      }

                      <span class="type">void</span> signal(<span class="type">int</span> count) AE_NO_TSAN
                      {
                          <span class="keyword">while</span> (count<span class="operator">-</span><span class="operator">-</span> <span class="operator">&gt;</span> <span class="number">0</span>)
                          {
                              semaphore_signal(m_sema);
                          }
                      }
                  };
  <span class="preprocessor">#elif defined(__unix__)</span>
                  <span class="comment">//---------------------------------------------------------</span>
                  <span class="comment">// Semaphore (POSIX, Linux)</span>
                  <span class="comment">//---------------------------------------------------------</span>
                  <span class="keyword">class</span> Semaphore
                  {
                  <span class="keyword">private</span>:
                      sem_t m_sema;

                      Semaphore(<span class="keyword">const</span> Semaphore<span class="operator">&amp;</span> other);
                      Semaphore<span class="operator">&amp;</span> <span class="keyword">operator</span><span class="operator">=</span>(<span class="keyword">const</span> Semaphore<span class="operator">&amp;</span> other);

                  <span class="keyword">public</span>:
                      AE_NO_TSAN Semaphore(<span class="type">int</span> initialCount <span class="operator">=</span> <span class="number">0</span>)
                      {
                          assert(initialCount <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>);
                          sem_init(<span class="operator">&amp;</span>m_sema<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> initialCount);
                      }

                      AE_NO_TSAN <span class="operator">~</span>Semaphore()
                      {
                          sem_destroy(<span class="operator">&amp;</span>m_sema);
                      }

                      <span class="type">void</span> wait() AE_NO_TSAN
                      {
                          <span class="comment">// http://stackoverflow.com/questions/2013181/gdb-causes-sem-wait-to-fail-with-eintr-error</span>
                          <span class="type">int</span> rc;
                          <span class="keyword">do</span>
                          {
                              rc <span class="operator">=</span> sem_wait(<span class="operator">&amp;</span>m_sema);
                          }
                          <span class="keyword">while</span> (rc <span class="operator">=</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> errno <span class="operator">=</span><span class="operator">=</span> EINTR);
                      }

                          bool try_wait() AE_NO_TSAN
                          {
                                  <span class="type">int</span> rc;
                                  <span class="keyword">do</span> {
                                          rc <span class="operator">=</span> sem_trywait(<span class="operator">&amp;</span>m_sema);
                                  } <span class="keyword">while</span> (rc <span class="operator">=</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> errno <span class="operator">=</span><span class="operator">=</span> EINTR);
                                  <span class="keyword">return</span> <span class="operator">!</span>(rc <span class="operator">=</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> errno <span class="operator">=</span><span class="operator">=</span> EAGAIN);
                          }

                          bool timed_wait(std<span class="operator">::</span>uint64_t usecs) AE_NO_TSAN
                          {
                                  <span class="keyword">struct</span> timespec ts;
                                  <span class="keyword">const</span> <span class="type">int</span> usecs_in_1_sec <span class="operator">=</span> <span class="number">1000000</span>;
                                  <span class="keyword">const</span> <span class="type">int</span> nsecs_in_1_sec <span class="operator">=</span> <span class="number">1000000000</span>;
                                  clock_gettime(CLOCK_REALTIME<span class="operator">,</span> <span class="operator">&amp;</span>ts);
                                  ts<span class="operator">.</span>tv_sec <span class="operator">+</span><span class="operator">=</span> usecs <span class="operator">/</span> usecs_in_1_sec;
                                  ts<span class="operator">.</span>tv_nsec <span class="operator">+</span><span class="operator">=</span> (usecs <span class="operator">%</span> usecs_in_1_sec) <span class="operator">*</span> <span class="number">1000</span>;
                                  <span class="comment">// sem_timedwait bombs if you have more than 1e9 in tv_nsec</span>
                                  <span class="comment">// so we have to clean things up before passing it in</span>
                                  <span class="keyword">if</span> (ts<span class="operator">.</span>tv_nsec <span class="operator">&gt;</span><span class="operator">=</span> nsecs_in_1_sec) {
                                          ts<span class="operator">.</span>tv_nsec <span class="operator">-</span><span class="operator">=</span> nsecs_in_1_sec;
                                          <span class="operator">+</span><span class="operator">+</span>ts<span class="operator">.</span>tv_sec;
                                  }

                                  <span class="type">int</span> rc;
                                  <span class="keyword">do</span> {
                                          rc <span class="operator">=</span> sem_timedwait(<span class="operator">&amp;</span>m_sema<span class="operator">,</span> <span class="operator">&amp;</span>ts);
                                  } <span class="keyword">while</span> (rc <span class="operator">=</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> errno <span class="operator">=</span><span class="operator">=</span> EINTR);
                                  <span class="keyword">return</span> <span class="operator">!</span>(rc <span class="operator">=</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> errno <span class="operator">=</span><span class="operator">=</span> ETIMEDOUT);
                          }

                      <span class="type">void</span> signal() AE_NO_TSAN
                      {
                          sem_post(<span class="operator">&amp;</span>m_sema);
                      }

                      <span class="type">void</span> signal(<span class="type">int</span> count) AE_NO_TSAN
                      {
                          <span class="keyword">while</span> (count<span class="operator">-</span><span class="operator">-</span> <span class="operator">&gt;</span> <span class="number">0</span>)
                          {
                              sem_post(<span class="operator">&amp;</span>m_sema);
                          }
                      }
                  };
  <span class="preprocessor">#else</span>
  <span class="preprocessor">#error Unsupported platform! (No semaphore wrapper available)</span>
  <span class="preprocessor">#endif</span>

                  <span class="comment">//---------------------------------------------------------</span>
                  <span class="comment">// LightweightSemaphore</span>
                  <span class="comment">//---------------------------------------------------------</span>
                  <span class="keyword">class</span> LightweightSemaphore
                  {
                  <span class="keyword">public</span>:
                          <span class="keyword">typedef</span> std<span class="operator">::</span>make_signed<span class="operator">&lt;</span>std<span class="operator">::</span>size_t<span class="operator">&gt;</span><span class="operator">::</span>type ssize_t;

                  <span class="keyword">private</span>:
                      weak_atomic<span class="operator">&lt;</span>ssize_t<span class="operator">&gt;</span> m_count;
                      Semaphore m_sema;

                      bool waitWithPartialSpinning(std<span class="operator">::</span>int64_t timeout_usecs <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) AE_NO_TSAN
                      {
                          ssize_t oldCount;
                          <span class="comment">// Is there a better way to set the initial spin count?</span>
                          <span class="comment">// If we lower it to 1000, testBenaphore becomes 15x slower on my Core i7-5930K Windows PC,</span>
                          <span class="comment">// as threads start hitting the kernel semaphore.</span>
                          <span class="type">int</span> spin <span class="operator">=</span> <span class="number">10000</span>;
                          <span class="keyword">while</span> (<span class="operator">-</span><span class="operator">-</span>spin <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>)
                          {
                              <span class="keyword">if</span> (m_count<span class="operator">.</span>load() <span class="operator">&gt;</span> <span class="number">0</span>)
                              {
                                  m_count<span class="operator">.</span>fetch_add_acquire(<span class="operator">-</span><span class="number">1</span>);
                                  <span class="keyword">return</span> <span class="keyword">true</span>;
                              }
                              compiler_fence(memory_order_acquire);     <span class="comment">// Prevent the compiler from collapsing the loop.</span>
                          }
                          oldCount <span class="operator">=</span> m_count<span class="operator">.</span>fetch_add_acquire(<span class="operator">-</span><span class="number">1</span>);
                                  <span class="keyword">if</span> (oldCount <span class="operator">&gt;</span> <span class="number">0</span>)
                                          <span class="keyword">return</span> <span class="keyword">true</span>;
                          <span class="keyword">if</span> (timeout_usecs <span class="operator">&lt;</span> <span class="number">0</span>)
                                  {
                                          m_sema<span class="operator">.</span>wait();
                                          <span class="keyword">return</span> <span class="keyword">true</span>;
                                  }
                                  <span class="keyword">if</span> (m_sema<span class="operator">.</span>timed_wait(timeout_usecs))
                                          <span class="keyword">return</span> <span class="keyword">true</span>;
                                  <span class="comment">// At this point, we've timed out waiting for the semaphore, but the</span>
                                  <span class="comment">// count is still decremented indicating we may still be waiting on</span>
                                  <span class="comment">// it. So we have to re-adjust the count, but only if the semaphore</span>
                                  <span class="comment">// wasn't signaled enough times for us too since then. If it was, we</span>
                                  <span class="comment">// need to release the semaphore too.</span>
                                  <span class="keyword">while</span> (<span class="keyword">true</span>)
                                  {
                                          oldCount <span class="operator">=</span> m_count<span class="operator">.</span>fetch_add_release(<span class="number">1</span>);
                                          <span class="keyword">if</span> (oldCount <span class="operator">&lt;</span> <span class="number">0</span>)
                                                  <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">// successfully restored things to the way they were</span>
                                          <span class="comment">// Oh, the producer thread just signaled the semaphore after all. Try again:</span>
                                          oldCount <span class="operator">=</span> m_count<span class="operator">.</span>fetch_add_acquire(<span class="operator">-</span><span class="number">1</span>);
                                          <span class="keyword">if</span> (oldCount <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> m_sema<span class="operator">.</span>try_wait())
                                                  <span class="keyword">return</span> <span class="keyword">true</span>;
                                  }
                      }

                  <span class="keyword">public</span>:
                      AE_NO_TSAN LightweightSemaphore(ssize_t initialCount <span class="operator">=</span> <span class="number">0</span>) : m_count(initialCount)
                      {
                          assert(initialCount <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>);
                      }

                      bool tryWait() AE_NO_TSAN
                      {
                          <span class="keyword">if</span> (m_count<span class="operator">.</span>load() <span class="operator">&gt;</span> <span class="number">0</span>)
                          {
                                  m_count<span class="operator">.</span>fetch_add_acquire(<span class="operator">-</span><span class="number">1</span>);
                                  <span class="keyword">return</span> <span class="keyword">true</span>;
                          }
                          <span class="keyword">return</span> <span class="keyword">false</span>;
                      }

                      <span class="type">void</span> wait() AE_NO_TSAN
                      {
                          <span class="keyword">if</span> (<span class="operator">!</span>tryWait())
                              waitWithPartialSpinning();
                      }

                          bool wait(std<span class="operator">::</span>int64_t timeout_usecs) AE_NO_TSAN
                          {
                                  <span class="keyword">return</span> tryWait() <span class="operator">|</span><span class="operator">|</span> waitWithPartialSpinning(timeout_usecs);
                          }

                      <span class="type">void</span> signal(ssize_t count <span class="operator">=</span> <span class="number">1</span>) AE_NO_TSAN
                      {
                          assert(count <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>);
                          ssize_t oldCount <span class="operator">=</span> m_count<span class="operator">.</span>fetch_add_release(count);
                          assert(oldCount <span class="operator">&gt;</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>);
                          <span class="keyword">if</span> (oldCount <span class="operator">&lt;</span> <span class="number">0</span>)
                          {
                              m_sema<span class="operator">.</span>signal(<span class="number">1</span>);
                          }
                      }

                      ssize_t availableApprox() <span class="keyword">const</span> AE_NO_TSAN
                      {
                          ssize_t count <span class="operator">=</span> m_count<span class="operator">.</span>load();
                          <span class="keyword">return</span> count <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">?</span> count : <span class="number">0</span>;
                      }
                  };
          }       <span class="comment">// end namespace spsc_sema</span>
  }       <span class="comment">// end namespace moodycamel</span>

  <span class="preprocessor">#if defined(AE_VCPP) &amp;&amp; (_MSC_VER &lt; 1700 || defined(__cplusplus_cli))</span>
  <span class="preprocessor">#pragma warning(pop)</span>
  <span class="preprocessor">#ifdef __cplusplus_cli</span>
  <span class="preprocessor">#pragma managed(pop)</span>
  <span class="preprocessor">#endif</span>
  <span class="preprocessor">#endif</span>

</pre>
