<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- music-box.qdoc -->
  <title>Kuesa Music Box QML Example | Kuesa Runtime 1.2</title>
<link rel='stylesheet' href='style/bootstrap.min.css'> <link rel='stylesheet' href='style/dracula.css'> <link rel='stylesheet' href='style/style.css'><script type='text/javascript' src='scripts/jquery.slim.min.js'></script> <script type='text/javascript' src='scripts/bootstrap.bundle.min.js'></script> <script type='text/javascript' src='scripts/highlight.pack.js'></script> <script type='text/javascript' src='scripts/clipboard.min.js'></script> <script type='text/javascript' src='scripts/script.js'></script></head>
<div id="title"> <div class="logo"> <a href="https://www.kdab.com" target=”_blank” class="ui-link"> <img src="images/kdab-logo.png" alt="KDAB Logo"> </a> </div> <div class="header"> <h1>Kuesa Runtime</h1> </div> </div> <div id="breadcrumbs"><ul><li><a href="index.html">Kuesa Runtime 1.2</a></li>
<li><a href="kuesa-overview.html#kuesa-runtime">Kuesa Runtime</a></li>
<li>Kuesa Music Box QML Example</li>
<li id="buildversion"><a href="kuesa-overview.html#kuesa-runtime">Kuesa Runtime 1.2 Reference Documentation</a></li>
</ul></div><div class='doc-content'><h1 class="title">Kuesa Music Box QML Example</h1>
<span class="subtitle"></span>
<pre class="cpp">
 <span class="comment">// WAV audio loader and writer. Public domain. See &quot;unlicense&quot; statement at the end of this file.</span>
 <span class="comment">// dr_wav - v0.9.0 - 2018-12-16</span>
 <span class="comment">//</span>
 <span class="comment">// David Reid - mackron@gmail.com</span>

 <span class="comment">/*
 DEPRECATED APIS
 ===============
 Version 0.9.0 deprecated the per-sample reading and seeking APIs and replaced them with versions that work on the resolution
 of a PCM frame instead. For example, given a stereo WAV file, previously you would pass 2 to drwav_read_f32() to read one
 PCM frame, whereas now you would pass in 1 to drwav_read_pcm_frames_f32(). The old APIs would return the number of samples
 read, whereas now it will return the number of PCM frames. Below is a list of APIs that have been deprecated and their
 replacements.

     drwav_read()                     -&gt; drwav_read_pcm_frames()
     drwav_read_s16()                 -&gt; drwav_read_pcm_frames_s16()
     drwav_read_f32()                 -&gt; drwav_read_pcm_frames_f32()
     drwav_read_s32()                 -&gt; drwav_read_pcm_frames_s32()
     drwav_seek_to_sample()           -&gt; drwav_seek_to_pcm_frame()
     drwav_write()                    -&gt; drwav_write_pcm_frames()
     drwav_open_and_read_s16()        -&gt; drwav_open_and_read_pcm_frames_s16()
     drwav_open_and_read_f32()        -&gt; drwav_open_and_read_pcm_frames_f32()
     drwav_open_and_read_s32()        -&gt; drwav_open_and_read_pcm_frames_s32()
     drwav_open_file_and_read_s16()   -&gt; drwav_open_file_and_read_pcm_frames_s16()
     drwav_open_file_and_read_f32()   -&gt; drwav_open_file_and_read_pcm_frames_f32()
     drwav_open_file_and_read_s32()   -&gt; drwav_open_file_and_read_pcm_frames_s32()
     drwav_open_memory_and_read_s16() -&gt; drwav_open_memory_and_read_pcm_frames_s16()
     drwav_open_memory_and_read_f32() -&gt; drwav_open_memory_and_read_pcm_frames_f32()
     drwav_open_memory_and_read_s32() -&gt; drwav_open_memory_and_read_pcm_frames_s32()
     drwav::totalSampleCount          -&gt; drwav::totalPCMFrameCount

 Rationale:
     1) Most programs will want to read in multiples of the channel count which demands a per-frame reading API. Per-sample
        reading just adds complexity and maintenance costs for no practical benefit.
     2) This is consistent with my other decoders - dr_flac and dr_mp3.

 These APIs will be removed completely in version 0.10.0. You can continue to use drwav_read_raw() if you need per-sample
 reading.
 */</span>

 <span class="comment">// USAGE</span>
 <span class="comment">//</span>
 <span class="comment">// This is a single-file library. To use it, do something like the following in one .c file.</span>
 <span class="comment">//     #define DR_WAV_IMPLEMENTATION</span>
 <span class="comment">//     #include &quot;dr_wav.h&quot;</span>
 <span class="comment">//</span>
 <span class="comment">// You can then #include this file in other parts of the program as you would with any other header file. Do something</span>
 <span class="comment">// like the following to read audio data:</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav wav;</span>
 <span class="comment">//     if (!drwav_init_file(&amp;wav, &quot;my_song.wav&quot;)) {</span>
 <span class="comment">//         // Error opening WAV file.</span>
 <span class="comment">//     }</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav_int32* pDecodedInterleavedSamples = malloc(wav.totalPCMFrameCount * wav.channels * sizeof(drwav_int32));</span>
 <span class="comment">//     size_t numberOfSamplesActuallyDecoded = drwav_read_pcm_frames_s32(&amp;wav, wav.totalPCMFrameCount, pDecodedInterleavedSamples);</span>
 <span class="comment">//</span>
 <span class="comment">//     ...</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav_uninit(&amp;wav);</span>
 <span class="comment">//</span>
 <span class="comment">// You can also use drwav_open() to allocate and initialize the loader for you:</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav* pWav = drwav_open_file(&quot;my_song.wav&quot;);</span>
 <span class="comment">//     if (pWav == NULL) {</span>
 <span class="comment">//         // Error opening WAV file.</span>
 <span class="comment">//     }</span>
 <span class="comment">//</span>
 <span class="comment">//     ...</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav_close(pWav);</span>
 <span class="comment">//</span>
 <span class="comment">// If you just want to quickly open and read the audio data in a single operation you can do something like this:</span>
 <span class="comment">//</span>
 <span class="comment">//     unsigned int channels;</span>
 <span class="comment">//     unsigned int sampleRate;</span>
 <span class="comment">//     drwav_uint64 totalPCMFrameCount;</span>
 <span class="comment">//     float* pSampleData = drwav_open_file_and_read_pcm_frames_f32(&quot;my_song.wav&quot;, &amp;channels, &amp;sampleRate, &amp;totalPCMFrameCount);</span>
 <span class="comment">//     if (pSampleData == NULL) {</span>
 <span class="comment">//         // Error opening and reading WAV file.</span>
 <span class="comment">//     }</span>
 <span class="comment">//</span>
 <span class="comment">//     ...</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav_free(pSampleData);</span>
 <span class="comment">//</span>
 <span class="comment">// The examples above use versions of the API that convert the audio data to a consistent format (32-bit signed PCM, in</span>
 <span class="comment">// this case), but you can still output the audio data in its internal format (see notes below for supported formats):</span>
 <span class="comment">//</span>
 <span class="comment">//     size_t samplesRead = drwav_read_pcm_frames(&amp;wav, wav.totalPCMFrameCount, pDecodedInterleavedSamples);</span>
 <span class="comment">//</span>
 <span class="comment">// You can also read the raw bytes of audio data, which could be useful if dr_wav does not have native support for</span>
 <span class="comment">// a particular data format:</span>
 <span class="comment">//</span>
 <span class="comment">//     size_t bytesRead = drwav_read_raw(&amp;wav, bytesToRead, pRawDataBuffer);</span>
 <span class="comment">//</span>
 <span class="comment">//</span>
 <span class="comment">// dr_wav can also be used to output WAV files. This does not currently support compressed formats. To use this, look at</span>
 <span class="comment">// drwav_open_write(), drwav_open_file_write(), etc. Use drwav_write_pcm_frames() to write samples, or drwav_write_raw()</span>
 <span class="comment">// to write raw data in the &quot;data&quot; chunk.</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav_data_format format;</span>
 <span class="comment">//     format.container = drwav_container_riff;     // &lt;-- drwav_container_riff = normal WAV files, drwav_container_w64 = Sony Wave64.</span>
 <span class="comment">//     format.format = DR_WAVE_FORMAT_PCM;          // &lt;-- Any of the DR_WAVE_FORMAT_* codes.</span>
 <span class="comment">//     format.channels = 2;</span>
 <span class="comment">//     format.sampleRate = 44100;</span>
 <span class="comment">//     format.bitsPerSample = 16;</span>
 <span class="comment">//     drwav* pWav = drwav_open_file_write(&quot;data/recording.wav&quot;, &amp;format);</span>
 <span class="comment">//</span>
 <span class="comment">//     ...</span>
 <span class="comment">//</span>
 <span class="comment">//     drwav_uint64 samplesWritten = drwav_write_pcm_frames(pWav, frameCount, pSamples);</span>
 <span class="comment">//</span>
 <span class="comment">//</span>
 <span class="comment">// dr_wav has seamless support the Sony Wave64 format. The decoder will automatically detect it and it should Just Work</span>
 <span class="comment">// without any manual intervention.</span>
 <span class="comment">//</span>
 <span class="comment">//</span>
 <span class="comment">// OPTIONS</span>
 <span class="comment">// #define these options before including this file.</span>
 <span class="comment">//</span>
 <span class="comment">// #define DR_WAV_NO_CONVERSION_API</span>
 <span class="comment">//   Disables conversion APIs such as drwav_read_pcm_frames_f32() and drwav_s16_to_f32().</span>
 <span class="comment">//</span>
 <span class="comment">// #define DR_WAV_NO_STDIO</span>
 <span class="comment">//   Disables drwav_open_file(), drwav_open_file_write(), etc.</span>
 <span class="comment">//</span>
 <span class="comment">//</span>
 <span class="comment">//</span>
 <span class="comment">// QUICK NOTES</span>
 <span class="comment">// - Samples are always interleaved.</span>
 <span class="comment">// - The default read function does not do any data conversion. Use drwav_read_pcm_frames_f32(), drwav_read_pcm_frames_s32()</span>
 <span class="comment">//   and drwav_read_pcm_frames_s16() to read and convert audio data to 32-bit floating point, signed 32-bit integer and</span>
 <span class="comment">//   signed 16-bit integer samples respectively. Tested and supported internal formats include the following:</span>
 <span class="comment">//   - Unsigned 8-bit PCM</span>
 <span class="comment">//   - Signed 12-bit PCM</span>
 <span class="comment">//   - Signed 16-bit PCM</span>
 <span class="comment">//   - Signed 24-bit PCM</span>
 <span class="comment">//   - Signed 32-bit PCM</span>
 <span class="comment">//   - IEEE 32-bit floating point</span>
 <span class="comment">//   - IEEE 64-bit floating point</span>
 <span class="comment">//   - A-law and u-law</span>
 <span class="comment">//   - Microsoft ADPCM</span>
 <span class="comment">//   - IMA ADPCM (DVI, format code 0x11)</span>
 <span class="comment">// - dr_wav will try to read the WAV file as best it can, even if it's not strictly conformant to the WAV format.</span>

 <span class="preprocessor">#ifndef dr_wav_h</span>
 <span class="preprocessor">#define dr_wav_h</span>

 <span class="preprocessor">#include &lt;stddef.h&gt;</span>

 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1600</span>
 <span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">char</span>    drwav_int8;
 <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>    drwav_uint8;
 <span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">short</span>   drwav_int16;
 <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>   drwav_uint16;
 <span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">int</span>     drwav_int32;
 <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>     drwav_uint32;
 <span class="keyword">typedef</span>   <span class="type">signed</span> __int64 drwav_int64;
 <span class="keyword">typedef</span> <span class="type">unsigned</span> __int64 drwav_uint64;
 <span class="preprocessor">#else</span>
 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
 <span class="keyword">typedef</span> int8_t           drwav_int8;
 <span class="keyword">typedef</span> uint8_t          drwav_uint8;
 <span class="keyword">typedef</span> int16_t          drwav_int16;
 <span class="keyword">typedef</span> uint16_t         drwav_uint16;
 <span class="keyword">typedef</span> int32_t          drwav_int32;
 <span class="keyword">typedef</span> uint32_t         drwav_uint32;
 <span class="keyword">typedef</span> int64_t          drwav_int64;
 <span class="keyword">typedef</span> uint64_t         drwav_uint64;
 <span class="preprocessor">#endif</span>
 <span class="keyword">typedef</span> drwav_uint8      drwav_bool8;
 <span class="keyword">typedef</span> drwav_uint32     drwav_bool32;
 <span class="preprocessor">#define DRWAV_TRUE       1</span>
 <span class="preprocessor">#define DRWAV_FALSE      0</span>

 <span class="preprocessor">#ifdef __cplusplus</span>
 <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> {
 <span class="preprocessor">#endif</span>

 <span class="comment">// Common data formats.</span>
 <span class="preprocessor">#define DR_WAVE_FORMAT_PCM          0x1</span>
 <span class="preprocessor">#define DR_WAVE_FORMAT_ADPCM        0x2</span>
 <span class="preprocessor">#define DR_WAVE_FORMAT_IEEE_FLOAT   0x3</span>
 <span class="preprocessor">#define DR_WAVE_FORMAT_ALAW         0x6</span>
 <span class="preprocessor">#define DR_WAVE_FORMAT_MULAW        0x7</span>
 <span class="preprocessor">#define DR_WAVE_FORMAT_DVI_ADPCM    0x11</span>
 <span class="preprocessor">#define DR_WAVE_FORMAT_EXTENSIBLE   0xFFFE</span>

 <span class="comment">// Constants.</span>
 <span class="preprocessor">#ifndef DRWAV_MAX_SMPL_LOOPS</span>
 <span class="preprocessor">#define DRWAV_MAX_SMPL_LOOPS        1</span>
 <span class="preprocessor">#endif</span>

 <span class="comment">// Flags to pass into drwav_init_ex(), etc.</span>
 <span class="preprocessor">#define DRWAV_SEQUENTIAL            0x00000001</span>

 <span class="keyword">typedef</span> <span class="keyword">enum</span>
 {
     drwav_seek_origin_start<span class="operator">,</span>
     drwav_seek_origin_current
 } drwav_seek_origin;

 <span class="keyword">typedef</span> <span class="keyword">enum</span>
 {
     drwav_container_riff<span class="operator">,</span>
     drwav_container_w64
 } drwav_container;

 <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     <span class="keyword">union</span>
     {
         drwav_uint8 fourcc<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;
         drwav_uint8 guid<span class="operator">[</span><span class="number">16</span><span class="operator">]</span>;
     } id;

     <span class="comment">// The size in bytes of the chunk.</span>
     drwav_uint64 sizeInBytes;

     <span class="comment">// RIFF = 2 byte alignment.</span>
     <span class="comment">// W64  = 8 byte alignment.</span>
     <span class="type">unsigned</span> <span class="type">int</span> paddingSize;
 } drwav_chunk_header;

 <span class="comment">// Callback for when data is read. Return value is the number of bytes actually read.</span>
 <span class="comment">//</span>
 <span class="comment">// pUserData   [in]  The user data that was passed to drwav_init(), drwav_open() and family.</span>
 <span class="comment">// pBufferOut  [out] The output buffer.</span>
 <span class="comment">// bytesToRead [in]  The number of bytes to read.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of bytes actually read.</span>
 <span class="comment">//</span>
 <span class="comment">// A return value of less than bytesToRead indicates the end of the stream. Do _not_ return from this callback until</span>
 <span class="comment">// either the entire bytesToRead is filled or you have reached the end of the stream.</span>
 <span class="keyword">typedef</span> size_t (<span class="operator">*</span> drwav_read_proc)(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut<span class="operator">,</span> size_t bytesToRead);

 <span class="comment">// Callback for when data is written. Returns value is the number of bytes actually written.</span>
 <span class="comment">//</span>
 <span class="comment">// pUserData    [in]  The user data that was passed to drwav_init_write(), drwav_open_write() and family.</span>
 <span class="comment">// pData        [out] A pointer to the data to write.</span>
 <span class="comment">// bytesToWrite [in]  The number of bytes to write.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of bytes actually written.</span>
 <span class="comment">//</span>
 <span class="comment">// If the return value differs from bytesToWrite, it indicates an error.</span>
 <span class="keyword">typedef</span> size_t (<span class="operator">*</span> drwav_write_proc)(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData<span class="operator">,</span> size_t bytesToWrite);

 <span class="comment">// Callback for when data needs to be seeked.</span>
 <span class="comment">//</span>
 <span class="comment">// pUserData [in] The user data that was passed to drwav_init(), drwav_open() and family.</span>
 <span class="comment">// offset    [in] The number of bytes to move, relative to the origin. Will never be negative.</span>
 <span class="comment">// origin    [in] The origin of the seek - the current position or the start of the stream.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns whether or not the seek was successful.</span>
 <span class="comment">//</span>
 <span class="comment">// Whether or not it is relative to the beginning or current position is determined by the &quot;origin&quot; parameter which</span>
 <span class="comment">// will be either drwav_seek_origin_start or drwav_seek_origin_current.</span>
 <span class="keyword">typedef</span> drwav_bool32 (<span class="operator">*</span> drwav_seek_proc)(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">int</span> offset<span class="operator">,</span> drwav_seek_origin origin);

 <span class="comment">// Callback for when drwav_init_ex/drwav_open_ex finds a chunk.</span>
 <span class="comment">//</span>
 <span class="comment">// pChunkUserData    [in] The user data that was passed to the pChunkUserData parameter of drwav_init_ex(), drwav_open_ex() and family.</span>
 <span class="comment">// onRead            [in] A pointer to the function to call when reading.</span>
 <span class="comment">// onSeek            [in] A pointer to the function to call when seeking.</span>
 <span class="comment">// pReadSeekUserData [in] The user data that was passed to the pReadSeekUserData parameter of drwav_init_ex(), drwav_open_ex() and family.</span>
 <span class="comment">// pChunkHeader      [in] A pointer to an object containing basic header information about the chunk. Use this to identify the chunk.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of bytes read + seeked.</span>
 <span class="comment">//</span>
 <span class="comment">// To read data from the chunk, call onRead(), passing in pReadSeekUserData as the first parameter. Do the same</span>
 <span class="comment">// for seeking with onSeek(). The return value must be the total number of bytes you have read _plus_ seeked.</span>
 <span class="comment">//</span>
 <span class="comment">// You must not attempt to read beyond the boundary of the chunk.</span>
 <span class="keyword">typedef</span> drwav_uint64 (<span class="operator">*</span> drwav_chunk_proc)(<span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pReadSeekUserData<span class="operator">,</span> <span class="keyword">const</span> drwav_chunk_header<span class="operator">*</span> pChunkHeader);

 <span class="comment">// Structure for internal use. Only used for loaders opened with drwav_open_memory().</span>
 <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> data;
     size_t dataSize;
     size_t currentReadPos;
 } drwav__memory_stream;

 <span class="comment">// Structure for internal use. Only used for writers opened with drwav_open_memory_write().</span>
 <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     <span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData;
     size_t<span class="operator">*</span> pDataSize;
     size_t dataSize;
     size_t dataCapacity;
     size_t currentWritePos;
 } drwav__memory_stream_write;

 <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     drwav_container container;  <span class="comment">// RIFF, W64.</span>
     drwav_uint32 format;        <span class="comment">// DR_WAVE_FORMAT_*</span>
     drwav_uint32 channels;
     drwav_uint32 sampleRate;
     drwav_uint32 bitsPerSample;
 } drwav_data_format;

 <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     <span class="comment">// The format tag exactly as specified in the wave file's &quot;fmt&quot; chunk. This can be used by applications</span>
     <span class="comment">// that require support for data formats not natively supported by dr_wav.</span>
     drwav_uint16 formatTag;

     <span class="comment">// The number of channels making up the audio data. When this is set to 1 it is mono, 2 is stereo, etc.</span>
     drwav_uint16 channels;

     <span class="comment">// The sample rate. Usually set to something like 44100.</span>
     drwav_uint32 sampleRate;

     <span class="comment">// Average bytes per second. You probably don't need this, but it's left here for informational purposes.</span>
     drwav_uint32 avgBytesPerSec;

     <span class="comment">// Block align. This is equal to the number of channels * bytes per sample.</span>
     drwav_uint16 blockAlign;

     <span class="comment">// Bits per sample.</span>
     drwav_uint16 bitsPerSample;

     <span class="comment">// The size of the extended data. Only used internally for validation, but left here for informational purposes.</span>
     drwav_uint16 extendedSize;

     <span class="comment">// The number of valid bits per sample. When &lt;formatTag&gt; is equal to WAVE_FORMAT_EXTENSIBLE, &lt;bitsPerSample&gt;</span>
     <span class="comment">// is always rounded up to the nearest multiple of 8. This variable contains information about exactly how</span>
     <span class="comment">// many bits a valid per sample. Mainly used for informational purposes.</span>
     drwav_uint16 validBitsPerSample;

     <span class="comment">// The channel mask. Not used at the moment.</span>
     drwav_uint32 channelMask;

     <span class="comment">// The sub-format, exactly as specified by the wave file.</span>
     drwav_uint8 subFormat<span class="operator">[</span><span class="number">16</span><span class="operator">]</span>;
 } drwav_fmt;

 <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     drwav_uint32 cuePointId;
     drwav_uint32 type;
     drwav_uint32 start;
     drwav_uint32 end;
     drwav_uint32 fraction;
     drwav_uint32 playCount;
 } drwav_smpl_loop;

  <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     drwav_uint32 manufacturer;
     drwav_uint32 product;
     drwav_uint32 samplePeriod;
     drwav_uint32 midiUnityNotes;
     drwav_uint32 midiPitchFraction;
     drwav_uint32 smpteFormat;
     drwav_uint32 smpteOffset;
     drwav_uint32 numSampleLoops;
     drwav_uint32 samplerData;
     drwav_smpl_loop loops<span class="operator">[</span>DRWAV_MAX_SMPL_LOOPS<span class="operator">]</span>;
 } drwav_smpl;

 <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
     <span class="comment">// A pointer to the function to call when more data is needed.</span>
     drwav_read_proc onRead;

     <span class="comment">// A pointer to the function to call when data needs to be written. Only used when the drwav object is opened in write mode.</span>
     drwav_write_proc onWrite;

     <span class="comment">// A pointer to the function to call when the wav file needs to be seeked.</span>
     drwav_seek_proc onSeek;

     <span class="comment">// The user data to pass to callbacks.</span>
     <span class="type">void</span><span class="operator">*</span> pUserData;

     <span class="comment">// Whether or not the WAV file is formatted as a standard RIFF file or W64.</span>
     drwav_container container;

     <span class="comment">// Structure containing format information exactly as specified by the wav file.</span>
     drwav_fmt fmt;

     <span class="comment">// The sample rate. Will be set to something like 44100.</span>
     drwav_uint32 sampleRate;

     <span class="comment">// The number of channels. This will be set to 1 for monaural streams, 2 for stereo, etc.</span>
     drwav_uint16 channels;

     <span class="comment">// The bits per sample. Will be set to something like 16, 24, etc.</span>
     drwav_uint16 bitsPerSample;

     <span class="comment">// Equal to fmt.formatTag, or the value specified by fmt.subFormat if fmt.formatTag is equal to 65534 (WAVE_FORMAT_EXTENSIBLE).</span>
     drwav_uint16 translatedFormatTag;

     <span class="comment">// The total number of PCM frames making up the audio data.</span>
     drwav_uint64 totalPCMFrameCount;

     <span class="comment">// The size in bytes of the data chunk.</span>
     drwav_uint64 dataChunkDataSize;

     <span class="comment">// The position in the stream of the first byte of the data chunk. This is used for seeking.</span>
     drwav_uint64 dataChunkDataPos;

     <span class="comment">// The number of bytes remaining in the data chunk.</span>
     drwav_uint64 bytesRemaining;

     <span class="comment">// Only used in sequential write mode. Keeps track of the desired size of the &quot;data&quot; chunk at the point of initialization time. Always</span>
     <span class="comment">// set to 0 for non-sequential writes and when the drwav object is opened in read mode. Used for validation.</span>
     drwav_uint64 dataChunkDataSizeTargetWrite;

     <span class="comment">// Keeps track of whether or not the wav writer was initialized in sequential mode.</span>
     drwav_bool32 isSequentialWrite;

     <span class="comment">// smpl chunk.</span>
     drwav_smpl smpl;

     <span class="comment">// A hack to avoid a DRWAV_MALLOC() when opening a decoder with drwav_open_memory().</span>
     drwav__memory_stream memoryStream;
     drwav__memory_stream_write memoryStreamWrite;

     <span class="comment">// Generic data for compressed formats. This data is shared across all block-compressed formats.</span>
     <span class="keyword">struct</span>
     {
         drwav_uint64 iCurrentSample;    <span class="comment">// The index of the next sample that will be read by drwav_read_*(). This is used with &quot;totalSampleCount&quot; to ensure we don't read excess samples at the end of the last block.</span>
     } compressed;

     <span class="comment">// Microsoft ADPCM specific data.</span>
     <span class="keyword">struct</span>
     {
         drwav_uint32 bytesRemainingInBlock;
         drwav_uint16 predictor<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
         drwav_int32  delta<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
         drwav_int32  cachedSamples<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;  <span class="comment">// Samples are stored in this cache during decoding.</span>
         drwav_uint32 cachedSampleCount;
         drwav_int32  prevSamples<span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span>; <span class="comment">// The previous 2 samples for each channel (2 channels at most).</span>
     } msadpcm;

     <span class="comment">// IMA ADPCM specific data.</span>
     <span class="keyword">struct</span>
     {
         drwav_uint32 bytesRemainingInBlock;
         drwav_int32  predictor<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
         drwav_int32  stepIndex<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
         drwav_int32  cachedSamples<span class="operator">[</span><span class="number">16</span><span class="operator">]</span>; <span class="comment">// Samples are stored in this cache during decoding.</span>
         drwav_uint32 cachedSampleCount;
     } ima;

     drwav_uint64 totalSampleCount;  <span class="comment">// &lt;-- DEPRECATED. Will be removed in a future version.</span>
 } drwav;

 <span class="comment">// Initializes a pre-allocated drwav object.</span>
 <span class="comment">//</span>
 <span class="comment">// pWav                         [out]          A pointer to the drwav object being initialized.</span>
 <span class="comment">// onRead                       [in]           The function to call when data needs to be read from the client.</span>
 <span class="comment">// onSeek                       [in]           The function to call when the read position of the client data needs to move.</span>
 <span class="comment">// onChunk                      [in, optional] The function to call when a chunk is enumerated at initialized time.</span>
 <span class="comment">// pUserData, pReadSeekUserData [in, optional] A pointer to application defined data that will be passed to onRead and onSeek.</span>
 <span class="comment">// pChunkUserData               [in, optional] A pointer to application defined data that will be passed to onChunk.</span>
 <span class="comment">// flags                        [in, optional] A set of flags for controlling how things are loaded.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns true if successful; false otherwise.</span>
 <span class="comment">//</span>
 <span class="comment">// Close the loader with drwav_uninit().</span>
 <span class="comment">//</span>
 <span class="comment">// This is the lowest level function for initializing a WAV file. You can also use drwav_init_file() and drwav_init_memory()</span>
 <span class="comment">// to open the stream from a file or from a block of memory respectively.</span>
 <span class="comment">//</span>
 <span class="comment">// If you want dr_wav to manage the memory allocation for you, consider using drwav_open() instead. This will allocate</span>
 <span class="comment">// a drwav object on the heap and return a pointer to it.</span>
 <span class="comment">//</span>
 <span class="comment">// Possible values for flags:</span>
 <span class="comment">//   DRWAV_SEQUENTIAL: Never perform a backwards seek while loading. This disables the chunk callback and will cause this function</span>
 <span class="comment">//                     to return as soon as the data chunk is found. Any chunks after the data chunk will be ignored.</span>
 <span class="comment">//</span>
 <span class="comment">// drwav_init() is equivalent to &quot;drwav_init_ex(pWav, onRead, onSeek, NULL, pUserData, NULL, 0);&quot;.</span>
 <span class="comment">//</span>
 <span class="comment">// The onChunk callback is not called for the WAVE or FMT chunks. The contents of the FMT chunk can be read from pWav-&gt;fmt</span>
 <span class="comment">// after the function returns.</span>
 <span class="comment">//</span>
 <span class="comment">// See also: drwav_init_file(), drwav_init_memory(), drwav_uninit()</span>
 drwav_bool32 drwav_init(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);
 drwav_bool32 drwav_init_ex(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pReadSeekUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags);

 <span class="comment">// Initializes a pre-allocated drwav object for writing.</span>
 <span class="comment">//</span>
 <span class="comment">// onWrite   [in]           The function to call when data needs to be written.</span>
 <span class="comment">// onSeek    [in]           The function to call when the write position needs to move.</span>
 <span class="comment">// pUserData [in, optional] A pointer to application defined data that will be passed to onWrite and onSeek.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns true if successful; false otherwise.</span>
 <span class="comment">//</span>
 <span class="comment">// Close the writer with drwav_uninit().</span>
 <span class="comment">//</span>
 <span class="comment">// This is the lowest level function for initializing a WAV file. You can also use drwav_init_file() and drwav_init_memory()</span>
 <span class="comment">// to open the stream from a file or from a block of memory respectively.</span>
 <span class="comment">//</span>
 <span class="comment">// If the total sample count is known, you can use drwav_init_write_sequential(). This avoids the need for dr_wav to perform</span>
 <span class="comment">// a post-processing step for storing the total sample count and the size of the data chunk which requires a backwards seek.</span>
 <span class="comment">//</span>
 <span class="comment">// If you want dr_wav to manage the memory allocation for you, consider using drwav_open() instead. This will allocate</span>
 <span class="comment">// a drwav object on the heap and return a pointer to it.</span>
 <span class="comment">//</span>
 <span class="comment">// See also: drwav_init_file_write(), drwav_init_memory_write(), drwav_uninit()</span>
 drwav_bool32 drwav_init_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);
 drwav_bool32 drwav_init_write_sequential(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);

 <span class="comment">// Uninitializes the given drwav object.</span>
 <span class="comment">//</span>
 <span class="comment">// Use this only for objects initialized with drwav_init().</span>
 <span class="type">void</span> drwav_uninit(drwav<span class="operator">*</span> pWav);

 <span class="comment">// Opens a wav file using the given callbacks.</span>
 <span class="comment">//</span>
 <span class="comment">// onRead    [in]           The function to call when data needs to be read from the client.</span>
 <span class="comment">// onSeek    [in]           The function to call when the read position of the client data needs to move.</span>
 <span class="comment">// pUserData [in, optional] A pointer to application defined data that will be passed to onRead and onSeek.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns null on error.</span>
 <span class="comment">//</span>
 <span class="comment">// Close the loader with drwav_close().</span>
 <span class="comment">//</span>
 <span class="comment">// You can also use drwav_open_file() and drwav_open_memory() to open the stream from a file or from a block of</span>
 <span class="comment">// memory respectively.</span>
 <span class="comment">//</span>
 <span class="comment">// This is different from drwav_init() in that it will allocate the drwav object for you via DRWAV_MALLOC() before</span>
 <span class="comment">// initializing it.</span>
 <span class="comment">//</span>
 <span class="comment">// See also: drwav_init(), drwav_open_file(), drwav_open_memory(), drwav_close()</span>
 drwav<span class="operator">*</span> drwav_open(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);
 drwav<span class="operator">*</span> drwav_open_ex(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pReadSeekUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags);

 <span class="comment">// Opens a wav file for writing using the given callbacks.</span>
 <span class="comment">//</span>
 <span class="comment">// onWrite   [in]           The function to call when data needs to be written.</span>
 <span class="comment">// onSeek    [in]           The function to call when the write position needs to move.</span>
 <span class="comment">// pUserData [in, optional] A pointer to application defined data that will be passed to onWrite and onSeek.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns null on error.</span>
 <span class="comment">//</span>
 <span class="comment">// Close the loader with drwav_close().</span>
 <span class="comment">//</span>
 <span class="comment">// You can also use drwav_open_file_write() and drwav_open_memory_write() to open the stream from a file or from a block</span>
 <span class="comment">// of memory respectively.</span>
 <span class="comment">//</span>
 <span class="comment">// This is different from drwav_init_write() in that it will allocate the drwav object for you via DRWAV_MALLOC() before</span>
 <span class="comment">// initializing it.</span>
 <span class="comment">//</span>
 <span class="comment">// See also: drwav_open_file_write(), drwav_open_memory_write(), drwav_close()</span>
 drwav<span class="operator">*</span> drwav_open_write(<span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);
 drwav<span class="operator">*</span> drwav_open_write_sequential(<span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);

 <span class="comment">// Uninitializes and deletes the the given drwav object.</span>
 <span class="comment">//</span>
 <span class="comment">// Use this only for objects created with drwav_open().</span>
 <span class="type">void</span> drwav_close(drwav<span class="operator">*</span> pWav);

 <span class="comment">// Reads raw audio data.</span>
 <span class="comment">//</span>
 <span class="comment">// This is the lowest level function for reading audio data. It simply reads the given number of</span>
 <span class="comment">// bytes of the raw internal sample data.</span>
 <span class="comment">//</span>
 <span class="comment">// Consider using drwav_read_pcm_frames_s16(), drwav_read_pcm_frames_s32() or drwav_read_pcm_frames_f32() for</span>
 <span class="comment">// reading sample data in a consistent format.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of bytes actually read.</span>
 size_t drwav_read_raw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> size_t bytesToRead<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut);

 <span class="comment">// Reads a chunk of audio data in the native internal format.</span>
 <span class="comment">//</span>
 <span class="comment">// This is typically the most efficient way to retrieve audio data, but it does not do any format</span>
 <span class="comment">// conversions which means you'll need to convert the data manually if required.</span>
 <span class="comment">//</span>
 <span class="comment">// If the return value is less than &lt;framesToRead&gt; it means the end of the file has been reached or</span>
 <span class="comment">// you have requested more samples than can possibly fit in the output buffer.</span>
 <span class="comment">//</span>
 <span class="comment">// This function will only work when sample data is of a fixed size and uncompressed. If you are</span>
 <span class="comment">// using a compressed format consider using drwav_read_raw() or drwav_read_pcm_frames_s16/s32/f32/etc().</span>
 drwav_uint64 drwav_read_pcm_frames(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut);

 <span class="comment">// Seeks to the given PCM frame.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns true if successful; false otherwise.</span>
 drwav_bool32 drwav_seek_to_pcm_frame(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 targetFrameIndex);

 <span class="comment">// Writes raw audio data.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of bytes actually written. If this differs from bytesToWrite, it indicates an error.</span>
 size_t drwav_write_raw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> size_t bytesToWrite<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData);

 <span class="comment">// Writes PCM frames.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of PCM frames written.</span>
 drwav_uint64 drwav_write_pcm_frames(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToWrite<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData);

 <span class="comment">//// Conversion Utilities ////</span>
 <span class="preprocessor">#ifndef DR_WAV_NO_CONVERSION_API</span>

 <span class="comment">// Reads a chunk of audio data and converts it to signed 16-bit PCM samples.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of PCM frames actually read.</span>
 <span class="comment">//</span>
 <span class="comment">// If the return value is less than &lt;framesToRead&gt; it means the end of the file has been reached.</span>
 drwav_uint64 drwav_read_pcm_frames_s16(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut);

 <span class="comment">// Low-level function for converting unsigned 8-bit PCM samples to signed 16-bit PCM samples.</span>
 <span class="type">void</span> drwav_u8_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting signed 24-bit PCM samples to signed 16-bit PCM samples.</span>
 <span class="type">void</span> drwav_s24_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting signed 32-bit PCM samples to signed 16-bit PCM samples.</span>
 <span class="type">void</span> drwav_s32_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int32<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting IEEE 32-bit floating point samples to signed 16-bit PCM samples.</span>
 <span class="type">void</span> drwav_f32_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">float</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting IEEE 64-bit floating point samples to signed 16-bit PCM samples.</span>
 <span class="type">void</span> drwav_f64_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting A-law samples to signed 16-bit PCM samples.</span>
 <span class="type">void</span> drwav_alaw_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting u-law samples to signed 16-bit PCM samples.</span>
 <span class="type">void</span> drwav_mulaw_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Reads a chunk of audio data and converts it to IEEE 32-bit floating point samples.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of PCM frames actually read.</span>
 <span class="comment">//</span>
 <span class="comment">// If the return value is less than &lt;framesToRead&gt; it means the end of the file has been reached.</span>
 drwav_uint64 drwav_read_pcm_frames_f32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut);

 <span class="comment">// Low-level function for converting unsigned 8-bit PCM samples to IEEE 32-bit floating point samples.</span>
 <span class="type">void</span> drwav_u8_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting signed 16-bit PCM samples to IEEE 32-bit floating point samples.</span>
 <span class="type">void</span> drwav_s16_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int16<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting signed 24-bit PCM samples to IEEE 32-bit floating point samples.</span>
 <span class="type">void</span> drwav_s24_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting signed 32-bit PCM samples to IEEE 32-bit floating point samples.</span>
 <span class="type">void</span> drwav_s32_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int32<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting IEEE 64-bit floating point samples to IEEE 32-bit floating point samples.</span>
 <span class="type">void</span> drwav_f64_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting A-law samples to IEEE 32-bit floating point samples.</span>
 <span class="type">void</span> drwav_alaw_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting u-law samples to IEEE 32-bit floating point samples.</span>
 <span class="type">void</span> drwav_mulaw_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Reads a chunk of audio data and converts it to signed 32-bit PCM samples.</span>
 <span class="comment">//</span>
 <span class="comment">// Returns the number of PCM frames actually read.</span>
 <span class="comment">//</span>
 <span class="comment">// If the return value is less than &lt;framesToRead&gt; it means the end of the file has been reached.</span>
 drwav_uint64 drwav_read_pcm_frames_s32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut);

 <span class="comment">// Low-level function for converting unsigned 8-bit PCM samples to signed 32-bit PCM samples.</span>
 <span class="type">void</span> drwav_u8_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting signed 16-bit PCM samples to signed 32-bit PCM samples.</span>
 <span class="type">void</span> drwav_s16_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int16<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting signed 24-bit PCM samples to signed 32-bit PCM samples.</span>
 <span class="type">void</span> drwav_s24_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting IEEE 32-bit floating point samples to signed 32-bit PCM samples.</span>
 <span class="type">void</span> drwav_f32_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">float</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting IEEE 64-bit floating point samples to signed 32-bit PCM samples.</span>
 <span class="type">void</span> drwav_f64_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting A-law samples to signed 32-bit PCM samples.</span>
 <span class="type">void</span> drwav_alaw_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="comment">// Low-level function for converting u-law samples to signed 32-bit PCM samples.</span>
 <span class="type">void</span> drwav_mulaw_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount);

 <span class="preprocessor">#endif  //DR_WAV_NO_CONVERSION_API</span>

 <span class="comment">//// High-Level Convenience Helpers ////</span>

 <span class="preprocessor">#ifndef DR_WAV_NO_STDIO</span>

 <span class="comment">// Helper for initializing a wave file using stdio.</span>
 <span class="comment">//</span>
 <span class="comment">// This holds the internal FILE object until drwav_uninit() is called. Keep this in mind if you're caching drwav</span>
 <span class="comment">// objects because the operating system may restrict the number of file handles an application can have open at</span>
 <span class="comment">// any given time.</span>
 drwav_bool32 drwav_init_file(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename);
 drwav_bool32 drwav_init_file_ex(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags);

 <span class="comment">// Helper for initializing a wave file for writing using stdio.</span>
 <span class="comment">//</span>
 <span class="comment">// This holds the internal FILE object until drwav_uninit() is called. Keep this in mind if you're caching drwav</span>
 <span class="comment">// objects because the operating system may restrict the number of file handles an application can have open at</span>
 <span class="comment">// any given time.</span>
 drwav_bool32 drwav_init_file_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat);
 drwav_bool32 drwav_init_file_write_sequential(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount);

 <span class="comment">// Helper for opening a wave file using stdio.</span>
 <span class="comment">//</span>
 <span class="comment">// This holds the internal FILE object until drwav_close() is called. Keep this in mind if you're caching drwav</span>
 <span class="comment">// objects because the operating system may restrict the number of file handles an application can have open at</span>
 <span class="comment">// any given time.</span>
 drwav<span class="operator">*</span> drwav_open_file(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename);
 drwav<span class="operator">*</span> drwav_open_file_ex(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags);

 <span class="comment">// Helper for opening a wave file for writing using stdio.</span>
 <span class="comment">//</span>
 <span class="comment">// This holds the internal FILE object until drwav_close() is called. Keep this in mind if you're caching drwav</span>
 <span class="comment">// objects because the operating system may restrict the number of file handles an application can have open at</span>
 <span class="comment">// any given time.</span>
 drwav<span class="operator">*</span> drwav_open_file_write(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat);
 drwav<span class="operator">*</span> drwav_open_file_write_sequential(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount);

 <span class="preprocessor">#endif  //DR_WAV_NO_STDIO</span>

 <span class="comment">// Helper for initializing a loader from a pre-allocated memory buffer.</span>
 <span class="comment">//</span>
 <span class="comment">// This does not create a copy of the data. It is up to the application to ensure the buffer remains valid for</span>
 <span class="comment">// the lifetime of the drwav object.</span>
 <span class="comment">//</span>
 <span class="comment">// The buffer should contain the contents of the entire wave file, not just the sample data.</span>
 drwav_bool32 drwav_init_memory(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize);
 drwav_bool32 drwav_init_memory_ex(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags);

 <span class="comment">// Helper for initializing a writer which outputs data to a memory buffer.</span>
 <span class="comment">//</span>
 <span class="comment">// dr_wav will manage the memory allocations, however it is up to the caller to free the data with drwav_free().</span>
 <span class="comment">//</span>
 <span class="comment">// The buffer will remain allocated even after drwav_uninit() is called. Indeed, the buffer should not be</span>
 <span class="comment">// considered valid until after drwav_uninit() has been called anyway.</span>
 drwav_bool32 drwav_init_memory_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat);
 drwav_bool32 drwav_init_memory_write_sequential(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount);

 <span class="comment">// Helper for opening a loader from a pre-allocated memory buffer.</span>
 <span class="comment">//</span>
 <span class="comment">// This does not create a copy of the data. It is up to the application to ensure the buffer remains valid for</span>
 <span class="comment">// the lifetime of the drwav object.</span>
 <span class="comment">//</span>
 <span class="comment">// The buffer should contain the contents of the entire wave file, not just the sample data.</span>
 drwav<span class="operator">*</span> drwav_open_memory(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize);
 drwav<span class="operator">*</span> drwav_open_memory_ex(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags);

 <span class="comment">// Helper for opening a writer which outputs data to a memory buffer.</span>
 <span class="comment">//</span>
 <span class="comment">// dr_wav will manage the memory allocations, however it is up to the caller to free the data with drwav_free().</span>
 <span class="comment">//</span>
 <span class="comment">// The buffer will remain allocated even after drwav_close() is called. Indeed, the buffer should not be</span>
 <span class="comment">// considered valid until after drwav_close() has been called anyway.</span>
 drwav<span class="operator">*</span> drwav_open_memory_write(<span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat);
 drwav<span class="operator">*</span> drwav_open_memory_write_sequential(<span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount);

 <span class="preprocessor">#ifndef DR_WAV_NO_CONVERSION_API</span>
 <span class="comment">// Opens and reads a wav file in a single operation.</span>
 drwav_int16<span class="operator">*</span> drwav_open_and_read_pcm_frames_s16(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 <span class="type">float</span><span class="operator">*</span> drwav_open_and_read_pcm_frames_f32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 drwav_int32<span class="operator">*</span> drwav_open_and_read_pcm_frames_s32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 <span class="preprocessor">#ifndef DR_WAV_NO_STDIO</span>
 <span class="comment">// Opens and decodes a wav file in a single operation.</span>
 drwav_int16<span class="operator">*</span> drwav_open_file_and_read_pcm_frames_s16(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 <span class="type">float</span><span class="operator">*</span> drwav_open_file_and_read_pcm_frames_f32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 drwav_int32<span class="operator">*</span> drwav_open_file_and_read_pcm_frames_s32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 <span class="preprocessor">#endif</span>

 <span class="comment">// Opens and decodes a wav file from a block of memory in a single operation.</span>
 drwav_int16<span class="operator">*</span> drwav_open_memory_and_read_pcm_frames_s16(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 <span class="type">float</span><span class="operator">*</span> drwav_open_memory_and_read_pcm_frames_f32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 drwav_int32<span class="operator">*</span> drwav_open_memory_and_read_pcm_frames_s32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCount);
 <span class="preprocessor">#endif</span>

 <span class="comment">// Frees data that was allocated internally by dr_wav.</span>
 <span class="type">void</span> drwav_free(<span class="type">void</span> <span class="operator">*</span>pDataReturnedByOpenAndRead);

 <span class="comment">// DEPRECATED APIS</span>
 <span class="comment">// ===============</span>
 drwav_uint64 drwav_read(drwav <span class="operator">*</span>pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">void</span> <span class="operator">*</span>pBufferOut);
 drwav_uint64 drwav_read_s16(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut);
 drwav_uint64 drwav_read_f32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut);
 drwav_uint64 drwav_read_s32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut);
 drwav_bool32 drwav_seek_to_sample(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 sample);
 drwav_uint64 drwav_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToWrite<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData);
 <span class="preprocessor">#ifndef DR_WAV_NO_CONVERSION_API</span>
 drwav_int16<span class="operator">*</span> drwav_open_and_read_s16(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 <span class="type">float</span><span class="operator">*</span> drwav_open_and_read_f32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 drwav_int32<span class="operator">*</span> drwav_open_and_read_s32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 <span class="preprocessor">#ifndef DR_WAV_NO_STDIO</span>
 drwav_int16<span class="operator">*</span> drwav_open_memory_and_read_s16(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 <span class="type">float</span><span class="operator">*</span> drwav_open_file_and_read_f32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 drwav_int32<span class="operator">*</span> drwav_open_file_and_read_s32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 <span class="preprocessor">#endif</span>
 drwav_int16<span class="operator">*</span> drwav_open_memory_and_read_s16(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 <span class="type">float</span><span class="operator">*</span> drwav_open_memory_and_read_f32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 drwav_int32<span class="operator">*</span> drwav_open_memory_and_read_s32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount);
 <span class="preprocessor">#endif</span>

 <span class="preprocessor">#ifdef __cplusplus</span>
 }
 <span class="preprocessor">#endif</span>
 <span class="preprocessor">#endif  // dr_wav_h</span>

 <span class="comment">/////////////////////////////////////////////////////</span>
 <span class="comment">//</span>
 <span class="comment">// IMPLEMENTATION</span>
 <span class="comment">//</span>
 <span class="comment">/////////////////////////////////////////////////////</span>

 <span class="preprocessor">#ifdef DR_WAV_IMPLEMENTATION</span>
 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
 <span class="preprocessor">#include &lt;string.h&gt; // For memcpy(), memset()</span>
 <span class="preprocessor">#include &lt;limits.h&gt; // For INT_MAX</span>

 <span class="preprocessor">#ifndef DR_WAV_NO_STDIO</span>
 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
 <span class="preprocessor">#endif</span>

 <span class="comment">// Standard library stuff.</span>
 <span class="preprocessor">#ifndef DRWAV_ASSERT</span>
 <span class="preprocessor">#include &lt;assert.h&gt;</span>
 <span class="preprocessor">#define DRWAV_ASSERT(expression)           assert(expression)</span>
 <span class="preprocessor">#endif</span>
 <span class="preprocessor">#ifndef DRWAV_MALLOC</span>
 <span class="preprocessor">#define DRWAV_MALLOC(sz)                   malloc((sz))</span>
 <span class="preprocessor">#endif</span>
 <span class="preprocessor">#ifndef DRWAV_REALLOC</span>
 <span class="preprocessor">#define DRWAV_REALLOC(p, sz)               realloc((p), (sz))</span>
 <span class="preprocessor">#endif</span>
 <span class="preprocessor">#ifndef DRWAV_FREE</span>
 <span class="preprocessor">#define DRWAV_FREE(p)                      free((p))</span>
 <span class="preprocessor">#endif</span>
 <span class="preprocessor">#ifndef DRWAV_COPY_MEMORY</span>
 <span class="preprocessor">#define DRWAV_COPY_MEMORY(dst, src, sz)    memcpy((dst), (src), (sz))</span>
 <span class="preprocessor">#endif</span>
 <span class="preprocessor">#ifndef DRWAV_ZERO_MEMORY</span>
 <span class="preprocessor">#define DRWAV_ZERO_MEMORY(p, sz)           memset((p), 0, (sz))</span>
 <span class="preprocessor">#endif</span>

 <span class="preprocessor">#define drwav_countof(x)                   (sizeof(x) / sizeof(x[0]))</span>
 <span class="preprocessor">#define drwav_align(x, a)                  ((((x) + (a) - 1) / (a)) * (a))</span>
 <span class="preprocessor">#define drwav_min(a, b)                    (((a) &lt; (b)) ? (a) : (b))</span>
 <span class="preprocessor">#define drwav_max(a, b)                    (((a) &gt; (b)) ? (a) : (b))</span>
 <span class="preprocessor">#define drwav_clamp(x, lo, hi)             (drwav_max((lo), drwav_min((hi), (x))))</span>

 <span class="preprocessor">#define drwav_assert                       DRWAV_ASSERT</span>
 <span class="preprocessor">#define drwav_copy_memory                  DRWAV_COPY_MEMORY</span>
 <span class="preprocessor">#define drwav_zero_memory                  DRWAV_ZERO_MEMORY</span>

 <span class="keyword">typedef</span> drwav_int32 drwav_result;
 <span class="preprocessor">#define DRWAV_SUCCESS            0</span>
 <span class="preprocessor">#define DRWAV_ERROR             -1</span>
 <span class="preprocessor">#define DRWAV_INVALID_ARGS      -2</span>
 <span class="preprocessor">#define DRWAV_INVALID_OPERATION -3</span>
 <span class="preprocessor">#define DRWAV_INVALID_FILE      -100</span>
 <span class="preprocessor">#define DRWAV_EOF               -101</span>

 <span class="preprocessor">#define DRWAV_MAX_SIMD_VECTOR_SIZE         64  // 64 for AVX-512 in the future.</span>

 <span class="preprocessor">#ifdef _MSC_VER</span>
 <span class="preprocessor">#define DRWAV_INLINE __forceinline</span>
 <span class="preprocessor">#else</span>
 <span class="preprocessor">#ifdef __GNUC__</span>
 <span class="preprocessor">#define DRWAV_INLINE inline __attribute__((always_inline))</span>
 <span class="preprocessor">#else</span>
 <span class="preprocessor">#define DRWAV_INLINE inline</span>
 <span class="preprocessor">#endif</span>
 <span class="preprocessor">#endif</span>

 <span class="preprocessor">#if defined(SIZE_MAX)</span>
     <span class="preprocessor">#define DRWAV_SIZE_MAX  SIZE_MAX</span>
 <span class="preprocessor">#else</span>
     <span class="preprocessor">#if defined(_WIN64) || defined(_LP64) || defined(__LP64__)</span>
         <span class="preprocessor">#define DRWAV_SIZE_MAX  ((drwav_uint64)0xFFFFFFFFFFFFFFFF)</span>
     <span class="preprocessor">#else</span>
         <span class="preprocessor">#define DRWAV_SIZE_MAX  0xFFFFFFFF</span>
     <span class="preprocessor">#endif</span>
 <span class="preprocessor">#endif</span>

 <span class="keyword">static</span> <span class="keyword">const</span> drwav_uint8 drwavGUID_W64_RIFF<span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0x72</span><span class="operator">,</span><span class="number">0x69</span><span class="operator">,</span><span class="number">0x66</span><span class="operator">,</span><span class="number">0x66</span><span class="operator">,</span> <span class="number">0x2E</span><span class="operator">,</span><span class="number">0x91</span><span class="operator">,</span> <span class="number">0xCF</span><span class="operator">,</span><span class="number">0x11</span><span class="operator">,</span> <span class="number">0xA5</span><span class="operator">,</span><span class="number">0xD6</span><span class="operator">,</span> <span class="number">0x28</span><span class="operator">,</span><span class="number">0xDB</span><span class="operator">,</span><span class="number">0x04</span><span class="operator">,</span><span class="number">0xC1</span><span class="operator">,</span><span class="number">0x00</span><span class="operator">,</span><span class="number">0x00</span>};    <span class="comment">// 66666972-912E-11CF-A5D6-28DB04C10000</span>
 <span class="keyword">static</span> <span class="keyword">const</span> drwav_uint8 drwavGUID_W64_WAVE<span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0x77</span><span class="operator">,</span><span class="number">0x61</span><span class="operator">,</span><span class="number">0x76</span><span class="operator">,</span><span class="number">0x65</span><span class="operator">,</span> <span class="number">0xF3</span><span class="operator">,</span><span class="number">0xAC</span><span class="operator">,</span> <span class="number">0xD3</span><span class="operator">,</span><span class="number">0x11</span><span class="operator">,</span> <span class="number">0x8C</span><span class="operator">,</span><span class="number">0xD1</span><span class="operator">,</span> <span class="number">0x00</span><span class="operator">,</span><span class="number">0xC0</span><span class="operator">,</span><span class="number">0x4F</span><span class="operator">,</span><span class="number">0x8E</span><span class="operator">,</span><span class="number">0xDB</span><span class="operator">,</span><span class="number">0x8A</span>};    <span class="comment">// 65766177-ACF3-11D3-8CD1-00C04F8EDB8A</span>
 <span class="keyword">static</span> <span class="keyword">const</span> drwav_uint8 drwavGUID_W64_JUNK<span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0x6A</span><span class="operator">,</span><span class="number">0x75</span><span class="operator">,</span><span class="number">0x6E</span><span class="operator">,</span><span class="number">0x6B</span><span class="operator">,</span> <span class="number">0xF3</span><span class="operator">,</span><span class="number">0xAC</span><span class="operator">,</span> <span class="number">0xD3</span><span class="operator">,</span><span class="number">0x11</span><span class="operator">,</span> <span class="number">0x8C</span><span class="operator">,</span><span class="number">0xD1</span><span class="operator">,</span> <span class="number">0x00</span><span class="operator">,</span><span class="number">0xC0</span><span class="operator">,</span><span class="number">0x4F</span><span class="operator">,</span><span class="number">0x8E</span><span class="operator">,</span><span class="number">0xDB</span><span class="operator">,</span><span class="number">0x8A</span>};    <span class="comment">// 6B6E756A-ACF3-11D3-8CD1-00C04F8EDB8A</span>
 <span class="keyword">static</span> <span class="keyword">const</span> drwav_uint8 drwavGUID_W64_FMT <span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0x66</span><span class="operator">,</span><span class="number">0x6D</span><span class="operator">,</span><span class="number">0x74</span><span class="operator">,</span><span class="number">0x20</span><span class="operator">,</span> <span class="number">0xF3</span><span class="operator">,</span><span class="number">0xAC</span><span class="operator">,</span> <span class="number">0xD3</span><span class="operator">,</span><span class="number">0x11</span><span class="operator">,</span> <span class="number">0x8C</span><span class="operator">,</span><span class="number">0xD1</span><span class="operator">,</span> <span class="number">0x00</span><span class="operator">,</span><span class="number">0xC0</span><span class="operator">,</span><span class="number">0x4F</span><span class="operator">,</span><span class="number">0x8E</span><span class="operator">,</span><span class="number">0xDB</span><span class="operator">,</span><span class="number">0x8A</span>};    <span class="comment">// 20746D66-ACF3-11D3-8CD1-00C04F8EDB8A</span>
 <span class="keyword">static</span> <span class="keyword">const</span> drwav_uint8 drwavGUID_W64_FACT<span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0x66</span><span class="operator">,</span><span class="number">0x61</span><span class="operator">,</span><span class="number">0x63</span><span class="operator">,</span><span class="number">0x74</span><span class="operator">,</span> <span class="number">0xF3</span><span class="operator">,</span><span class="number">0xAC</span><span class="operator">,</span> <span class="number">0xD3</span><span class="operator">,</span><span class="number">0x11</span><span class="operator">,</span> <span class="number">0x8C</span><span class="operator">,</span><span class="number">0xD1</span><span class="operator">,</span> <span class="number">0x00</span><span class="operator">,</span><span class="number">0xC0</span><span class="operator">,</span><span class="number">0x4F</span><span class="operator">,</span><span class="number">0x8E</span><span class="operator">,</span><span class="number">0xDB</span><span class="operator">,</span><span class="number">0x8A</span>};    <span class="comment">// 74636166-ACF3-11D3-8CD1-00C04F8EDB8A</span>
 <span class="keyword">static</span> <span class="keyword">const</span> drwav_uint8 drwavGUID_W64_DATA<span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0x64</span><span class="operator">,</span><span class="number">0x61</span><span class="operator">,</span><span class="number">0x74</span><span class="operator">,</span><span class="number">0x61</span><span class="operator">,</span> <span class="number">0xF3</span><span class="operator">,</span><span class="number">0xAC</span><span class="operator">,</span> <span class="number">0xD3</span><span class="operator">,</span><span class="number">0x11</span><span class="operator">,</span> <span class="number">0x8C</span><span class="operator">,</span><span class="number">0xD1</span><span class="operator">,</span> <span class="number">0x00</span><span class="operator">,</span><span class="number">0xC0</span><span class="operator">,</span><span class="number">0x4F</span><span class="operator">,</span><span class="number">0x8E</span><span class="operator">,</span><span class="number">0xDB</span><span class="operator">,</span><span class="number">0x8A</span>};    <span class="comment">// 61746164-ACF3-11D3-8CD1-00C04F8EDB8A</span>
 <span class="keyword">static</span> <span class="keyword">const</span> drwav_uint8 drwavGUID_W64_SMPL<span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {<span class="number">0x73</span><span class="operator">,</span><span class="number">0x6D</span><span class="operator">,</span><span class="number">0x70</span><span class="operator">,</span><span class="number">0x6C</span><span class="operator">,</span> <span class="number">0xF3</span><span class="operator">,</span><span class="number">0xAC</span><span class="operator">,</span> <span class="number">0xD3</span><span class="operator">,</span><span class="number">0x11</span><span class="operator">,</span> <span class="number">0x8C</span><span class="operator">,</span><span class="number">0xD1</span><span class="operator">,</span> <span class="number">0x00</span><span class="operator">,</span><span class="number">0xC0</span><span class="operator">,</span><span class="number">0x4F</span><span class="operator">,</span><span class="number">0x8E</span><span class="operator">,</span><span class="number">0xDB</span><span class="operator">,</span><span class="number">0x8A</span>};    <span class="comment">// 6C706D73-ACF3-11D3-8CD1-00C04F8EDB8A</span>

 <span class="keyword">static</span> DRWAV_INLINE drwav_bool32 drwav__guid_equal(<span class="keyword">const</span> drwav_uint8 a<span class="operator">[</span><span class="number">16</span><span class="operator">]</span><span class="operator">,</span> <span class="keyword">const</span> drwav_uint8 b<span class="operator">[</span><span class="number">16</span><span class="operator">]</span>)
 {
     <span class="keyword">const</span> drwav_uint32<span class="operator">*</span> a32 <span class="operator">=</span> (<span class="keyword">const</span> drwav_uint32<span class="operator">*</span>)a;
     <span class="keyword">const</span> drwav_uint32<span class="operator">*</span> b32 <span class="operator">=</span> (<span class="keyword">const</span> drwav_uint32<span class="operator">*</span>)b;

     <span class="keyword">return</span>
         a32<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b32<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>
         a32<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b32<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>
         a32<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b32<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>
         a32<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b32<span class="operator">[</span><span class="number">3</span><span class="operator">]</span>;
 }

 <span class="keyword">static</span> DRWAV_INLINE drwav_bool32 drwav__fourcc_equal(<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> a<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> b)
 {
     <span class="keyword">return</span>
         a<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>
         a<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>
         a<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">&amp;</span><span class="operator">&amp;</span>
         a<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> b<span class="operator">[</span><span class="number">3</span><span class="operator">]</span>;
 }

 <span class="keyword">static</span> DRWAV_INLINE <span class="type">int</span> drwav__is_little_endian()
 {
     <span class="type">int</span> n <span class="operator">=</span> <span class="number">1</span>;
     <span class="keyword">return</span> (<span class="operator">*</span>(<span class="type">char</span><span class="operator">*</span>)<span class="operator">&amp;</span>n) <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>;
 }

 <span class="keyword">static</span> DRWAV_INLINE <span class="type">unsigned</span> <span class="type">short</span> drwav__bytes_to_u16(<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> data)
 {
     <span class="keyword">return</span> (data<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0</span>) <span class="operator">|</span> (data<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>);
 }

 <span class="keyword">static</span> DRWAV_INLINE <span class="type">short</span> drwav__bytes_to_s16(<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> data)
 {
     <span class="keyword">return</span> (<span class="type">short</span>)drwav__bytes_to_u16(data);
 }

 <span class="keyword">static</span> DRWAV_INLINE <span class="type">unsigned</span> <span class="type">int</span> drwav__bytes_to_u32(<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> data)
 {
     <span class="keyword">return</span> (data<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0</span>) <span class="operator">|</span> (data<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>) <span class="operator">|</span> (data<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>) <span class="operator">|</span> (data<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">24</span>);
 }

 <span class="keyword">static</span> DRWAV_INLINE drwav_uint64 drwav__bytes_to_u64(<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> data)
 {
     <span class="keyword">return</span>
         ((drwav_uint64)data<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span>  <span class="number">0</span>) <span class="operator">|</span> ((drwav_uint64)data<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span>  <span class="number">8</span>) <span class="operator">|</span> ((drwav_uint64)data<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>) <span class="operator">|</span> ((drwav_uint64)data<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">24</span>) <span class="operator">|</span>
         ((drwav_uint64)data<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">32</span>) <span class="operator">|</span> ((drwav_uint64)data<span class="operator">[</span><span class="number">5</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">40</span>) <span class="operator">|</span> ((drwav_uint64)data<span class="operator">[</span><span class="number">6</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">48</span>) <span class="operator">|</span> ((drwav_uint64)data<span class="operator">[</span><span class="number">7</span><span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">56</span>);
 }

 <span class="keyword">static</span> DRWAV_INLINE <span class="type">void</span> drwav__bytes_to_guid(<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> data<span class="operator">,</span> drwav_uint8<span class="operator">*</span> guid)
 {
     <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">16</span>; <span class="operator">+</span><span class="operator">+</span>i) {
         guid<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> data<span class="operator">[</span>i<span class="operator">]</span>;
     }
 }

 <span class="keyword">static</span> DRWAV_INLINE drwav_bool32 drwav__is_compressed_format_tag(drwav_uint16 formatTag)
 {
     <span class="keyword">return</span>
         formatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM <span class="operator">|</span><span class="operator">|</span>
         formatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM;
 }

 drwav_uint64 drwav_read_s16__msadpcm(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut);
 drwav_uint64 drwav_read_s16__ima(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut);
 drwav_bool32 drwav_init_write__internal(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);
 drwav<span class="operator">*</span> drwav_open_write__internal(<span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData);

 <span class="keyword">static</span> drwav_result drwav__read_chunk_header(drwav_read_proc onRead<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> drwav_container container<span class="operator">,</span> drwav_uint64<span class="operator">*</span> pRunningBytesReadOut<span class="operator">,</span> drwav_chunk_header<span class="operator">*</span> pHeaderOut)
 {
     <span class="keyword">if</span> (container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
         <span class="keyword">if</span> (onRead(pUserData<span class="operator">,</span> pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>id<span class="operator">.</span>fourcc<span class="operator">,</span> <span class="number">4</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">4</span>) {
             <span class="keyword">return</span> DRWAV_EOF;
         }

         <span class="type">unsigned</span> <span class="type">char</span> sizeInBytes<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;
         <span class="keyword">if</span> (onRead(pUserData<span class="operator">,</span> sizeInBytes<span class="operator">,</span> <span class="number">4</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">4</span>) {
             <span class="keyword">return</span> DRWAV_INVALID_FILE;
         }

         pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>sizeInBytes <span class="operator">=</span> drwav__bytes_to_u32(sizeInBytes);
         pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>paddingSize <span class="operator">=</span> (<span class="type">unsigned</span> <span class="type">int</span>)(pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>sizeInBytes <span class="operator">%</span> <span class="number">2</span>);
         <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> <span class="number">8</span>;
     } <span class="keyword">else</span> {
         <span class="keyword">if</span> (onRead(pUserData<span class="operator">,</span> pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>id<span class="operator">.</span>guid<span class="operator">,</span> <span class="number">16</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">16</span>) {
             <span class="keyword">return</span> DRWAV_EOF;
         }

         <span class="type">unsigned</span> <span class="type">char</span> sizeInBytes<span class="operator">[</span><span class="number">8</span><span class="operator">]</span>;
         <span class="keyword">if</span> (onRead(pUserData<span class="operator">,</span> sizeInBytes<span class="operator">,</span> <span class="number">8</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">8</span>) {
             <span class="keyword">return</span> DRWAV_INVALID_FILE;
         }

         pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>sizeInBytes <span class="operator">=</span> drwav__bytes_to_u64(sizeInBytes) <span class="operator">-</span> <span class="number">24</span>;    <span class="comment">// &lt;-- Subtract 24 because w64 includes the size of the header.</span>
         pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>paddingSize <span class="operator">=</span> (<span class="type">unsigned</span> <span class="type">int</span>)(pHeaderOut<span class="operator">-</span><span class="operator">&gt;</span>sizeInBytes <span class="operator">%</span> <span class="number">8</span>);
         <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> <span class="number">24</span>;
     }

     <span class="keyword">return</span> DRWAV_SUCCESS;
 }

 <span class="keyword">static</span> drwav_bool32 drwav__seek_forward(drwav_seek_proc onSeek<span class="operator">,</span> drwav_uint64 offset<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     drwav_uint64 bytesRemainingToSeek <span class="operator">=</span> offset;
     <span class="keyword">while</span> (bytesRemainingToSeek <span class="operator">&gt;</span> <span class="number">0</span>) {
         <span class="keyword">if</span> (bytesRemainingToSeek <span class="operator">&gt;</span> <span class="number">0x7FFFFFFF</span>) {
             <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> <span class="number">0x7FFFFFFF</span><span class="operator">,</span> drwav_seek_origin_current)) {
                 <span class="keyword">return</span> DRWAV_FALSE;
             }
             bytesRemainingToSeek <span class="operator">-</span><span class="operator">=</span> <span class="number">0x7FFFFFFF</span>;
         } <span class="keyword">else</span> {
             <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> (<span class="type">int</span>)bytesRemainingToSeek<span class="operator">,</span> drwav_seek_origin_current)) {
                 <span class="keyword">return</span> DRWAV_FALSE;
             }
             bytesRemainingToSeek <span class="operator">=</span> <span class="number">0</span>;
         }
     }

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 <span class="keyword">static</span> drwav_bool32 drwav__seek_from_start(drwav_seek_proc onSeek<span class="operator">,</span> drwav_uint64 offset<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">if</span> (offset <span class="operator">&lt;</span><span class="operator">=</span> <span class="number">0x7FFFFFFF</span>) {
         <span class="keyword">return</span> onSeek(pUserData<span class="operator">,</span> (<span class="type">int</span>)offset<span class="operator">,</span> drwav_seek_origin_start);
     }

     <span class="comment">// Larger than 32-bit seek.</span>
     <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> <span class="number">0x7FFFFFFF</span><span class="operator">,</span> drwav_seek_origin_start)) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }
     offset <span class="operator">-</span><span class="operator">=</span> <span class="number">0x7FFFFFFF</span>;

     <span class="keyword">for</span> (;;) {
         <span class="keyword">if</span> (offset <span class="operator">&lt;</span><span class="operator">=</span> <span class="number">0x7FFFFFFF</span>) {
             <span class="keyword">return</span> onSeek(pUserData<span class="operator">,</span> (<span class="type">int</span>)offset<span class="operator">,</span> drwav_seek_origin_current);
         }

         <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> <span class="number">0x7FFFFFFF</span><span class="operator">,</span> drwav_seek_origin_current)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
         offset <span class="operator">-</span><span class="operator">=</span> <span class="number">0x7FFFFFFF</span>;
     }

     <span class="comment">// Should never get here.</span>
     <span class="comment">//return DRWAV_TRUE;</span>
 }

 <span class="keyword">static</span> drwav_bool32 drwav__read_fmt(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> drwav_container container<span class="operator">,</span> drwav_uint64<span class="operator">*</span> pRunningBytesReadOut<span class="operator">,</span> drwav_fmt<span class="operator">*</span> fmtOut)
 {
     drwav_chunk_header header;
     <span class="keyword">if</span> (drwav__read_chunk_header(onRead<span class="operator">,</span> pUserData<span class="operator">,</span> container<span class="operator">,</span> pRunningBytesReadOut<span class="operator">,</span> <span class="operator">&amp;</span>header) <span class="operator">!</span><span class="operator">=</span> DRWAV_SUCCESS) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="comment">// Skip non-fmt chunks.</span>
     <span class="keyword">while</span> ((container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>drwav__fourcc_equal(header<span class="operator">.</span>id<span class="operator">.</span>fourcc<span class="operator">,</span> <span class="string">&quot;fmt &quot;</span>)) <span class="operator">|</span><span class="operator">|</span> (container <span class="operator">=</span><span class="operator">=</span> drwav_container_w64 <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>drwav__guid_equal(header<span class="operator">.</span>id<span class="operator">.</span>guid<span class="operator">,</span> drwavGUID_W64_FMT))) {
         <span class="keyword">if</span> (<span class="operator">!</span>drwav__seek_forward(onSeek<span class="operator">,</span> header<span class="operator">.</span>sizeInBytes <span class="operator">+</span> header<span class="operator">.</span>paddingSize<span class="operator">,</span> pUserData)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
         <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> header<span class="operator">.</span>sizeInBytes <span class="operator">+</span> header<span class="operator">.</span>paddingSize;

         <span class="comment">// Try the next header.</span>
         <span class="keyword">if</span> (drwav__read_chunk_header(onRead<span class="operator">,</span> pUserData<span class="operator">,</span> container<span class="operator">,</span> pRunningBytesReadOut<span class="operator">,</span> <span class="operator">&amp;</span>header) <span class="operator">!</span><span class="operator">=</span> DRWAV_SUCCESS) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
     }

     <span class="comment">// Validation.</span>
     <span class="keyword">if</span> (container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
         <span class="keyword">if</span> (<span class="operator">!</span>drwav__fourcc_equal(header<span class="operator">.</span>id<span class="operator">.</span>fourcc<span class="operator">,</span> <span class="string">&quot;fmt &quot;</span>)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
     } <span class="keyword">else</span> {
         <span class="keyword">if</span> (<span class="operator">!</span>drwav__guid_equal(header<span class="operator">.</span>id<span class="operator">.</span>guid<span class="operator">,</span> drwavGUID_W64_FMT)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
     }

     <span class="type">unsigned</span> <span class="type">char</span> fmt<span class="operator">[</span><span class="number">16</span><span class="operator">]</span>;
     <span class="keyword">if</span> (onRead(pUserData<span class="operator">,</span> fmt<span class="operator">,</span> <span class="keyword">sizeof</span>(fmt)) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(fmt)) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }
     <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> <span class="keyword">sizeof</span>(fmt);

     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>formatTag      <span class="operator">=</span> drwav__bytes_to_u16(fmt <span class="operator">+</span> <span class="number">0</span>);
     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>channels       <span class="operator">=</span> drwav__bytes_to_u16(fmt <span class="operator">+</span> <span class="number">2</span>);
     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>sampleRate     <span class="operator">=</span> drwav__bytes_to_u32(fmt <span class="operator">+</span> <span class="number">4</span>);
     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>avgBytesPerSec <span class="operator">=</span> drwav__bytes_to_u32(fmt <span class="operator">+</span> <span class="number">8</span>);
     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>blockAlign     <span class="operator">=</span> drwav__bytes_to_u16(fmt <span class="operator">+</span> <span class="number">12</span>);
     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample  <span class="operator">=</span> drwav__bytes_to_u16(fmt <span class="operator">+</span> <span class="number">14</span>);

     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize       <span class="operator">=</span> <span class="number">0</span>;
     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>validBitsPerSample <span class="operator">=</span> <span class="number">0</span>;
     fmtOut<span class="operator">-</span><span class="operator">&gt;</span>channelMask        <span class="operator">=</span> <span class="number">0</span>;
     memset(fmtOut<span class="operator">-</span><span class="operator">&gt;</span>subFormat<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="keyword">sizeof</span>(fmtOut<span class="operator">-</span><span class="operator">&gt;</span>subFormat));

     <span class="keyword">if</span> (header<span class="operator">.</span>sizeInBytes <span class="operator">&gt;</span> <span class="number">16</span>) {
         <span class="type">unsigned</span> <span class="type">char</span> fmt_cbSize<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
         <span class="keyword">if</span> (onRead(pUserData<span class="operator">,</span> fmt_cbSize<span class="operator">,</span> <span class="keyword">sizeof</span>(fmt_cbSize)) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(fmt_cbSize)) {
             <span class="keyword">return</span> DRWAV_FALSE;    <span class="comment">// Expecting more data.</span>
         }
         <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> <span class="keyword">sizeof</span>(fmt_cbSize);

         <span class="type">int</span> bytesReadSoFar <span class="operator">=</span> <span class="number">18</span>;

         fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize <span class="operator">=</span> drwav__bytes_to_u16(fmt_cbSize);
         <span class="keyword">if</span> (fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize <span class="operator">&gt;</span> <span class="number">0</span>) {
             <span class="comment">// Simple validation.</span>
             <span class="keyword">if</span> (fmtOut<span class="operator">-</span><span class="operator">&gt;</span>formatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_EXTENSIBLE) {
                 <span class="keyword">if</span> (fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize <span class="operator">!</span><span class="operator">=</span> <span class="number">22</span>) {
                     <span class="keyword">return</span> DRWAV_FALSE;
                 }
             }

             <span class="keyword">if</span> (fmtOut<span class="operator">-</span><span class="operator">&gt;</span>formatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_EXTENSIBLE) {
                 <span class="type">unsigned</span> <span class="type">char</span> fmtext<span class="operator">[</span><span class="number">22</span><span class="operator">]</span>;
                 <span class="keyword">if</span> (onRead(pUserData<span class="operator">,</span> fmtext<span class="operator">,</span> fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize) <span class="operator">!</span><span class="operator">=</span> fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize) {
                     <span class="keyword">return</span> DRWAV_FALSE;    <span class="comment">// Expecting more data.</span>
                 }

                 fmtOut<span class="operator">-</span><span class="operator">&gt;</span>validBitsPerSample <span class="operator">=</span> drwav__bytes_to_u16(fmtext <span class="operator">+</span> <span class="number">0</span>);
                 fmtOut<span class="operator">-</span><span class="operator">&gt;</span>channelMask        <span class="operator">=</span> drwav__bytes_to_u32(fmtext <span class="operator">+</span> <span class="number">2</span>);
                 drwav__bytes_to_guid(fmtext <span class="operator">+</span> <span class="number">6</span><span class="operator">,</span> fmtOut<span class="operator">-</span><span class="operator">&gt;</span>subFormat);
             } <span class="keyword">else</span> {
                 <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize<span class="operator">,</span> drwav_seek_origin_current)) {
                     <span class="keyword">return</span> DRWAV_FALSE;
                 }
             }
             <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize;

             bytesReadSoFar <span class="operator">+</span><span class="operator">=</span> fmtOut<span class="operator">-</span><span class="operator">&gt;</span>extendedSize;
         }

         <span class="comment">// Seek past any leftover bytes. For w64 the leftover will be defined based on the chunk size.</span>
         <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> (<span class="type">int</span>)(header<span class="operator">.</span>sizeInBytes <span class="operator">-</span> bytesReadSoFar)<span class="operator">,</span> drwav_seek_origin_current)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
         <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> (header<span class="operator">.</span>sizeInBytes <span class="operator">-</span> bytesReadSoFar);
     }

     <span class="keyword">if</span> (header<span class="operator">.</span>paddingSize <span class="operator">&gt;</span> <span class="number">0</span>) {
         <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> header<span class="operator">.</span>paddingSize<span class="operator">,</span> drwav_seek_origin_current)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
         <span class="operator">*</span>pRunningBytesReadOut <span class="operator">+</span><span class="operator">=</span> header<span class="operator">.</span>paddingSize;
     }

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 <span class="preprocessor">#ifndef DR_WAV_NO_STDIO</span>
 FILE<span class="operator">*</span> drwav_fopen(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filePath<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> openMode)
 {
     FILE<span class="operator">*</span> pFile;
 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400</span>
     <span class="keyword">if</span> (fopen_s(<span class="operator">&amp;</span>pFile<span class="operator">,</span> filePath<span class="operator">,</span> openMode) <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }
 <span class="preprocessor">#else</span>
     pFile <span class="operator">=</span> fopen(filePath<span class="operator">,</span> openMode);
     <span class="keyword">if</span> (pFile <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }
 <span class="preprocessor">#endif</span>

     <span class="keyword">return</span> pFile;
 }

 <span class="keyword">static</span> size_t drwav__on_read_stdio(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut<span class="operator">,</span> size_t bytesToRead)
 {
     <span class="keyword">return</span> fread(pBufferOut<span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> bytesToRead<span class="operator">,</span> (FILE<span class="operator">*</span>)pUserData);
 }

 <span class="keyword">static</span> size_t drwav__on_write_stdio(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData<span class="operator">,</span> size_t bytesToWrite)
 {
     <span class="keyword">return</span> fwrite(pData<span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> bytesToWrite<span class="operator">,</span> (FILE<span class="operator">*</span>)pUserData);
 }

 <span class="keyword">static</span> drwav_bool32 drwav__on_seek_stdio(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">int</span> offset<span class="operator">,</span> drwav_seek_origin origin)
 {
     <span class="keyword">return</span> fseek((FILE<span class="operator">*</span>)pUserData<span class="operator">,</span> offset<span class="operator">,</span> (origin <span class="operator">=</span><span class="operator">=</span> drwav_seek_origin_current) <span class="operator">?</span> SEEK_CUR : SEEK_SET) <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>;
 }

 drwav_bool32 drwav_init_file(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename)
 {
     <span class="keyword">return</span> drwav_init_file_ex(pWav<span class="operator">,</span> filename<span class="operator">,</span> NULL<span class="operator">,</span> NULL<span class="operator">,</span> <span class="number">0</span>);
 }

 drwav_bool32 drwav_init_file_ex(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags)
 {
     FILE<span class="operator">*</span> pFile <span class="operator">=</span> drwav_fopen(filename<span class="operator">,</span> <span class="string">&quot;rb&quot;</span>);
     <span class="keyword">if</span> (pFile <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="keyword">return</span> drwav_init_ex(pWav<span class="operator">,</span> drwav__on_read_stdio<span class="operator">,</span> drwav__on_seek_stdio<span class="operator">,</span> onChunk<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)pFile<span class="operator">,</span> pChunkUserData<span class="operator">,</span> flags);
 }

 drwav_bool32 drwav_init_file_write__internal(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential)
 {
     FILE<span class="operator">*</span> pFile <span class="operator">=</span> drwav_fopen(filename<span class="operator">,</span> <span class="string">&quot;wb&quot;</span>);
     <span class="keyword">if</span> (pFile <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="keyword">return</span> drwav_init_write__internal(pWav<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> isSequential<span class="operator">,</span> drwav__on_write_stdio<span class="operator">,</span> drwav__on_seek_stdio<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)pFile);
 }

 drwav_bool32 drwav_init_file_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat)
 {
     <span class="keyword">return</span> drwav_init_file_write__internal(pWav<span class="operator">,</span> filename<span class="operator">,</span> pFormat<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> DRWAV_FALSE);
 }

 drwav_bool32 drwav_init_file_write_sequential(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount)
 {
     <span class="keyword">return</span> drwav_init_file_write__internal(pWav<span class="operator">,</span> filename<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> DRWAV_TRUE);
 }

 drwav<span class="operator">*</span> drwav_open_file(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename)
 {
     <span class="keyword">return</span> drwav_open_file_ex(filename<span class="operator">,</span> NULL<span class="operator">,</span> NULL<span class="operator">,</span> <span class="number">0</span>);
 }

 drwav<span class="operator">*</span> drwav_open_file_ex(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags)
 {
     FILE<span class="operator">*</span> pFile <span class="operator">=</span> drwav_fopen(filename<span class="operator">,</span> <span class="string">&quot;rb&quot;</span>);
     <span class="keyword">if</span> (pFile <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     drwav<span class="operator">*</span> pWav <span class="operator">=</span> drwav_open_ex(drwav__on_read_stdio<span class="operator">,</span> drwav__on_seek_stdio<span class="operator">,</span> onChunk<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)pFile<span class="operator">,</span> pChunkUserData<span class="operator">,</span> flags);
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         fclose(pFile);
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> pWav;
 }

 drwav<span class="operator">*</span> drwav_open_file_write__internal(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential)
 {
     FILE<span class="operator">*</span> pFile <span class="operator">=</span> drwav_fopen(filename<span class="operator">,</span> <span class="string">&quot;wb&quot;</span>);
     <span class="keyword">if</span> (pFile <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     drwav<span class="operator">*</span> pWav <span class="operator">=</span> drwav_open_write__internal(pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> isSequential<span class="operator">,</span> drwav__on_write_stdio<span class="operator">,</span> drwav__on_seek_stdio<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)pFile);
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         fclose(pFile);
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> pWav;
 }

 drwav<span class="operator">*</span> drwav_open_file_write(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat)
 {
     <span class="keyword">return</span> drwav_open_file_write__internal(filename<span class="operator">,</span> pFormat<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> DRWAV_FALSE);
 }

 drwav<span class="operator">*</span> drwav_open_file_write_sequential(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount)
 {
     <span class="keyword">return</span> drwav_open_file_write__internal(filename<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> DRWAV_TRUE);
 }
 <span class="preprocessor">#endif  //DR_WAV_NO_STDIO</span>

 <span class="keyword">static</span> size_t drwav__on_read_memory(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut<span class="operator">,</span> size_t bytesToRead)
 {
     drwav__memory_stream<span class="operator">*</span> memory <span class="operator">=</span> (drwav__memory_stream<span class="operator">*</span>)pUserData;
     drwav_assert(memory <span class="operator">!</span><span class="operator">=</span> NULL);
     drwav_assert(memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize <span class="operator">&gt;</span><span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos);

     size_t bytesRemaining <span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize <span class="operator">-</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos;
     <span class="keyword">if</span> (bytesToRead <span class="operator">&gt;</span> bytesRemaining) {
         bytesToRead <span class="operator">=</span> bytesRemaining;
     }

     <span class="keyword">if</span> (bytesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         DRWAV_COPY_MEMORY(pBufferOut<span class="operator">,</span> memory<span class="operator">-</span><span class="operator">&gt;</span>data <span class="operator">+</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos<span class="operator">,</span> bytesToRead);
         memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos <span class="operator">+</span><span class="operator">=</span> bytesToRead;
     }

     <span class="keyword">return</span> bytesToRead;
 }

 <span class="keyword">static</span> drwav_bool32 drwav__on_seek_memory(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">int</span> offset<span class="operator">,</span> drwav_seek_origin origin)
 {
     drwav__memory_stream<span class="operator">*</span> memory <span class="operator">=</span> (drwav__memory_stream<span class="operator">*</span>)pUserData;
     drwav_assert(memory <span class="operator">!</span><span class="operator">=</span> NULL);

     <span class="keyword">if</span> (origin <span class="operator">=</span><span class="operator">=</span> drwav_seek_origin_current) {
         <span class="keyword">if</span> (offset <span class="operator">&gt;</span> <span class="number">0</span>) {
             <span class="keyword">if</span> (memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos <span class="operator">+</span> offset <span class="operator">&gt;</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize) {
                 <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// Trying to seek too far forward.</span>
             }
         } <span class="keyword">else</span> {
             <span class="keyword">if</span> (memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos <span class="operator">&lt;</span> (size_t)<span class="operator">-</span>offset) {
                 <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// Trying to seek too far backwards.</span>
             }
         }

         <span class="comment">// This will never underflow thanks to the clamps above.</span>
         memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos <span class="operator">+</span><span class="operator">=</span> offset;
     } <span class="keyword">else</span> {
         <span class="keyword">if</span> ((drwav_uint32)offset <span class="operator">&lt;</span><span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize) {
             memory<span class="operator">-</span><span class="operator">&gt;</span>currentReadPos <span class="operator">=</span> offset;
         } <span class="keyword">else</span> {
             <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// Trying to seek too far forward.</span>
         }
     }

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 <span class="keyword">static</span> size_t drwav__on_write_memory(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pDataIn<span class="operator">,</span> size_t bytesToWrite)
 {
     drwav__memory_stream_write<span class="operator">*</span> memory <span class="operator">=</span> (drwav__memory_stream_write<span class="operator">*</span>)pUserData;
     drwav_assert(memory <span class="operator">!</span><span class="operator">=</span> NULL);
     drwav_assert(memory<span class="operator">-</span><span class="operator">&gt;</span>dataCapacity <span class="operator">&gt;</span><span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos);

     size_t bytesRemaining <span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataCapacity <span class="operator">-</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos;
     <span class="keyword">if</span> (bytesRemaining <span class="operator">&lt;</span> bytesToWrite) {
         <span class="comment">// Need to reallocate.</span>
         size_t newDataCapacity <span class="operator">=</span> (memory<span class="operator">-</span><span class="operator">&gt;</span>dataCapacity <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) <span class="operator">?</span> <span class="number">256</span> : memory<span class="operator">-</span><span class="operator">&gt;</span>dataCapacity <span class="operator">*</span> <span class="number">2</span>;

         <span class="comment">// If doubling wasn't enough, just make it the minimum required size to write the data.</span>
         <span class="keyword">if</span> ((newDataCapacity <span class="operator">-</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos) <span class="operator">&lt;</span> bytesToWrite) {
             newDataCapacity <span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos <span class="operator">+</span> bytesToWrite;
         }

         <span class="type">void</span><span class="operator">*</span> pNewData <span class="operator">=</span> DRWAV_REALLOC(<span class="operator">*</span>memory<span class="operator">-</span><span class="operator">&gt;</span>ppData<span class="operator">,</span> newDataCapacity);
         <span class="keyword">if</span> (pNewData <span class="operator">=</span><span class="operator">=</span> NULL) {
             <span class="keyword">return</span> <span class="number">0</span>;
         }

         <span class="operator">*</span>memory<span class="operator">-</span><span class="operator">&gt;</span>ppData <span class="operator">=</span> pNewData;
         memory<span class="operator">-</span><span class="operator">&gt;</span>dataCapacity <span class="operator">=</span> newDataCapacity;
     }

     drwav_uint8<span class="operator">*</span> pDataOut <span class="operator">=</span> (drwav_uint8<span class="operator">*</span>)(<span class="operator">*</span>memory<span class="operator">-</span><span class="operator">&gt;</span>ppData);
     DRWAV_COPY_MEMORY(pDataOut <span class="operator">+</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos<span class="operator">,</span> pDataIn<span class="operator">,</span> bytesToWrite);

     memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos <span class="operator">+</span><span class="operator">=</span> bytesToWrite;
     <span class="keyword">if</span> (memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize <span class="operator">&lt;</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos) {
         memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize <span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos;
     }

     <span class="operator">*</span>memory<span class="operator">-</span><span class="operator">&gt;</span>pDataSize <span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize;

     <span class="keyword">return</span> bytesToWrite;
 }

 <span class="keyword">static</span> drwav_bool32 drwav__on_seek_memory_write(<span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">int</span> offset<span class="operator">,</span> drwav_seek_origin origin)
 {
     drwav__memory_stream_write<span class="operator">*</span> memory <span class="operator">=</span> (drwav__memory_stream_write<span class="operator">*</span>)pUserData;
     drwav_assert(memory <span class="operator">!</span><span class="operator">=</span> NULL);

     <span class="keyword">if</span> (origin <span class="operator">=</span><span class="operator">=</span> drwav_seek_origin_current) {
         <span class="keyword">if</span> (offset <span class="operator">&gt;</span> <span class="number">0</span>) {
             <span class="keyword">if</span> (memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos <span class="operator">+</span> offset <span class="operator">&gt;</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize) {
                 offset <span class="operator">=</span> (<span class="type">int</span>)(memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize <span class="operator">-</span> memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos);  <span class="comment">// Trying to seek too far forward.</span>
             }
         } <span class="keyword">else</span> {
             <span class="keyword">if</span> (memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos <span class="operator">&lt;</span> (size_t)<span class="operator">-</span>offset) {
                 offset <span class="operator">=</span> <span class="operator">-</span>(<span class="type">int</span>)memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos;  <span class="comment">// Trying to seek too far backwards.</span>
             }
         }

         <span class="comment">// This will never underflow thanks to the clamps above.</span>
         memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos <span class="operator">+</span><span class="operator">=</span> offset;
     } <span class="keyword">else</span> {
         <span class="keyword">if</span> ((drwav_uint32)offset <span class="operator">&lt;</span><span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize) {
             memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos <span class="operator">=</span> offset;
         } <span class="keyword">else</span> {
             memory<span class="operator">-</span><span class="operator">&gt;</span>currentWritePos <span class="operator">=</span> memory<span class="operator">-</span><span class="operator">&gt;</span>dataSize;  <span class="comment">// Trying to seek too far forward.</span>
         }
     }

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 drwav_bool32 drwav_init_memory(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize)
 {
     <span class="keyword">return</span> drwav_init_memory_ex(pWav<span class="operator">,</span> data<span class="operator">,</span> dataSize<span class="operator">,</span> NULL<span class="operator">,</span> NULL<span class="operator">,</span> <span class="number">0</span>);
 }

 drwav_bool32 drwav_init_memory_ex(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags)
 {
     <span class="keyword">if</span> (data <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> dataSize <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     drwav__memory_stream memoryStream;
     drwav_zero_memory(<span class="operator">&amp;</span>memoryStream<span class="operator">,</span> <span class="keyword">sizeof</span>(memoryStream));
     memoryStream<span class="operator">.</span>data <span class="operator">=</span> (<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span>)data;
     memoryStream<span class="operator">.</span>dataSize <span class="operator">=</span> dataSize;
     memoryStream<span class="operator">.</span>currentReadPos <span class="operator">=</span> <span class="number">0</span>;

     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_ex(pWav<span class="operator">,</span> drwav__on_read_memory<span class="operator">,</span> drwav__on_seek_memory<span class="operator">,</span> onChunk<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)<span class="operator">&amp;</span>memoryStream<span class="operator">,</span> pChunkUserData<span class="operator">,</span> flags)) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStream <span class="operator">=</span> memoryStream;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData <span class="operator">=</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStream;
     <span class="keyword">return</span> DRWAV_TRUE;
 }

 drwav_bool32 drwav_init_memory_write__internal(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential)
 {
     <span class="keyword">if</span> (ppData <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="operator">*</span>ppData <span class="operator">=</span> NULL; <span class="comment">// Important because we're using realloc()!</span>
     <span class="operator">*</span>pDataSize <span class="operator">=</span> <span class="number">0</span>;

     drwav__memory_stream_write memoryStreamWrite;
     drwav_zero_memory(<span class="operator">&amp;</span>memoryStreamWrite<span class="operator">,</span> <span class="keyword">sizeof</span>(memoryStreamWrite));
     memoryStreamWrite<span class="operator">.</span>ppData <span class="operator">=</span> ppData;
     memoryStreamWrite<span class="operator">.</span>pDataSize <span class="operator">=</span> pDataSize;
     memoryStreamWrite<span class="operator">.</span>dataSize <span class="operator">=</span> <span class="number">0</span>;
     memoryStreamWrite<span class="operator">.</span>dataCapacity <span class="operator">=</span> <span class="number">0</span>;
     memoryStreamWrite<span class="operator">.</span>currentWritePos <span class="operator">=</span> <span class="number">0</span>;

     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_write__internal(pWav<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> isSequential<span class="operator">,</span> drwav__on_write_memory<span class="operator">,</span> drwav__on_seek_memory_write<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)<span class="operator">&amp;</span>memoryStreamWrite)) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStreamWrite <span class="operator">=</span> memoryStreamWrite;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData <span class="operator">=</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStreamWrite;
     <span class="keyword">return</span> DRWAV_TRUE;
 }

 drwav_bool32 drwav_init_memory_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat)
 {
     <span class="keyword">return</span> drwav_init_memory_write__internal(pWav<span class="operator">,</span> ppData<span class="operator">,</span> pDataSize<span class="operator">,</span> pFormat<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> DRWAV_FALSE);
 }

 drwav_bool32 drwav_init_memory_write_sequential(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount)
 {
     <span class="keyword">return</span> drwav_init_memory_write__internal(pWav<span class="operator">,</span> ppData<span class="operator">,</span> pDataSize<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> DRWAV_TRUE);
 }

 drwav<span class="operator">*</span> drwav_open_memory(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize)
 {
     <span class="keyword">return</span> drwav_open_memory_ex(data<span class="operator">,</span> dataSize<span class="operator">,</span> NULL<span class="operator">,</span> NULL<span class="operator">,</span> <span class="number">0</span>);
 }

 drwav<span class="operator">*</span> drwav_open_memory_ex(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags)
 {
     <span class="keyword">if</span> (data <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> dataSize <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> NULL;
     }

     drwav__memory_stream memoryStream;
     drwav_zero_memory(<span class="operator">&amp;</span>memoryStream<span class="operator">,</span> <span class="keyword">sizeof</span>(memoryStream));
     memoryStream<span class="operator">.</span>data <span class="operator">=</span> (<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span>)data;
     memoryStream<span class="operator">.</span>dataSize <span class="operator">=</span> dataSize;
     memoryStream<span class="operator">.</span>currentReadPos <span class="operator">=</span> <span class="number">0</span>;

     drwav<span class="operator">*</span> pWav <span class="operator">=</span> drwav_open_ex(drwav__on_read_memory<span class="operator">,</span> drwav__on_seek_memory<span class="operator">,</span> onChunk<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)<span class="operator">&amp;</span>memoryStream<span class="operator">,</span> pChunkUserData<span class="operator">,</span> flags);
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStream <span class="operator">=</span> memoryStream;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData <span class="operator">=</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStream;
     <span class="keyword">return</span> pWav;
 }

 drwav<span class="operator">*</span> drwav_open_memory_write__internal(<span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential)
 {
     <span class="keyword">if</span> (ppData <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="operator">*</span>ppData <span class="operator">=</span> NULL; <span class="comment">// Important because we're using realloc()!</span>
     <span class="operator">*</span>pDataSize <span class="operator">=</span> <span class="number">0</span>;

     drwav__memory_stream_write memoryStreamWrite;
     drwav_zero_memory(<span class="operator">&amp;</span>memoryStreamWrite<span class="operator">,</span> <span class="keyword">sizeof</span>(memoryStreamWrite));
     memoryStreamWrite<span class="operator">.</span>ppData <span class="operator">=</span> ppData;
     memoryStreamWrite<span class="operator">.</span>pDataSize <span class="operator">=</span> pDataSize;
     memoryStreamWrite<span class="operator">.</span>dataSize <span class="operator">=</span> <span class="number">0</span>;
     memoryStreamWrite<span class="operator">.</span>dataCapacity <span class="operator">=</span> <span class="number">0</span>;
     memoryStreamWrite<span class="operator">.</span>currentWritePos <span class="operator">=</span> <span class="number">0</span>;

     drwav<span class="operator">*</span> pWav <span class="operator">=</span> drwav_open_write__internal(pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> isSequential<span class="operator">,</span> drwav__on_write_memory<span class="operator">,</span> drwav__on_seek_memory_write<span class="operator">,</span> (<span class="type">void</span><span class="operator">*</span>)<span class="operator">&amp;</span>memoryStreamWrite);
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStreamWrite <span class="operator">=</span> memoryStreamWrite;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData <span class="operator">=</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>memoryStreamWrite;
     <span class="keyword">return</span> pWav;
 }

 drwav<span class="operator">*</span> drwav_open_memory_write(<span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat)
 {
     <span class="keyword">return</span> drwav_open_memory_write__internal(ppData<span class="operator">,</span> pDataSize<span class="operator">,</span> pFormat<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> DRWAV_FALSE);
 }

 drwav<span class="operator">*</span> drwav_open_memory_write_sequential(<span class="type">void</span><span class="operator">*</span><span class="operator">*</span> ppData<span class="operator">,</span> size_t<span class="operator">*</span> pDataSize<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount)
 {
     <span class="keyword">return</span> drwav_open_memory_write__internal(ppData<span class="operator">,</span> pDataSize<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> DRWAV_TRUE);
 }

 size_t drwav__on_read(drwav_read_proc onRead<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut<span class="operator">,</span> size_t bytesToRead<span class="operator">,</span> drwav_uint64<span class="operator">*</span> pCursor)
 {
     drwav_assert(onRead <span class="operator">!</span><span class="operator">=</span> NULL);
     drwav_assert(pCursor <span class="operator">!</span><span class="operator">=</span> NULL);

     size_t bytesRead <span class="operator">=</span> onRead(pUserData<span class="operator">,</span> pBufferOut<span class="operator">,</span> bytesToRead);
     <span class="operator">*</span>pCursor <span class="operator">+</span><span class="operator">=</span> bytesRead;
     <span class="keyword">return</span> bytesRead;
 }

 drwav_bool32 drwav__on_seek(drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">int</span> offset<span class="operator">,</span> drwav_seek_origin origin<span class="operator">,</span> drwav_uint64<span class="operator">*</span> pCursor)
 {
     drwav_assert(onSeek <span class="operator">!</span><span class="operator">=</span> NULL);
     drwav_assert(pCursor <span class="operator">!</span><span class="operator">=</span> NULL);

     <span class="keyword">if</span> (<span class="operator">!</span>onSeek(pUserData<span class="operator">,</span> offset<span class="operator">,</span> origin)) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="keyword">if</span> (origin <span class="operator">=</span><span class="operator">=</span> drwav_seek_origin_start) {
         <span class="operator">*</span>pCursor <span class="operator">=</span> offset;
     } <span class="keyword">else</span> {
         <span class="operator">*</span>pCursor <span class="operator">+</span><span class="operator">=</span> offset;
     }

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 <span class="keyword">static</span> drwav_uint32 drwav_get_bytes_per_sample(drwav<span class="operator">*</span> pWav)
 {
     <span class="comment">// The number of bytes per sample is based on the bits per sample or the block align. We prioritize floor(bitsPerSample/8), but if</span>
     <span class="comment">// this is zero or the bits per sample is not a multiple of 8 we need to fall back to the block align.</span>
     drwav_uint32 bytesPerSample <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">3</span>;
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">&amp;</span> <span class="number">0x7</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span>) {
         bytesPerSample <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign<span class="operator">/</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>channels;
     }

     <span class="keyword">return</span> bytesPerSample;
 }

 <span class="keyword">static</span> drwav_uint32 drwav_get_bytes_per_pcm_frame(drwav<span class="operator">*</span> pWav)
 {
     <span class="comment">// The number of bytes per frame is based on the bits per sample or the block align. We prioritize floor(bitsPerSample*channels/8), but if</span>
     <span class="comment">// this is zero or the bits per frame is not a multiple of 8 we need to fall back to the block align.</span>
     drwav_uint32 bitsPerFrame <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>channels;
     drwav_uint32 bytesPerFrame <span class="operator">=</span> bitsPerFrame <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">3</span>;
     <span class="keyword">if</span> (bytesPerFrame <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> (bitsPerFrame <span class="operator">&amp;</span> <span class="number">0x7</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span>) {
         bytesPerFrame <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign;
     }

     <span class="keyword">return</span> bytesPerFrame;
 }

 drwav_bool32 drwav_init(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">return</span> drwav_init_ex(pWav<span class="operator">,</span> onRead<span class="operator">,</span> onSeek<span class="operator">,</span> NULL<span class="operator">,</span> pUserData<span class="operator">,</span> NULL<span class="operator">,</span> <span class="number">0</span>);
 }

 drwav_bool32 drwav_init_ex(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pReadSeekUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags)
 {
     <span class="keyword">if</span> (onRead <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> onSeek <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     drwav_uint64 cursor <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// &lt;-- Keeps track of the byte position so we can seek to specific locations.</span>
     drwav_bool32 sequential <span class="operator">=</span> (flags <span class="operator">&amp;</span> DRWAV_SEQUENTIAL) <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span>;

     drwav_zero_memory(pWav<span class="operator">,</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pWav));
     pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead    <span class="operator">=</span> onRead;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek    <span class="operator">=</span> onSeek;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData <span class="operator">=</span> pReadSeekUserData;

     <span class="comment">// The first 4 bytes should be the RIFF identifier.</span>
     <span class="type">unsigned</span> <span class="type">char</span> riff<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;
     <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> riff<span class="operator">,</span> <span class="keyword">sizeof</span>(riff)<span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(riff)) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="comment">// The first 4 bytes can be used to identify the container. For RIFF files it will start with &quot;RIFF&quot; and for</span>
     <span class="comment">// w64 it will start with &quot;riff&quot;.</span>
     <span class="keyword">if</span> (drwav__fourcc_equal(riff<span class="operator">,</span> <span class="string">&quot;RIFF&quot;</span>)) {
         pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span> drwav_container_riff;
     } <span class="keyword">else</span> <span class="keyword">if</span> (drwav__fourcc_equal(riff<span class="operator">,</span> <span class="string">&quot;riff&quot;</span>)) {
         pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span> drwav_container_w64;

         <span class="comment">// Check the rest of the GUID for validity.</span>
         drwav_uint8 riff2<span class="operator">[</span><span class="number">12</span><span class="operator">]</span>;
         <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> riff2<span class="operator">,</span> <span class="keyword">sizeof</span>(riff2)<span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(riff2)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }

         <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">12</span>; <span class="operator">+</span><span class="operator">+</span>i) {
             <span class="keyword">if</span> (riff2<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">!</span><span class="operator">=</span> drwavGUID_W64_RIFF<span class="operator">[</span>i<span class="operator">+</span><span class="number">4</span><span class="operator">]</span>) {
                 <span class="keyword">return</span> DRWAV_FALSE;
             }
         }
     } <span class="keyword">else</span> {
         <span class="keyword">return</span> DRWAV_FALSE;   <span class="comment">// Unknown or unsupported container.</span>
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
         <span class="comment">// RIFF/WAVE</span>
         <span class="type">unsigned</span> <span class="type">char</span> chunkSizeBytes<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;
         <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> chunkSizeBytes<span class="operator">,</span> <span class="keyword">sizeof</span>(chunkSizeBytes)<span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(chunkSizeBytes)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }

         <span class="type">unsigned</span> <span class="type">int</span> chunkSize <span class="operator">=</span> drwav__bytes_to_u32(chunkSizeBytes);
         <span class="keyword">if</span> (chunkSize <span class="operator">&lt;</span> <span class="number">36</span>) {
             <span class="keyword">return</span> DRWAV_FALSE;    <span class="comment">// Chunk size should always be at least 36 bytes.</span>
         }

         <span class="type">unsigned</span> <span class="type">char</span> wave<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;
         <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> wave<span class="operator">,</span> <span class="keyword">sizeof</span>(wave)<span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(wave)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }

         <span class="keyword">if</span> (<span class="operator">!</span>drwav__fourcc_equal(wave<span class="operator">,</span> <span class="string">&quot;WAVE&quot;</span>)) {
             <span class="keyword">return</span> DRWAV_FALSE;    <span class="comment">// Expecting &quot;WAVE&quot;.</span>
         }
     } <span class="keyword">else</span> {
         <span class="comment">// W64</span>
         <span class="type">unsigned</span> <span class="type">char</span> chunkSize<span class="operator">[</span><span class="number">8</span><span class="operator">]</span>;
         <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> chunkSize<span class="operator">,</span> <span class="keyword">sizeof</span>(chunkSize)<span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(chunkSize)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }

         <span class="keyword">if</span> (drwav__bytes_to_u64(chunkSize) <span class="operator">&lt;</span> <span class="number">80</span>) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }

         drwav_uint8 wave<span class="operator">[</span><span class="number">16</span><span class="operator">]</span>;
         <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> wave<span class="operator">,</span> <span class="keyword">sizeof</span>(wave)<span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(wave)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }

         <span class="keyword">if</span> (<span class="operator">!</span>drwav__guid_equal(wave<span class="operator">,</span> drwavGUID_W64_WAVE)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
     }

     <span class="comment">// The next bytes should be the &quot;fmt &quot; chunk.</span>
     drwav_fmt fmt;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav__read_fmt(onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>container<span class="operator">,</span> <span class="operator">&amp;</span>cursor<span class="operator">,</span> <span class="operator">&amp;</span>fmt)) {
         <span class="keyword">return</span> DRWAV_FALSE;    <span class="comment">// Failed to read the &quot;fmt &quot; chunk.</span>
     }

     <span class="comment">// Basic validation.</span>
     <span class="keyword">if</span> (fmt<span class="operator">.</span>sampleRate <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> fmt<span class="operator">.</span>channels <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> fmt<span class="operator">.</span>bitsPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> fmt<span class="operator">.</span>blockAlign <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// Invalid channel count. Probably an invalid WAV file.</span>
     }

     <span class="comment">// Translate the internal format.</span>
     <span class="type">unsigned</span> <span class="type">short</span> translatedFormatTag <span class="operator">=</span> fmt<span class="operator">.</span>formatTag;
     <span class="keyword">if</span> (translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_EXTENSIBLE) {
         translatedFormatTag <span class="operator">=</span> drwav__bytes_to_u16(fmt<span class="operator">.</span>subFormat <span class="operator">+</span> <span class="number">0</span>);
     }

     drwav_uint64 sampleCountFromFactChunk <span class="operator">=</span> <span class="number">0</span>;

     <span class="comment">// We need to enumerate over each chunk for two reasons:</span>
     <span class="comment">//   1) The &quot;data&quot; chunk may not be the next one</span>
     <span class="comment">//   2) We may want to report each chunk back to the client</span>
     <span class="comment">//</span>
     <span class="comment">// In order to correctly report each chunk back to the client we will need to keep looping until the end of the file.</span>
     drwav_bool32 foundDataChunk <span class="operator">=</span> DRWAV_FALSE;
     drwav_uint64 dataChunkSize <span class="operator">=</span> <span class="number">0</span>;

     <span class="comment">// The next chunk we care about is the &quot;data&quot; chunk. This is not necessarily the next chunk so we'll need to loop.</span>
     drwav_uint64 chunkSize <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">for</span> (;;)
     {
         drwav_chunk_header header;
         drwav_result result <span class="operator">=</span> drwav__read_chunk_header(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>container<span class="operator">,</span> <span class="operator">&amp;</span>cursor<span class="operator">,</span> <span class="operator">&amp;</span>header);
         <span class="keyword">if</span> (result <span class="operator">!</span><span class="operator">=</span> DRWAV_SUCCESS) {
             <span class="keyword">if</span> (<span class="operator">!</span>foundDataChunk) {
                 <span class="keyword">return</span> DRWAV_FALSE;
             } <span class="keyword">else</span> {
                 <span class="keyword">break</span>;  <span class="comment">// Probably at the end of the file. Get out of the loop.</span>
             }
         }

         <span class="comment">// Tell the client about this chunk.</span>
         <span class="keyword">if</span> (<span class="operator">!</span>sequential <span class="operator">&amp;</span><span class="operator">&amp;</span> onChunk <span class="operator">!</span><span class="operator">=</span> NULL) {
             drwav_uint64 callbackBytesRead <span class="operator">=</span> onChunk(pChunkUserData<span class="operator">,</span> onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> <span class="operator">&amp;</span>header);

             <span class="comment">// dr_wav may need to read the contents of the chunk, so we now need to seek back to the position before</span>
             <span class="comment">// we called the callback.</span>
             <span class="keyword">if</span> (callbackBytesRead <span class="operator">&gt;</span> <span class="number">0</span>) {
                 <span class="keyword">if</span> (<span class="operator">!</span>drwav__seek_from_start(onSeek<span class="operator">,</span> cursor<span class="operator">,</span> pReadSeekUserData)) {
                     <span class="keyword">return</span> DRWAV_FALSE;
                 }
             }
         }

         <span class="keyword">if</span> (<span class="operator">!</span>foundDataChunk) {
             pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos <span class="operator">=</span> cursor;
         }

         chunkSize <span class="operator">=</span> header<span class="operator">.</span>sizeInBytes;
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
             <span class="keyword">if</span> (drwav__fourcc_equal(header<span class="operator">.</span>id<span class="operator">.</span>fourcc<span class="operator">,</span> <span class="string">&quot;data&quot;</span>)) {
                 foundDataChunk <span class="operator">=</span> DRWAV_TRUE;
                 dataChunkSize <span class="operator">=</span> chunkSize;
             }
         } <span class="keyword">else</span> {
             <span class="keyword">if</span> (drwav__guid_equal(header<span class="operator">.</span>id<span class="operator">.</span>guid<span class="operator">,</span> drwavGUID_W64_DATA)) {
                 foundDataChunk <span class="operator">=</span> DRWAV_TRUE;
                 dataChunkSize <span class="operator">=</span> chunkSize;
             }
         }

         <span class="comment">// If at this point we have found the data chunk and we're running in sequential mode, we need to break out of this loop. The reason for</span>
         <span class="comment">// this is that we would otherwise require a backwards seek which sequential mode forbids.</span>
         <span class="keyword">if</span> (foundDataChunk <span class="operator">&amp;</span><span class="operator">&amp;</span> sequential) {
             <span class="keyword">break</span>;
         }

         <span class="comment">// Optional. Get the total sample count from the FACT chunk. This is useful for compressed formats.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
             <span class="keyword">if</span> (drwav__fourcc_equal(header<span class="operator">.</span>id<span class="operator">.</span>fourcc<span class="operator">,</span> <span class="string">&quot;fact&quot;</span>)) {
                 drwav_uint32 sampleCount;
                 <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> <span class="operator">&amp;</span>sampleCount<span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="number">4</span>) {
                     <span class="keyword">return</span> DRWAV_FALSE;
                 }
                 chunkSize <span class="operator">-</span><span class="operator">=</span> <span class="number">4</span>;

                 <span class="keyword">if</span> (<span class="operator">!</span>foundDataChunk) {
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos <span class="operator">=</span> cursor;
                 }

                 <span class="comment">// The sample count in the &quot;fact&quot; chunk is either unreliable, or I'm not understanding it properly. For now I am only enabling this</span>
                 <span class="comment">// for Microsoft ADPCM formats.</span>
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM) {
                     sampleCountFromFactChunk <span class="operator">=</span> sampleCount;
                 } <span class="keyword">else</span> {
                     sampleCountFromFactChunk <span class="operator">=</span> <span class="number">0</span>;
                 }
             }
         } <span class="keyword">else</span> {
             <span class="keyword">if</span> (drwav__guid_equal(header<span class="operator">.</span>id<span class="operator">.</span>guid<span class="operator">,</span> drwavGUID_W64_FACT)) {
                 <span class="keyword">if</span> (drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> <span class="operator">&amp;</span>sampleCountFromFactChunk<span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="operator">&amp;</span>cursor) <span class="operator">!</span><span class="operator">=</span> <span class="number">8</span>) {
                     <span class="keyword">return</span> DRWAV_FALSE;
                 }
                 chunkSize <span class="operator">-</span><span class="operator">=</span> <span class="number">8</span>;

                 <span class="keyword">if</span> (<span class="operator">!</span>foundDataChunk) {
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos <span class="operator">=</span> cursor;
                 }
             }
         }

         <span class="comment">// &quot;smpl&quot; chunk.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
             <span class="keyword">if</span> (drwav__fourcc_equal(header<span class="operator">.</span>id<span class="operator">.</span>fourcc<span class="operator">,</span> <span class="string">&quot;smpl&quot;</span>)) {
                 <span class="type">unsigned</span> <span class="type">char</span> smplHeaderData<span class="operator">[</span><span class="number">36</span><span class="operator">]</span>;    <span class="comment">// 36 = size of the smpl header section, not including the loop data.</span>
                 <span class="keyword">if</span> (chunkSize <span class="operator">&gt;</span><span class="operator">=</span> <span class="keyword">sizeof</span>(smplHeaderData)) {
                     drwav_uint64 bytesJustRead <span class="operator">=</span> drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> smplHeaderData<span class="operator">,</span> <span class="keyword">sizeof</span>(smplHeaderData)<span class="operator">,</span> <span class="operator">&amp;</span>cursor);
                     chunkSize <span class="operator">-</span><span class="operator">=</span> bytesJustRead;

                     <span class="keyword">if</span> (bytesJustRead <span class="operator">=</span><span class="operator">=</span> <span class="keyword">sizeof</span>(smplHeaderData)) {
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>manufacturer      <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">0</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>product           <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">4</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>samplePeriod      <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">8</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>midiUnityNotes    <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">12</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>midiPitchFraction <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">16</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>smpteFormat       <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">20</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>smpteOffset       <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">24</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>numSampleLoops    <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">28</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>samplerData       <span class="operator">=</span> drwav__bytes_to_u32(smplHeaderData<span class="operator">+</span><span class="number">32</span>);

                         <span class="keyword">for</span> (drwav_uint32 iLoop <span class="operator">=</span> <span class="number">0</span>; iLoop <span class="operator">&lt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>numSampleLoops <span class="operator">&amp;</span><span class="operator">&amp;</span> iLoop <span class="operator">&lt;</span> drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>loops); <span class="operator">+</span><span class="operator">+</span>iLoop) {
                             <span class="type">unsigned</span> <span class="type">char</span> smplLoopData<span class="operator">[</span><span class="number">24</span><span class="operator">]</span>;  <span class="comment">// 24 = size of a loop section in the smpl chunk.</span>
                             bytesJustRead <span class="operator">=</span> drwav__on_read(onRead<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> smplLoopData<span class="operator">,</span> <span class="keyword">sizeof</span>(smplLoopData)<span class="operator">,</span> <span class="operator">&amp;</span>cursor);
                             chunkSize <span class="operator">-</span><span class="operator">=</span> bytesJustRead;

                             <span class="keyword">if</span> (bytesJustRead <span class="operator">=</span><span class="operator">=</span> <span class="keyword">sizeof</span>(smplLoopData)) {
                                 pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>loops<span class="operator">[</span>iLoop<span class="operator">]</span><span class="operator">.</span>cuePointId <span class="operator">=</span> drwav__bytes_to_u32(smplLoopData<span class="operator">+</span><span class="number">0</span>);
                                 pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>loops<span class="operator">[</span>iLoop<span class="operator">]</span><span class="operator">.</span>type       <span class="operator">=</span> drwav__bytes_to_u32(smplLoopData<span class="operator">+</span><span class="number">4</span>);
                                 pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>loops<span class="operator">[</span>iLoop<span class="operator">]</span><span class="operator">.</span>start      <span class="operator">=</span> drwav__bytes_to_u32(smplLoopData<span class="operator">+</span><span class="number">8</span>);
                                 pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>loops<span class="operator">[</span>iLoop<span class="operator">]</span><span class="operator">.</span>end        <span class="operator">=</span> drwav__bytes_to_u32(smplLoopData<span class="operator">+</span><span class="number">12</span>);
                                 pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>loops<span class="operator">[</span>iLoop<span class="operator">]</span><span class="operator">.</span>fraction   <span class="operator">=</span> drwav__bytes_to_u32(smplLoopData<span class="operator">+</span><span class="number">16</span>);
                                 pWav<span class="operator">-</span><span class="operator">&gt;</span>smpl<span class="operator">.</span>loops<span class="operator">[</span>iLoop<span class="operator">]</span><span class="operator">.</span>playCount  <span class="operator">=</span> drwav__bytes_to_u32(smplLoopData<span class="operator">+</span><span class="number">20</span>);
                             } <span class="keyword">else</span> {
                                 <span class="keyword">break</span>;  <span class="comment">// Break from the smpl loop for loop.</span>
                             }
                         }
                     }
                 } <span class="keyword">else</span> {
                     <span class="comment">// Looks like invalid data. Ignore the chunk.</span>
                 }
             }
         } <span class="keyword">else</span> {
             <span class="keyword">if</span> (drwav__guid_equal(header<span class="operator">.</span>id<span class="operator">.</span>guid<span class="operator">,</span> drwavGUID_W64_SMPL)) {
                 <span class="comment">// This path will be hit when a W64 WAV file contains a smpl chunk. I don't have a sample file to test this path, so a contribution</span>
                 <span class="comment">// is welcome to add support for this.</span>
             }
         }

         <span class="comment">// Make sure we seek past the padding.</span>
         chunkSize <span class="operator">+</span><span class="operator">=</span> header<span class="operator">.</span>paddingSize;
         <span class="keyword">if</span> (<span class="operator">!</span>drwav__seek_forward(onSeek<span class="operator">,</span> chunkSize<span class="operator">,</span> pReadSeekUserData)) {
             <span class="keyword">break</span>;
         }
         cursor <span class="operator">+</span><span class="operator">=</span> chunkSize;

         <span class="keyword">if</span> (<span class="operator">!</span>foundDataChunk) {
             pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos <span class="operator">=</span> cursor;
         }
     }

     <span class="comment">// If we haven't found a data chunk, return an error.</span>
     <span class="keyword">if</span> (<span class="operator">!</span>foundDataChunk) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="comment">// We may have moved passed the data chunk. If so we need to move back. If running in sequential mode we can assume we are already sitting on the data chunk.</span>
     <span class="keyword">if</span> (<span class="operator">!</span>sequential) {
         <span class="keyword">if</span> (<span class="operator">!</span>drwav__seek_from_start(onSeek<span class="operator">,</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos<span class="operator">,</span> pReadSeekUserData)) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
         cursor <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos;
     }

     <span class="comment">// At this point we should be sitting on the first byte of the raw audio data.</span>

     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt                 <span class="operator">=</span> fmt;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>sampleRate          <span class="operator">=</span> fmt<span class="operator">.</span>sampleRate;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>channels            <span class="operator">=</span> fmt<span class="operator">.</span>channels;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample       <span class="operator">=</span> fmt<span class="operator">.</span>bitsPerSample;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining      <span class="operator">=</span> dataChunkSize;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span> translatedFormatTag;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize   <span class="operator">=</span> dataChunkSize;

     <span class="keyword">if</span> (sampleCountFromFactChunk <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span>) {
         pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">=</span> sampleCountFromFactChunk;
     } <span class="keyword">else</span> {
         pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">=</span> dataChunkSize <span class="operator">/</span> drwav_get_bytes_per_pcm_frame(pWav);

         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM) {
             drwav_uint64 blockCount <span class="operator">=</span> dataChunkSize <span class="operator">/</span> fmt<span class="operator">.</span>blockAlign;
             pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">=</span> (((blockCount <span class="operator">*</span> (fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> (<span class="number">6</span><span class="operator">*</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>channels))) <span class="operator">*</span> <span class="number">2</span>)) <span class="operator">/</span> fmt<span class="operator">.</span>channels;  <span class="comment">// x2 because two samples per byte.</span>
         }
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
             drwav_uint64 blockCount <span class="operator">=</span> dataChunkSize <span class="operator">/</span> fmt<span class="operator">.</span>blockAlign;
             pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">=</span> (((blockCount <span class="operator">*</span> (fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> (<span class="number">4</span><span class="operator">*</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>channels))) <span class="operator">*</span> <span class="number">2</span>) <span class="operator">+</span> (blockCount <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels)) <span class="operator">/</span> fmt<span class="operator">.</span>channels;
         }
     }

     <span class="comment">// Some formats only support a certain number of channels.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM <span class="operator">|</span><span class="operator">|</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">&gt;</span> <span class="number">2</span>) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
     }

 <span class="preprocessor">#ifdef DR_WAV_LIBSNDFILE_COMPAT</span>
     <span class="comment">// I use libsndfile as a benchmark for testing, however in the version I'm using (from the Windows installer on the libsndfile website),</span>
     <span class="comment">// it appears the total sample count libsndfile uses for MS-ADPCM is incorrect. It would seem they are computing the total sample count</span>
     <span class="comment">// from the number of blocks, however this results in the inclusion of extra silent samples at the end of the last block. The correct</span>
     <span class="comment">// way to know the total sample count is to inspect the &quot;fact&quot; chunk, which should always be present for compressed formats, and should</span>
     <span class="comment">// always include the sample count. This little block of code below is only used to emulate the libsndfile logic so I can properly run my</span>
     <span class="comment">// correctness tests against libsndfile, and is disabled by default.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM) {
         drwav_uint64 blockCount <span class="operator">=</span> dataChunkSize <span class="operator">/</span> fmt<span class="operator">.</span>blockAlign;
         pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">=</span> (((blockCount <span class="operator">*</span> (fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> (<span class="number">6</span><span class="operator">*</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>channels))) <span class="operator">*</span> <span class="number">2</span>)) <span class="operator">/</span> fmt<span class="operator">.</span>channels;  <span class="comment">// x2 because two samples per byte.</span>
     }
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
         drwav_uint64 blockCount <span class="operator">=</span> dataChunkSize <span class="operator">/</span> fmt<span class="operator">.</span>blockAlign;
         pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">=</span> (((blockCount <span class="operator">*</span> (fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> (<span class="number">4</span><span class="operator">*</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>channels))) <span class="operator">*</span> <span class="number">2</span>) <span class="operator">+</span> (blockCount <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels)) <span class="operator">/</span> fmt<span class="operator">.</span>channels;
     }
 <span class="preprocessor">#endif</span>

     pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 drwav_uint32 drwav_riff_chunk_size_riff(drwav_uint64 dataChunkSize)
 {
     <span class="keyword">if</span> (dataChunkSize <span class="operator">&lt;</span><span class="operator">=</span> (<span class="number">0xFFFFFFFF</span> <span class="operator">-</span> <span class="number">36</span>)) {
         <span class="keyword">return</span> <span class="number">36</span> <span class="operator">+</span> (drwav_uint32)dataChunkSize;
     } <span class="keyword">else</span> {
         <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>;
     }
 }

 drwav_uint32 drwav_data_chunk_size_riff(drwav_uint64 dataChunkSize)
 {
     <span class="keyword">if</span> (dataChunkSize <span class="operator">&lt;</span><span class="operator">=</span> <span class="number">0xFFFFFFFF</span>) {
         <span class="keyword">return</span> (drwav_uint32)dataChunkSize;
     } <span class="keyword">else</span> {
         <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>;
     }
 }

 drwav_uint64 drwav_riff_chunk_size_w64(drwav_uint64 dataChunkSize)
 {
     <span class="keyword">return</span> <span class="number">80</span> <span class="operator">+</span> <span class="number">24</span> <span class="operator">+</span> dataChunkSize;   <span class="comment">// +24 because W64 includes the size of the GUID and size fields.</span>
 }

 drwav_uint64 drwav_data_chunk_size_w64(drwav_uint64 dataChunkSize)
 {
     <span class="keyword">return</span> <span class="number">24</span> <span class="operator">+</span> dataChunkSize;        <span class="comment">// +24 because W64 includes the size of the GUID and size fields.</span>
 }

 drwav_bool32 drwav_init_write__internal(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="keyword">if</span> (onWrite <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="keyword">if</span> (<span class="operator">!</span>isSequential <span class="operator">&amp;</span><span class="operator">&amp;</span> onSeek <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// &lt;-- onSeek is required when in non-sequential mode.</span>
     }

     <span class="comment">// Not currently supporting compressed formats. Will need to add support for the &quot;fact&quot; chunk before we enable this.</span>
     <span class="keyword">if</span> (pFormat<span class="operator">-</span><span class="operator">&gt;</span>format <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_EXTENSIBLE) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }
     <span class="keyword">if</span> (pFormat<span class="operator">-</span><span class="operator">&gt;</span>format <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM <span class="operator">|</span><span class="operator">|</span> pFormat<span class="operator">-</span><span class="operator">&gt;</span>format <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     drwav_zero_memory(pWav<span class="operator">,</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pWav));
     pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite <span class="operator">=</span> onWrite;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek <span class="operator">=</span> onSeek;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData <span class="operator">=</span> pUserData;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>formatTag <span class="operator">=</span> (drwav_uint16)pFormat<span class="operator">-</span><span class="operator">&gt;</span>format;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>channels <span class="operator">=</span> (drwav_uint16)pFormat<span class="operator">-</span><span class="operator">&gt;</span>channels;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>sampleRate <span class="operator">=</span> pFormat<span class="operator">-</span><span class="operator">&gt;</span>sampleRate;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>avgBytesPerSec <span class="operator">=</span> (drwav_uint32)((pFormat<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">*</span> pFormat<span class="operator">-</span><span class="operator">&gt;</span>sampleRate <span class="operator">*</span> pFormat<span class="operator">-</span><span class="operator">&gt;</span>channels) <span class="operator">/</span> <span class="number">8</span>);
     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign <span class="operator">=</span> (drwav_uint16)((pFormat<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">*</span> pFormat<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample) <span class="operator">/</span> <span class="number">8</span>);
     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>bitsPerSample <span class="operator">=</span> (drwav_uint16)pFormat<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>extendedSize <span class="operator">=</span> <span class="number">0</span>;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>isSequentialWrite <span class="operator">=</span> isSequential;

     size_t runningPos <span class="operator">=</span> <span class="number">0</span>;

     <span class="comment">// The initial values for the &quot;RIFF&quot; and &quot;data&quot; chunks depends on whether or not we are initializing in sequential mode or not. In</span>
     <span class="comment">// sequential mode we set this to its final values straight away since they can be calculated from the total sample count. In non-</span>
     <span class="comment">// sequential mode we initialize it all to zero and fill it out in drwav_uninit() using a backwards seek.</span>
     drwav_uint64 initialDataChunkSize <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (isSequential) {
         initialDataChunkSize <span class="operator">=</span> (totalSampleCount <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>bitsPerSample) <span class="operator">/</span> <span class="number">8</span>;

         <span class="comment">// The RIFF container has a limit on the number of samples. drwav is not allowing this. There's no practical limits for Wave64</span>
         <span class="comment">// so for the sake of simplicity I'm not doing any validation for that.</span>
         <span class="keyword">if</span> (pFormat<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
             <span class="keyword">if</span> (initialDataChunkSize <span class="operator">&gt;</span> (<span class="number">0xFFFFFFFF</span> <span class="operator">-</span> <span class="number">36</span>)) {
                 <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// Not enough room to store every sample.</span>
             }
         }
     }

     pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSizeTargetWrite <span class="operator">=</span> initialDataChunkSize;

     <span class="comment">// &quot;RIFF&quot; chunk.</span>
     <span class="keyword">if</span> (pFormat<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
         drwav_uint32 chunkSizeRIFF <span class="operator">=</span> <span class="number">36</span> <span class="operator">+</span> (drwav_uint32)initialDataChunkSize;   <span class="comment">// +36 = &quot;RIFF&quot;+[RIFF Chunk Size]+&quot;WAVE&quot; + [sizeof &quot;fmt &quot; chunk]</span>
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="string">&quot;RIFF&quot;</span><span class="operator">,</span> <span class="number">4</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>chunkSizeRIFF<span class="operator">,</span> <span class="number">4</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="string">&quot;WAVE&quot;</span><span class="operator">,</span> <span class="number">4</span>);
     } <span class="keyword">else</span> {
         drwav_uint64 chunkSizeRIFF <span class="operator">=</span> <span class="number">80</span> <span class="operator">+</span> <span class="number">24</span> <span class="operator">+</span> initialDataChunkSize;   <span class="comment">// +24 because W64 includes the size of the GUID and size fields.</span>
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> drwavGUID_W64_RIFF<span class="operator">,</span> <span class="number">16</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>chunkSizeRIFF<span class="operator">,</span> <span class="number">8</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> drwavGUID_W64_WAVE<span class="operator">,</span> <span class="number">16</span>);
     }

     <span class="comment">// &quot;fmt &quot; chunk.</span>
     drwav_uint64 chunkSizeFMT;
     <span class="keyword">if</span> (pFormat<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
         chunkSizeFMT <span class="operator">=</span> <span class="number">16</span>;
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="string">&quot;fmt &quot;</span><span class="operator">,</span> <span class="number">4</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>chunkSizeFMT<span class="operator">,</span> <span class="number">4</span>);
     } <span class="keyword">else</span> {
         chunkSizeFMT <span class="operator">=</span> <span class="number">40</span>;
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> drwavGUID_W64_FMT<span class="operator">,</span> <span class="number">16</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>chunkSizeFMT<span class="operator">,</span> <span class="number">8</span>);
     }

     runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>formatTag<span class="operator">,</span>      <span class="number">2</span>);
     runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>channels<span class="operator">,</span>       <span class="number">2</span>);
     runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>sampleRate<span class="operator">,</span>     <span class="number">4</span>);
     runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>avgBytesPerSec<span class="operator">,</span> <span class="number">4</span>);
     runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign<span class="operator">,</span>     <span class="number">2</span>);
     runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>bitsPerSample<span class="operator">,</span>  <span class="number">2</span>);

     pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos <span class="operator">=</span> runningPos;

     <span class="comment">// &quot;data&quot; chunk.</span>
     <span class="keyword">if</span> (pFormat<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
         drwav_uint32 chunkSizeDATA <span class="operator">=</span> (drwav_uint32)initialDataChunkSize;
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="string">&quot;data&quot;</span><span class="operator">,</span> <span class="number">4</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>chunkSizeDATA<span class="operator">,</span> <span class="number">4</span>);
     } <span class="keyword">else</span> {
         drwav_uint64 chunkSizeDATA <span class="operator">=</span> <span class="number">24</span> <span class="operator">+</span> initialDataChunkSize; <span class="comment">// +24 because W64 includes the size of the GUID and size fields.</span>
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> drwavGUID_W64_DATA<span class="operator">,</span> <span class="number">16</span>);
         runningPos <span class="operator">+</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pUserData<span class="operator">,</span> <span class="operator">&amp;</span>chunkSizeDATA<span class="operator">,</span> <span class="number">8</span>);
     }

     <span class="comment">// Simple validation.</span>
     <span class="keyword">if</span> (pFormat<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
         <span class="keyword">if</span> (runningPos <span class="operator">!</span><span class="operator">=</span> <span class="number">20</span> <span class="operator">+</span> chunkSizeFMT <span class="operator">+</span> <span class="number">8</span>) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
     } <span class="keyword">else</span> {
         <span class="keyword">if</span> (runningPos <span class="operator">!</span><span class="operator">=</span> <span class="number">40</span> <span class="operator">+</span> chunkSizeFMT <span class="operator">+</span> <span class="number">24</span>) {
             <span class="keyword">return</span> DRWAV_FALSE;
         }
     }

     <span class="comment">// Set some properties for the client's convenience.</span>
     pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span> pFormat<span class="operator">-</span><span class="operator">&gt;</span>container;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">=</span> (drwav_uint16)pFormat<span class="operator">-</span><span class="operator">&gt;</span>channels;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>sampleRate <span class="operator">=</span> pFormat<span class="operator">-</span><span class="operator">&gt;</span>sampleRate;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">=</span> (drwav_uint16)pFormat<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample;
     pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span> (drwav_uint16)pFormat<span class="operator">-</span><span class="operator">&gt;</span>format;

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 drwav_bool32 drwav_init_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">return</span> drwav_init_write__internal(pWav<span class="operator">,</span> pFormat<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> DRWAV_FALSE<span class="operator">,</span> onWrite<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData);               <span class="comment">// DRWAV_FALSE = Not Sequential</span>
 }

 drwav_bool32 drwav_init_write_sequential(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">return</span> drwav_init_write__internal(pWav<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> DRWAV_TRUE<span class="operator">,</span> onWrite<span class="operator">,</span> NULL<span class="operator">,</span> pUserData);   <span class="comment">// DRWAV_TRUE = Sequential</span>
 }

 <span class="type">void</span> drwav_uninit(drwav<span class="operator">*</span> pWav)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="comment">// If the drwav object was opened in write mode we'll need to finalize a few things:</span>
     <span class="comment">//   - Make sure the &quot;data&quot; chunk is aligned to 16-bits for RIFF containers, or 64 bits for W64 containers.</span>
     <span class="comment">//   - Set the size of the &quot;data&quot; chunk.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite <span class="operator">!</span><span class="operator">=</span> NULL) {
         <span class="comment">// Validation for sequential mode.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>isSequentialWrite) {
             drwav_assert(pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize <span class="operator">=</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSizeTargetWrite);
         }

         <span class="comment">// Padding. Do not adjust pWav-&gt;dataChunkDataSize - this should not include the padding.</span>
         drwav_uint32 paddingSize <span class="operator">=</span> <span class="number">0</span>;
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
             paddingSize <span class="operator">=</span> (drwav_uint32)(pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize <span class="operator">%</span> <span class="number">2</span>);
         } <span class="keyword">else</span> {
             paddingSize <span class="operator">=</span> (drwav_uint32)(pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize <span class="operator">%</span> <span class="number">8</span>);
         }

         <span class="keyword">if</span> (paddingSize <span class="operator">&gt;</span> <span class="number">0</span>) {
             drwav_uint64 paddingData <span class="operator">=</span> <span class="number">0</span>;
             pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="operator">&amp;</span>paddingData<span class="operator">,</span> paddingSize);
         }

         <span class="comment">// Chunk sizes. When using sequential mode, these will have been filled in at initialization time. We only need</span>
         <span class="comment">// to do this when using non-sequential mode.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>isSequentialWrite) {
             <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>container <span class="operator">=</span><span class="operator">=</span> drwav_container_riff) {
                 <span class="comment">// The &quot;RIFF&quot; chunk size.</span>
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> drwav_seek_origin_start)) {
                     drwav_uint32 riffChunkSize <span class="operator">=</span> drwav_riff_chunk_size_riff(pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize);
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="operator">&amp;</span>riffChunkSize<span class="operator">,</span> <span class="number">4</span>);
                 }

                 <span class="comment">// the &quot;data&quot; chunk size.</span>
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> (<span class="type">int</span>)pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos <span class="operator">+</span> <span class="number">4</span><span class="operator">,</span> drwav_seek_origin_start)) {
                     drwav_uint32 dataChunkSize <span class="operator">=</span> drwav_data_chunk_size_riff(pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize);
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="operator">&amp;</span>dataChunkSize<span class="operator">,</span> <span class="number">4</span>);
                 }
             } <span class="keyword">else</span> {
                 <span class="comment">// The &quot;RIFF&quot; chunk size.</span>
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> drwav_seek_origin_start)) {
                     drwav_uint64 riffChunkSize <span class="operator">=</span> drwav_riff_chunk_size_w64(pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize);
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="operator">&amp;</span>riffChunkSize<span class="operator">,</span> <span class="number">8</span>);
                 }

                 <span class="comment">// The &quot;data&quot; chunk size.</span>
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> (<span class="type">int</span>)pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos <span class="operator">+</span> <span class="number">16</span><span class="operator">,</span> drwav_seek_origin_start)) {
                     drwav_uint64 dataChunkSize <span class="operator">=</span> drwav_data_chunk_size_w64(pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize);
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="operator">&amp;</span>dataChunkSize<span class="operator">,</span> <span class="number">8</span>);
                 }
             }
         }
     }

 <span class="preprocessor">#ifndef DR_WAV_NO_STDIO</span>
     <span class="comment">// If we opened the file with drwav_open_file() we will want to close the file handle. We can know whether or not drwav_open_file()</span>
     <span class="comment">// was used by looking at the onRead and onSeek callbacks.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead <span class="operator">=</span><span class="operator">=</span> drwav__on_read_stdio <span class="operator">|</span><span class="operator">|</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite <span class="operator">=</span><span class="operator">=</span> drwav__on_write_stdio) {
         fclose((FILE<span class="operator">*</span>)pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData);
     }
 <span class="preprocessor">#endif</span>
 }

 drwav<span class="operator">*</span> drwav_open(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">return</span> drwav_open_ex(onRead<span class="operator">,</span> onSeek<span class="operator">,</span> NULL<span class="operator">,</span> pUserData<span class="operator">,</span> NULL<span class="operator">,</span> <span class="number">0</span>);
 }

 drwav<span class="operator">*</span> drwav_open_ex(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> drwav_chunk_proc onChunk<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pReadSeekUserData<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pChunkUserData<span class="operator">,</span> drwav_uint32 flags)
 {
     drwav<span class="operator">*</span> pWav <span class="operator">=</span> (drwav<span class="operator">*</span>)DRWAV_MALLOC(<span class="keyword">sizeof</span>(<span class="operator">*</span>pWav));
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_ex(pWav<span class="operator">,</span> onRead<span class="operator">,</span> onSeek<span class="operator">,</span> onChunk<span class="operator">,</span> pReadSeekUserData<span class="operator">,</span> pChunkUserData<span class="operator">,</span> flags)) {
         DRWAV_FREE(pWav);
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> pWav;
 }

 drwav<span class="operator">*</span> drwav_open_write__internal(<span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_bool32 isSequential<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     drwav<span class="operator">*</span> pWav <span class="operator">=</span> (drwav<span class="operator">*</span>)DRWAV_MALLOC(<span class="keyword">sizeof</span>(<span class="operator">*</span>pWav));
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_write__internal(pWav<span class="operator">,</span> pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> isSequential<span class="operator">,</span> onWrite<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData)) {
         DRWAV_FREE(pWav);
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> pWav;
 }

 drwav<span class="operator">*</span> drwav_open_write(<span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">return</span> drwav_open_write__internal(pFormat<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> DRWAV_FALSE<span class="operator">,</span> onWrite<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData);
 }

 drwav<span class="operator">*</span> drwav_open_write_sequential(<span class="keyword">const</span> drwav_data_format<span class="operator">*</span> pFormat<span class="operator">,</span> drwav_uint64 totalSampleCount<span class="operator">,</span> drwav_write_proc onWrite<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData)
 {
     <span class="keyword">return</span> drwav_open_write__internal(pFormat<span class="operator">,</span> totalSampleCount<span class="operator">,</span> DRWAV_TRUE<span class="operator">,</span> onWrite<span class="operator">,</span> NULL<span class="operator">,</span> pUserData);
 }

 <span class="type">void</span> drwav_close(drwav<span class="operator">*</span> pWav)
 {
     drwav_uninit(pWav);
     DRWAV_FREE(pWav);
 }

 size_t drwav_read_raw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> size_t bytesToRead<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> bytesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pBufferOut <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="keyword">if</span> (bytesToRead <span class="operator">&gt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining) {
         bytesToRead <span class="operator">=</span> (size_t)pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining;
     }

     size_t bytesRead <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> pBufferOut<span class="operator">,</span> bytesToRead);

     pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining <span class="operator">-</span><span class="operator">=</span> bytesRead;
     <span class="keyword">return</span> bytesRead;
 }

 drwav_uint64 drwav_read(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> samplesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pBufferOut <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="comment">// Cannot use this function for compressed formats.</span>
     <span class="keyword">if</span> (drwav__is_compressed_format_tag(pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag)) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="comment">// Don't try to read more samples than can potentially fit in the output buffer.</span>
     <span class="keyword">if</span> (samplesToRead <span class="operator">*</span> bytesPerSample <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         samplesToRead <span class="operator">=</span> DRWAV_SIZE_MAX <span class="operator">/</span> bytesPerSample;
     }

     size_t bytesRead <span class="operator">=</span> drwav_read_raw(pWav<span class="operator">,</span> (size_t)(samplesToRead <span class="operator">*</span> bytesPerSample)<span class="operator">,</span> pBufferOut);
     <span class="keyword">return</span> bytesRead <span class="operator">/</span> bytesPerSample;
 }

 drwav_uint64 drwav_read_pcm_frames(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> framesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pBufferOut <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="comment">// Cannot use this function for compressed formats.</span>
     <span class="keyword">if</span> (drwav__is_compressed_format_tag(pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag)) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint32 bytesPerFrame <span class="operator">=</span> drwav_get_bytes_per_pcm_frame(pWav);
     <span class="keyword">if</span> (bytesPerFrame <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="comment">// Don't try to read more samples than can potentially fit in the output buffer.</span>
     <span class="keyword">if</span> (framesToRead <span class="operator">*</span> bytesPerFrame <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         framesToRead <span class="operator">=</span> DRWAV_SIZE_MAX <span class="operator">/</span> bytesPerFrame;
     }

     size_t bytesRead <span class="operator">=</span> drwav_read_raw(pWav<span class="operator">,</span> (size_t)(framesToRead <span class="operator">*</span> bytesPerFrame)<span class="operator">,</span> pBufferOut);
     <span class="keyword">return</span> bytesRead <span class="operator">/</span> bytesPerFrame;
 }

 drwav_bool32 drwav_seek_to_first_pcm_frame(drwav<span class="operator">*</span> pWav)
 {
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite <span class="operator">!</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// No seeking in write mode.</span>
     }

     <span class="keyword">if</span> (<span class="operator">!</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> (<span class="type">int</span>)pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataPos<span class="operator">,</span> drwav_seek_origin_start)) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="keyword">if</span> (drwav__is_compressed_format_tag(pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag)) {
         pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample <span class="operator">=</span> <span class="number">0</span>;
     }

     pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize;
     <span class="keyword">return</span> DRWAV_TRUE;
 }

 drwav_bool32 drwav_seek_to_sample(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 sample)
 {
     <span class="comment">// Seeking should be compatible with wave files &gt; 2GB.</span>

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite <span class="operator">!</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE; <span class="comment">// No seeking in write mode.</span>
     }

     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> DRWAV_FALSE;
     }

     <span class="comment">// If there are no samples, just return DRWAV_TRUE without doing anything.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> DRWAV_TRUE;
     }

     <span class="comment">// Make sure the sample is clamped.</span>
     <span class="keyword">if</span> (sample <span class="operator">&gt;</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
         sample  <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount <span class="operator">-</span> <span class="number">1</span>;
     }

     <span class="comment">// For compressed formats we just use a slow generic seek. If we are seeking forward we just seek forward. If we are going backwards we need</span>
     <span class="comment">// to seek back to the start.</span>
     <span class="keyword">if</span> (drwav__is_compressed_format_tag(pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag)) {
         <span class="comment">// TODO: This can be optimized.</span>

         <span class="comment">// If we're seeking forward it's simple - just keep reading samples until we hit the sample we're requesting. If we're seeking backwards,</span>
         <span class="comment">// we first need to seek back to the start and then just do the same thing as a forward seek.</span>
         <span class="keyword">if</span> (sample <span class="operator">&lt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample) {
             <span class="keyword">if</span> (<span class="operator">!</span>drwav_seek_to_first_pcm_frame(pWav)) {
                 <span class="keyword">return</span> DRWAV_FALSE;
             }
         }

         <span class="keyword">if</span> (sample <span class="operator">&gt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample) {
             drwav_uint64 offset <span class="operator">=</span> sample <span class="operator">-</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample;

             drwav_int16 devnull<span class="operator">[</span><span class="number">2048</span><span class="operator">]</span>;
             <span class="keyword">while</span> (offset <span class="operator">&gt;</span> <span class="number">0</span>) {
                 drwav_uint64 samplesToRead <span class="operator">=</span> offset;
                 <span class="keyword">if</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">2048</span>) {
                     samplesToRead <span class="operator">=</span> <span class="number">2048</span>;
                 }

                 drwav_uint64 samplesRead <span class="operator">=</span> <span class="number">0</span>;
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM) {
                     samplesRead <span class="operator">=</span> drwav_read_s16__msadpcm(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> devnull);
                 } <span class="keyword">else</span> <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
                     samplesRead <span class="operator">=</span> drwav_read_s16__ima(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> devnull);
                 } <span class="keyword">else</span> {
                     assert(DRWAV_FALSE);    <span class="comment">// If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here.</span>
                 }

                 <span class="keyword">if</span> (samplesRead <span class="operator">!</span><span class="operator">=</span> samplesToRead) {
                     <span class="keyword">return</span> DRWAV_FALSE;
                 }

                 offset <span class="operator">-</span><span class="operator">=</span> samplesRead;
             }
         }
     } <span class="keyword">else</span> {
         drwav_uint64 totalSizeInBytes <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalPCMFrameCount <span class="operator">*</span> drwav_get_bytes_per_pcm_frame(pWav);
         drwav_assert(totalSizeInBytes <span class="operator">&gt;</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining);

         drwav_uint64 currentBytePos <span class="operator">=</span> totalSizeInBytes <span class="operator">-</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining;
         drwav_uint64 targetBytePos  <span class="operator">=</span> sample <span class="operator">*</span> drwav_get_bytes_per_sample(pWav);

         drwav_uint64 offset;
         <span class="keyword">if</span> (currentBytePos <span class="operator">&lt;</span> targetBytePos) {
             <span class="comment">// Offset forwards.</span>
             offset <span class="operator">=</span> (targetBytePos <span class="operator">-</span> currentBytePos);
         } <span class="keyword">else</span> {
             <span class="comment">// Offset backwards.</span>
             <span class="keyword">if</span> (<span class="operator">!</span>drwav_seek_to_first_pcm_frame(pWav)) {
                 <span class="keyword">return</span> DRWAV_FALSE;
             }
             offset <span class="operator">=</span> targetBytePos;
         }

         <span class="keyword">while</span> (offset <span class="operator">&gt;</span> <span class="number">0</span>) {
             <span class="type">int</span> offset32 <span class="operator">=</span> ((offset <span class="operator">&gt;</span> INT_MAX) <span class="operator">?</span> INT_MAX : (<span class="type">int</span>)offset);
             <span class="keyword">if</span> (<span class="operator">!</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>onSeek(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> offset32<span class="operator">,</span> drwav_seek_origin_current)) {
                 <span class="keyword">return</span> DRWAV_FALSE;
             }

             pWav<span class="operator">-</span><span class="operator">&gt;</span>bytesRemaining <span class="operator">-</span><span class="operator">=</span> offset32;
             offset <span class="operator">-</span><span class="operator">=</span> offset32;
         }
     }

     <span class="keyword">return</span> DRWAV_TRUE;
 }

 drwav_bool32 drwav_seek_to_pcm_frame(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 targetFrameIndex)
 {
     <span class="keyword">return</span> drwav_seek_to_sample(pWav<span class="operator">,</span> targetFrameIndex <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels);
 }

 size_t drwav_write_raw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> size_t bytesToWrite<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> bytesToWrite <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pData <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     size_t bytesWritten <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>onWrite(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> pData<span class="operator">,</span> bytesToWrite);
     pWav<span class="operator">-</span><span class="operator">&gt;</span>dataChunkDataSize <span class="operator">+</span><span class="operator">=</span> bytesWritten;

     <span class="keyword">return</span> bytesWritten;
 }

 drwav_uint64 drwav_write(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToWrite<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> samplesToWrite <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pData <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 bytesToWrite <span class="operator">=</span> ((samplesToWrite <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample) <span class="operator">/</span> <span class="number">8</span>);
     <span class="keyword">if</span> (bytesToWrite <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 bytesWritten <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pRunningData <span class="operator">=</span> (<span class="keyword">const</span> drwav_uint8<span class="operator">*</span>)pData;
     <span class="keyword">while</span> (bytesToWrite <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 bytesToWriteThisIteration <span class="operator">=</span> bytesToWrite;
         <span class="keyword">if</span> (bytesToWriteThisIteration <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
             bytesToWriteThisIteration <span class="operator">=</span> DRWAV_SIZE_MAX;
         }

         size_t bytesJustWritten <span class="operator">=</span> drwav_write_raw(pWav<span class="operator">,</span> (size_t)bytesToWriteThisIteration<span class="operator">,</span> pRunningData);
         <span class="keyword">if</span> (bytesJustWritten <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         bytesToWrite <span class="operator">-</span><span class="operator">=</span> bytesJustWritten;
         bytesWritten <span class="operator">+</span><span class="operator">=</span> bytesJustWritten;
         pRunningData <span class="operator">+</span><span class="operator">=</span> bytesJustWritten;
     }

     <span class="keyword">return</span> (bytesWritten <span class="operator">*</span> <span class="number">8</span>) <span class="operator">/</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample;
 }

 drwav_uint64 drwav_write_pcm_frames(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToWrite<span class="operator">,</span> <span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> pData)
 {
     <span class="keyword">return</span> drwav_write(pWav<span class="operator">,</span> framesToWrite <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels<span class="operator">,</span> pData) <span class="operator">/</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
 }

 drwav_uint64 drwav_read_s16__msadpcm(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     drwav_assert(pWav <span class="operator">!</span><span class="operator">=</span> NULL);
     drwav_assert(samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>);
     drwav_assert(pBufferOut <span class="operator">!</span><span class="operator">=</span> NULL);

     <span class="comment">// TODO: Lots of room for optimization here.</span>

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;

     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample <span class="operator">&lt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
         <span class="comment">// If there are no cached samples we need to load a new block.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>) {
                 <span class="comment">// Mono.</span>
                 drwav_uint8 header<span class="operator">[</span><span class="number">7</span><span class="operator">]</span>;
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> header<span class="operator">,</span> <span class="keyword">sizeof</span>(header)) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(header)) {
                     <span class="keyword">return</span> totalSamplesRead;
                 }
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> <span class="keyword">sizeof</span>(header);

                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> header<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">1</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int32)drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">3</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int32)drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">5</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">=</span> <span class="number">2</span>;
             } <span class="keyword">else</span> {
                 <span class="comment">// Stereo.</span>
                 drwav_uint8 header<span class="operator">[</span><span class="number">14</span><span class="operator">]</span>;
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> header<span class="operator">,</span> <span class="keyword">sizeof</span>(header)) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(header)) {
                     <span class="keyword">return</span> totalSamplesRead;
                 }
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> <span class="keyword">sizeof</span>(header);

                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> header<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> header<span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">2</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">4</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int32)drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">6</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int32)drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">8</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int32)drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">10</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int32)drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">12</span>);

                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">=</span> <span class="number">4</span>;
             }
         }

         <span class="comment">// Output anything that's cached.</span>
         <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample <span class="operator">&lt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
             pBufferOut<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int16)pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span>drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples) <span class="operator">-</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount<span class="operator">]</span>;
             pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">-</span><span class="operator">=</span> <span class="number">1</span>;

             pBufferOut <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>;
             samplesToRead <span class="operator">-</span><span class="operator">=</span> <span class="number">1</span>;
             totalSamplesRead <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>;
             pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>;
         }

         <span class="keyword">if</span> (samplesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">return</span> totalSamplesRead;
         }

         <span class="comment">// If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next</span>
         <span class="comment">// loop iteration which will trigger the loading of a new block.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
                 <span class="keyword">continue</span>;
             } <span class="keyword">else</span> {
                 drwav_uint8 nibbles;
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="operator">&amp;</span>nibbles<span class="operator">,</span> <span class="number">1</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">1</span>) {
                     <span class="keyword">return</span> totalSamplesRead;
                 }
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>bytesRemainingInBlock <span class="operator">-</span><span class="operator">=</span> <span class="number">1</span>;

                 <span class="comment">// TODO: Optimize away these if statements.</span>
                 drwav_int32 nibble0 <span class="operator">=</span> ((nibbles <span class="operator">&amp;</span> <span class="number">0xF0</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">4</span>); <span class="keyword">if</span> ((nibbles <span class="operator">&amp;</span> <span class="number">0x80</span>)) { nibble0 <span class="operator">|</span><span class="operator">=</span> <span class="number">0xFFFFFFF0UL</span>; }
                 drwav_int32 nibble1 <span class="operator">=</span> ((nibbles <span class="operator">&amp;</span> <span class="number">0x0F</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">0</span>); <span class="keyword">if</span> ((nibbles <span class="operator">&amp;</span> <span class="number">0x08</span>)) { nibble1 <span class="operator">|</span><span class="operator">=</span> <span class="number">0xFFFFFFF0UL</span>; }

                 <span class="keyword">static</span> drwav_int32 adaptationTable<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
                     <span class="number">230</span><span class="operator">,</span> <span class="number">230</span><span class="operator">,</span> <span class="number">230</span><span class="operator">,</span> <span class="number">230</span><span class="operator">,</span> <span class="number">307</span><span class="operator">,</span> <span class="number">409</span><span class="operator">,</span> <span class="number">512</span><span class="operator">,</span> <span class="number">614</span><span class="operator">,</span>
                     <span class="number">768</span><span class="operator">,</span> <span class="number">614</span><span class="operator">,</span> <span class="number">512</span><span class="operator">,</span> <span class="number">409</span><span class="operator">,</span> <span class="number">307</span><span class="operator">,</span> <span class="number">230</span><span class="operator">,</span> <span class="number">230</span><span class="operator">,</span> <span class="number">230</span>
                 };
                 <span class="keyword">static</span> drwav_int32 coeff1Table<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> { <span class="number">256</span><span class="operator">,</span> <span class="number">512</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">192</span><span class="operator">,</span> <span class="number">240</span><span class="operator">,</span> <span class="number">460</span><span class="operator">,</span>  <span class="number">392</span> };
                 <span class="keyword">static</span> drwav_int32 coeff2Table<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> { <span class="number">0</span><span class="operator">,</span>  <span class="operator">-</span><span class="number">256</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">64</span><span class="operator">,</span>  <span class="number">0</span><span class="operator">,</span>  <span class="operator">-</span><span class="number">208</span><span class="operator">,</span> <span class="operator">-</span><span class="number">232</span> };

                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>) {
                     <span class="comment">// Mono.</span>
                     drwav_int32 newSample0;
                     newSample0  <span class="operator">=</span> ((pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">*</span> coeff1Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">]</span>) <span class="operator">+</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">*</span> coeff2Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">]</span>)) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     newSample0 <span class="operator">+</span><span class="operator">=</span> nibble0 <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                     newSample0  <span class="operator">=</span> drwav_clamp(newSample0<span class="operator">,</span> <span class="operator">-</span><span class="number">32768</span><span class="operator">,</span> <span class="number">32767</span>);

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (adaptationTable<span class="operator">[</span>((nibbles <span class="operator">&amp;</span> <span class="number">0xF0</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">4</span>)<span class="operator">]</span> <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&lt;</span> <span class="number">16</span>) {
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">16</span>;
                     }

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> newSample0;

                     drwav_int32 newSample1;
                     newSample1  <span class="operator">=</span> ((pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">*</span> coeff1Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">]</span>) <span class="operator">+</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">*</span> coeff2Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">]</span>)) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     newSample1 <span class="operator">+</span><span class="operator">=</span> nibble1 <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                     newSample1  <span class="operator">=</span> drwav_clamp(newSample1<span class="operator">,</span> <span class="operator">-</span><span class="number">32768</span><span class="operator">,</span> <span class="number">32767</span>);

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (adaptationTable<span class="operator">[</span>((nibbles <span class="operator">&amp;</span> <span class="number">0x0F</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">0</span>)<span class="operator">]</span> <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&lt;</span> <span class="number">16</span>) {
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">16</span>;
                     }

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> newSample1;

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> newSample0;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> newSample1;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">=</span> <span class="number">2</span>;
                 } <span class="keyword">else</span> {
                     <span class="comment">// Stereo.</span>

                     <span class="comment">// Left.</span>
                     drwav_int32 newSample0;
                     newSample0  <span class="operator">=</span> ((pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">*</span> coeff1Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">]</span>) <span class="operator">+</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">*</span> coeff2Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">]</span>)) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     newSample0 <span class="operator">+</span><span class="operator">=</span> nibble0 <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                     newSample0  <span class="operator">=</span> drwav_clamp(newSample0<span class="operator">,</span> <span class="operator">-</span><span class="number">32768</span><span class="operator">,</span> <span class="number">32767</span>);

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (adaptationTable<span class="operator">[</span>((nibbles <span class="operator">&amp;</span> <span class="number">0xF0</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">4</span>)<span class="operator">]</span> <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">&lt;</span> <span class="number">16</span>) {
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">16</span>;
                     }

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> newSample0;

                     <span class="comment">// Right.</span>
                     drwav_int32 newSample1;
                     newSample1  <span class="operator">=</span> ((pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">*</span> coeff1Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">]</span>) <span class="operator">+</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">*</span> coeff2Table<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">]</span>)) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     newSample1 <span class="operator">+</span><span class="operator">=</span> nibble1 <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                     newSample1  <span class="operator">=</span> drwav_clamp(newSample1<span class="operator">,</span> <span class="operator">-</span><span class="number">32768</span><span class="operator">,</span> <span class="number">32767</span>);

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> (adaptationTable<span class="operator">[</span>((nibbles <span class="operator">&amp;</span> <span class="number">0x0F</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">0</span>)<span class="operator">]</span> <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">1</span><span class="operator">]</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
                     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&lt;</span> <span class="number">16</span>) {
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>delta<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">16</span>;
                     }

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>prevSamples<span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> newSample1;

                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> newSample0;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSamples<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> newSample1;
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>msadpcm<span class="operator">.</span>cachedSampleCount <span class="operator">=</span> <span class="number">2</span>;
                 }
             }
         }
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s16__ima(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     drwav_assert(pWav <span class="operator">!</span><span class="operator">=</span> NULL);
     drwav_assert(samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>);
     drwav_assert(pBufferOut <span class="operator">!</span><span class="operator">=</span> NULL);

     <span class="comment">// TODO: Lots of room for optimization here.</span>

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;

     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample <span class="operator">&lt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
         <span class="comment">// If there are no cached samples we need to load a new block.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>) {
                 <span class="comment">// Mono.</span>
                 drwav_uint8 header<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> header<span class="operator">,</span> <span class="keyword">sizeof</span>(header)) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(header)) {
                     <span class="keyword">return</span> totalSamplesRead;
                 }
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> <span class="keyword">sizeof</span>(header);

                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">0</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> header<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples<span class="operator">[</span>drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples) <span class="operator">-</span> <span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount <span class="operator">=</span> <span class="number">1</span>;
             } <span class="keyword">else</span> {
                 <span class="comment">// Stereo.</span>
                 drwav_uint8 header<span class="operator">[</span><span class="number">8</span><span class="operator">]</span>;
                 <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> header<span class="operator">,</span> <span class="keyword">sizeof</span>(header)) <span class="operator">!</span><span class="operator">=</span> <span class="keyword">sizeof</span>(header)) {
                     <span class="keyword">return</span> totalSamplesRead;
                 }
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>fmt<span class="operator">.</span>blockAlign <span class="operator">-</span> <span class="keyword">sizeof</span>(header);

                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">0</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> header<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> drwav__bytes_to_s16(header <span class="operator">+</span> <span class="number">4</span>);
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> header<span class="operator">[</span><span class="number">6</span><span class="operator">]</span>;

                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples<span class="operator">[</span>drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples) <span class="operator">-</span> <span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples<span class="operator">[</span>drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples) <span class="operator">-</span> <span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span><span class="number">1</span><span class="operator">]</span>;
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount <span class="operator">=</span> <span class="number">2</span>;
             }
         }

         <span class="comment">// Output anything that's cached.</span>
         <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample <span class="operator">&lt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
             pBufferOut<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> (drwav_int16)pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples<span class="operator">[</span>drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples) <span class="operator">-</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount<span class="operator">]</span>;
             pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount <span class="operator">-</span><span class="operator">=</span> <span class="number">1</span>;

             pBufferOut <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>;
             samplesToRead <span class="operator">-</span><span class="operator">=</span> <span class="number">1</span>;
             totalSamplesRead <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>;
             pWav<span class="operator">-</span><span class="operator">&gt;</span>compressed<span class="operator">.</span>iCurrentSample <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>;
         }

         <span class="keyword">if</span> (samplesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">return</span> totalSamplesRead;
         }

         <span class="comment">// If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next</span>
         <span class="comment">// loop iteration which will trigger the loading of a new block.</span>
         <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>bytesRemainingInBlock <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
                 <span class="keyword">continue</span>;
             } <span class="keyword">else</span> {
                 <span class="keyword">static</span> drwav_int32 indexTable<span class="operator">[</span><span class="number">16</span><span class="operator">]</span> <span class="operator">=</span> {
                     <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span>
                     <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> <span class="number">8</span>
                 };

                 <span class="keyword">static</span> drwav_int32 stepTable<span class="operator">[</span><span class="number">89</span><span class="operator">]</span> <span class="operator">=</span> {
                     <span class="number">7</span><span class="operator">,</span>     <span class="number">8</span><span class="operator">,</span>     <span class="number">9</span><span class="operator">,</span>     <span class="number">10</span><span class="operator">,</span>    <span class="number">11</span><span class="operator">,</span>    <span class="number">12</span><span class="operator">,</span>    <span class="number">13</span><span class="operator">,</span>    <span class="number">14</span><span class="operator">,</span>    <span class="number">16</span><span class="operator">,</span>    <span class="number">17</span><span class="operator">,</span>
                     <span class="number">19</span><span class="operator">,</span>    <span class="number">21</span><span class="operator">,</span>    <span class="number">23</span><span class="operator">,</span>    <span class="number">25</span><span class="operator">,</span>    <span class="number">28</span><span class="operator">,</span>    <span class="number">31</span><span class="operator">,</span>    <span class="number">34</span><span class="operator">,</span>    <span class="number">37</span><span class="operator">,</span>    <span class="number">41</span><span class="operator">,</span>    <span class="number">45</span><span class="operator">,</span>
                     <span class="number">50</span><span class="operator">,</span>    <span class="number">55</span><span class="operator">,</span>    <span class="number">60</span><span class="operator">,</span>    <span class="number">66</span><span class="operator">,</span>    <span class="number">73</span><span class="operator">,</span>    <span class="number">80</span><span class="operator">,</span>    <span class="number">88</span><span class="operator">,</span>    <span class="number">97</span><span class="operator">,</span>    <span class="number">107</span><span class="operator">,</span>   <span class="number">118</span><span class="operator">,</span>
                     <span class="number">130</span><span class="operator">,</span>   <span class="number">143</span><span class="operator">,</span>   <span class="number">157</span><span class="operator">,</span>   <span class="number">173</span><span class="operator">,</span>   <span class="number">190</span><span class="operator">,</span>   <span class="number">209</span><span class="operator">,</span>   <span class="number">230</span><span class="operator">,</span>   <span class="number">253</span><span class="operator">,</span>   <span class="number">279</span><span class="operator">,</span>   <span class="number">307</span><span class="operator">,</span>
                     <span class="number">337</span><span class="operator">,</span>   <span class="number">371</span><span class="operator">,</span>   <span class="number">408</span><span class="operator">,</span>   <span class="number">449</span><span class="operator">,</span>   <span class="number">494</span><span class="operator">,</span>   <span class="number">544</span><span class="operator">,</span>   <span class="number">598</span><span class="operator">,</span>   <span class="number">658</span><span class="operator">,</span>   <span class="number">724</span><span class="operator">,</span>   <span class="number">796</span><span class="operator">,</span>
                     <span class="number">876</span><span class="operator">,</span>   <span class="number">963</span><span class="operator">,</span>   <span class="number">1060</span><span class="operator">,</span>  <span class="number">1166</span><span class="operator">,</span>  <span class="number">1282</span><span class="operator">,</span>  <span class="number">1411</span><span class="operator">,</span>  <span class="number">1552</span><span class="operator">,</span>  <span class="number">1707</span><span class="operator">,</span>  <span class="number">1878</span><span class="operator">,</span>  <span class="number">2066</span><span class="operator">,</span>
                     <span class="number">2272</span><span class="operator">,</span>  <span class="number">2499</span><span class="operator">,</span>  <span class="number">2749</span><span class="operator">,</span>  <span class="number">3024</span><span class="operator">,</span>  <span class="number">3327</span><span class="operator">,</span>  <span class="number">3660</span><span class="operator">,</span>  <span class="number">4026</span><span class="operator">,</span>  <span class="number">4428</span><span class="operator">,</span>  <span class="number">4871</span><span class="operator">,</span>  <span class="number">5358</span><span class="operator">,</span>
                     <span class="number">5894</span><span class="operator">,</span>  <span class="number">6484</span><span class="operator">,</span>  <span class="number">7132</span><span class="operator">,</span>  <span class="number">7845</span><span class="operator">,</span>  <span class="number">8630</span><span class="operator">,</span>  <span class="number">9493</span><span class="operator">,</span>  <span class="number">10442</span><span class="operator">,</span> <span class="number">11487</span><span class="operator">,</span> <span class="number">12635</span><span class="operator">,</span> <span class="number">13899</span><span class="operator">,</span>
                     <span class="number">15289</span><span class="operator">,</span> <span class="number">16818</span><span class="operator">,</span> <span class="number">18500</span><span class="operator">,</span> <span class="number">20350</span><span class="operator">,</span> <span class="number">22385</span><span class="operator">,</span> <span class="number">24623</span><span class="operator">,</span> <span class="number">27086</span><span class="operator">,</span> <span class="number">29794</span><span class="operator">,</span> <span class="number">32767</span>
                 };

                 <span class="comment">// From what I can tell with stereo streams, it looks like every 4 bytes (8 samples) is for one channel. So it goes 4 bytes for the</span>
                 <span class="comment">// left channel, 4 bytes for the right channel.</span>
                 pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount <span class="operator">=</span> <span class="number">8</span> <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
                 <span class="keyword">for</span> (drwav_uint32 iChannel <span class="operator">=</span> <span class="number">0</span>; iChannel <span class="operator">&lt;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels; <span class="operator">+</span><span class="operator">+</span>iChannel) {
                     drwav_uint8 nibbles<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;
                     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>onRead(pWav<span class="operator">-</span><span class="operator">&gt;</span>pUserData<span class="operator">,</span> <span class="operator">&amp;</span>nibbles<span class="operator">,</span> <span class="number">4</span>) <span class="operator">!</span><span class="operator">=</span> <span class="number">4</span>) {
                         <span class="keyword">return</span> totalSamplesRead;
                     }
                     pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>bytesRemainingInBlock <span class="operator">-</span><span class="operator">=</span> <span class="number">4</span>;

                     <span class="keyword">for</span> (drwav_uint32 iByte <span class="operator">=</span> <span class="number">0</span>; iByte <span class="operator">&lt;</span> <span class="number">4</span>; <span class="operator">+</span><span class="operator">+</span>iByte) {
                         drwav_uint8 nibble0 <span class="operator">=</span> ((nibbles<span class="operator">[</span>iByte<span class="operator">]</span> <span class="operator">&amp;</span> <span class="number">0x0F</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">0</span>);
                         drwav_uint8 nibble1 <span class="operator">=</span> ((nibbles<span class="operator">[</span>iByte<span class="operator">]</span> <span class="operator">&amp;</span> <span class="number">0xF0</span>) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">4</span>);

                         drwav_int32 step      <span class="operator">=</span> stepTable<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span>iChannel<span class="operator">]</span><span class="operator">]</span>;
                         drwav_int32 predictor <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span>iChannel<span class="operator">]</span>;

                         drwav_int32      diff  <span class="operator">=</span> step <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">3</span>;
                         <span class="keyword">if</span> (nibble0 <span class="operator">&amp;</span> <span class="number">1</span>) diff <span class="operator">+</span><span class="operator">=</span> step <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">2</span>;
                         <span class="keyword">if</span> (nibble0 <span class="operator">&amp;</span> <span class="number">2</span>) diff <span class="operator">+</span><span class="operator">=</span> step <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">1</span>;
                         <span class="keyword">if</span> (nibble0 <span class="operator">&amp;</span> <span class="number">4</span>) diff <span class="operator">+</span><span class="operator">=</span> step;
                         <span class="keyword">if</span> (nibble0 <span class="operator">&amp;</span> <span class="number">8</span>) diff  <span class="operator">=</span> <span class="operator">-</span>diff;

                         predictor <span class="operator">=</span> drwav_clamp(predictor <span class="operator">+</span> diff<span class="operator">,</span> <span class="operator">-</span><span class="number">32768</span><span class="operator">,</span> <span class="number">32767</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span>iChannel<span class="operator">]</span> <span class="operator">=</span> predictor;
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span>iChannel<span class="operator">]</span> <span class="operator">=</span> drwav_clamp(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span>iChannel<span class="operator">]</span> <span class="operator">+</span> indexTable<span class="operator">[</span>nibble0<span class="operator">]</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> (drwav_int32)drwav_countof(stepTable)<span class="operator">-</span><span class="number">1</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples<span class="operator">[</span>(drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples) <span class="operator">-</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount) <span class="operator">+</span> (iByte<span class="operator">*</span><span class="number">2</span><span class="operator">+</span><span class="number">0</span>)<span class="operator">*</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">+</span> iChannel<span class="operator">]</span> <span class="operator">=</span> predictor;

                         step      <span class="operator">=</span> stepTable<span class="operator">[</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span>iChannel<span class="operator">]</span><span class="operator">]</span>;
                         predictor <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span>iChannel<span class="operator">]</span>;

                                          diff  <span class="operator">=</span> step <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">3</span>;
                         <span class="keyword">if</span> (nibble1 <span class="operator">&amp;</span> <span class="number">1</span>) diff <span class="operator">+</span><span class="operator">=</span> step <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">2</span>;
                         <span class="keyword">if</span> (nibble1 <span class="operator">&amp;</span> <span class="number">2</span>) diff <span class="operator">+</span><span class="operator">=</span> step <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">1</span>;
                         <span class="keyword">if</span> (nibble1 <span class="operator">&amp;</span> <span class="number">4</span>) diff <span class="operator">+</span><span class="operator">=</span> step;
                         <span class="keyword">if</span> (nibble1 <span class="operator">&amp;</span> <span class="number">8</span>) diff  <span class="operator">=</span> <span class="operator">-</span>diff;

                         predictor <span class="operator">=</span> drwav_clamp(predictor <span class="operator">+</span> diff<span class="operator">,</span> <span class="operator">-</span><span class="number">32768</span><span class="operator">,</span> <span class="number">32767</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>predictor<span class="operator">[</span>iChannel<span class="operator">]</span> <span class="operator">=</span> predictor;
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span>iChannel<span class="operator">]</span> <span class="operator">=</span> drwav_clamp(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>stepIndex<span class="operator">[</span>iChannel<span class="operator">]</span> <span class="operator">+</span> indexTable<span class="operator">[</span>nibble1<span class="operator">]</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> (drwav_int32)drwav_countof(stepTable)<span class="operator">-</span><span class="number">1</span>);
                         pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples<span class="operator">[</span>(drwav_countof(pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSamples) <span class="operator">-</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>ima<span class="operator">.</span>cachedSampleCount) <span class="operator">+</span> (iByte<span class="operator">*</span><span class="number">2</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>pWav<span class="operator">-</span><span class="operator">&gt;</span>channels <span class="operator">+</span> iChannel<span class="operator">]</span> <span class="operator">=</span> predictor;
                     }
                 }
             }
         }
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 <span class="preprocessor">#ifndef DR_WAV_NO_CONVERSION_API</span>
 <span class="keyword">static</span> <span class="type">unsigned</span> <span class="type">short</span> g_drwavAlawTable<span class="operator">[</span><span class="number">256</span><span class="operator">]</span> <span class="operator">=</span> {
     <span class="number">0xEA80</span><span class="operator">,</span> <span class="number">0xEB80</span><span class="operator">,</span> <span class="number">0xE880</span><span class="operator">,</span> <span class="number">0xE980</span><span class="operator">,</span> <span class="number">0xEE80</span><span class="operator">,</span> <span class="number">0xEF80</span><span class="operator">,</span> <span class="number">0xEC80</span><span class="operator">,</span> <span class="number">0xED80</span><span class="operator">,</span> <span class="number">0xE280</span><span class="operator">,</span> <span class="number">0xE380</span><span class="operator">,</span> <span class="number">0xE080</span><span class="operator">,</span> <span class="number">0xE180</span><span class="operator">,</span> <span class="number">0xE680</span><span class="operator">,</span> <span class="number">0xE780</span><span class="operator">,</span> <span class="number">0xE480</span><span class="operator">,</span> <span class="number">0xE580</span><span class="operator">,</span>
     <span class="number">0xF540</span><span class="operator">,</span> <span class="number">0xF5C0</span><span class="operator">,</span> <span class="number">0xF440</span><span class="operator">,</span> <span class="number">0xF4C0</span><span class="operator">,</span> <span class="number">0xF740</span><span class="operator">,</span> <span class="number">0xF7C0</span><span class="operator">,</span> <span class="number">0xF640</span><span class="operator">,</span> <span class="number">0xF6C0</span><span class="operator">,</span> <span class="number">0xF140</span><span class="operator">,</span> <span class="number">0xF1C0</span><span class="operator">,</span> <span class="number">0xF040</span><span class="operator">,</span> <span class="number">0xF0C0</span><span class="operator">,</span> <span class="number">0xF340</span><span class="operator">,</span> <span class="number">0xF3C0</span><span class="operator">,</span> <span class="number">0xF240</span><span class="operator">,</span> <span class="number">0xF2C0</span><span class="operator">,</span>
     <span class="number">0xAA00</span><span class="operator">,</span> <span class="number">0xAE00</span><span class="operator">,</span> <span class="number">0xA200</span><span class="operator">,</span> <span class="number">0xA600</span><span class="operator">,</span> <span class="number">0xBA00</span><span class="operator">,</span> <span class="number">0xBE00</span><span class="operator">,</span> <span class="number">0xB200</span><span class="operator">,</span> <span class="number">0xB600</span><span class="operator">,</span> <span class="number">0x8A00</span><span class="operator">,</span> <span class="number">0x8E00</span><span class="operator">,</span> <span class="number">0x8200</span><span class="operator">,</span> <span class="number">0x8600</span><span class="operator">,</span> <span class="number">0x9A00</span><span class="operator">,</span> <span class="number">0x9E00</span><span class="operator">,</span> <span class="number">0x9200</span><span class="operator">,</span> <span class="number">0x9600</span><span class="operator">,</span>
     <span class="number">0xD500</span><span class="operator">,</span> <span class="number">0xD700</span><span class="operator">,</span> <span class="number">0xD100</span><span class="operator">,</span> <span class="number">0xD300</span><span class="operator">,</span> <span class="number">0xDD00</span><span class="operator">,</span> <span class="number">0xDF00</span><span class="operator">,</span> <span class="number">0xD900</span><span class="operator">,</span> <span class="number">0xDB00</span><span class="operator">,</span> <span class="number">0xC500</span><span class="operator">,</span> <span class="number">0xC700</span><span class="operator">,</span> <span class="number">0xC100</span><span class="operator">,</span> <span class="number">0xC300</span><span class="operator">,</span> <span class="number">0xCD00</span><span class="operator">,</span> <span class="number">0xCF00</span><span class="operator">,</span> <span class="number">0xC900</span><span class="operator">,</span> <span class="number">0xCB00</span><span class="operator">,</span>
     <span class="number">0xFEA8</span><span class="operator">,</span> <span class="number">0xFEB8</span><span class="operator">,</span> <span class="number">0xFE88</span><span class="operator">,</span> <span class="number">0xFE98</span><span class="operator">,</span> <span class="number">0xFEE8</span><span class="operator">,</span> <span class="number">0xFEF8</span><span class="operator">,</span> <span class="number">0xFEC8</span><span class="operator">,</span> <span class="number">0xFED8</span><span class="operator">,</span> <span class="number">0xFE28</span><span class="operator">,</span> <span class="number">0xFE38</span><span class="operator">,</span> <span class="number">0xFE08</span><span class="operator">,</span> <span class="number">0xFE18</span><span class="operator">,</span> <span class="number">0xFE68</span><span class="operator">,</span> <span class="number">0xFE78</span><span class="operator">,</span> <span class="number">0xFE48</span><span class="operator">,</span> <span class="number">0xFE58</span><span class="operator">,</span>
     <span class="number">0xFFA8</span><span class="operator">,</span> <span class="number">0xFFB8</span><span class="operator">,</span> <span class="number">0xFF88</span><span class="operator">,</span> <span class="number">0xFF98</span><span class="operator">,</span> <span class="number">0xFFE8</span><span class="operator">,</span> <span class="number">0xFFF8</span><span class="operator">,</span> <span class="number">0xFFC8</span><span class="operator">,</span> <span class="number">0xFFD8</span><span class="operator">,</span> <span class="number">0xFF28</span><span class="operator">,</span> <span class="number">0xFF38</span><span class="operator">,</span> <span class="number">0xFF08</span><span class="operator">,</span> <span class="number">0xFF18</span><span class="operator">,</span> <span class="number">0xFF68</span><span class="operator">,</span> <span class="number">0xFF78</span><span class="operator">,</span> <span class="number">0xFF48</span><span class="operator">,</span> <span class="number">0xFF58</span><span class="operator">,</span>
     <span class="number">0xFAA0</span><span class="operator">,</span> <span class="number">0xFAE0</span><span class="operator">,</span> <span class="number">0xFA20</span><span class="operator">,</span> <span class="number">0xFA60</span><span class="operator">,</span> <span class="number">0xFBA0</span><span class="operator">,</span> <span class="number">0xFBE0</span><span class="operator">,</span> <span class="number">0xFB20</span><span class="operator">,</span> <span class="number">0xFB60</span><span class="operator">,</span> <span class="number">0xF8A0</span><span class="operator">,</span> <span class="number">0xF8E0</span><span class="operator">,</span> <span class="number">0xF820</span><span class="operator">,</span> <span class="number">0xF860</span><span class="operator">,</span> <span class="number">0xF9A0</span><span class="operator">,</span> <span class="number">0xF9E0</span><span class="operator">,</span> <span class="number">0xF920</span><span class="operator">,</span> <span class="number">0xF960</span><span class="operator">,</span>
     <span class="number">0xFD50</span><span class="operator">,</span> <span class="number">0xFD70</span><span class="operator">,</span> <span class="number">0xFD10</span><span class="operator">,</span> <span class="number">0xFD30</span><span class="operator">,</span> <span class="number">0xFDD0</span><span class="operator">,</span> <span class="number">0xFDF0</span><span class="operator">,</span> <span class="number">0xFD90</span><span class="operator">,</span> <span class="number">0xFDB0</span><span class="operator">,</span> <span class="number">0xFC50</span><span class="operator">,</span> <span class="number">0xFC70</span><span class="operator">,</span> <span class="number">0xFC10</span><span class="operator">,</span> <span class="number">0xFC30</span><span class="operator">,</span> <span class="number">0xFCD0</span><span class="operator">,</span> <span class="number">0xFCF0</span><span class="operator">,</span> <span class="number">0xFC90</span><span class="operator">,</span> <span class="number">0xFCB0</span><span class="operator">,</span>
     <span class="number">0x1580</span><span class="operator">,</span> <span class="number">0x1480</span><span class="operator">,</span> <span class="number">0x1780</span><span class="operator">,</span> <span class="number">0x1680</span><span class="operator">,</span> <span class="number">0x1180</span><span class="operator">,</span> <span class="number">0x1080</span><span class="operator">,</span> <span class="number">0x1380</span><span class="operator">,</span> <span class="number">0x1280</span><span class="operator">,</span> <span class="number">0x1D80</span><span class="operator">,</span> <span class="number">0x1C80</span><span class="operator">,</span> <span class="number">0x1F80</span><span class="operator">,</span> <span class="number">0x1E80</span><span class="operator">,</span> <span class="number">0x1980</span><span class="operator">,</span> <span class="number">0x1880</span><span class="operator">,</span> <span class="number">0x1B80</span><span class="operator">,</span> <span class="number">0x1A80</span><span class="operator">,</span>
     <span class="number">0x0AC0</span><span class="operator">,</span> <span class="number">0x0A40</span><span class="operator">,</span> <span class="number">0x0BC0</span><span class="operator">,</span> <span class="number">0x0B40</span><span class="operator">,</span> <span class="number">0x08C0</span><span class="operator">,</span> <span class="number">0x0840</span><span class="operator">,</span> <span class="number">0x09C0</span><span class="operator">,</span> <span class="number">0x0940</span><span class="operator">,</span> <span class="number">0x0EC0</span><span class="operator">,</span> <span class="number">0x0E40</span><span class="operator">,</span> <span class="number">0x0FC0</span><span class="operator">,</span> <span class="number">0x0F40</span><span class="operator">,</span> <span class="number">0x0CC0</span><span class="operator">,</span> <span class="number">0x0C40</span><span class="operator">,</span> <span class="number">0x0DC0</span><span class="operator">,</span> <span class="number">0x0D40</span><span class="operator">,</span>
     <span class="number">0x5600</span><span class="operator">,</span> <span class="number">0x5200</span><span class="operator">,</span> <span class="number">0x5E00</span><span class="operator">,</span> <span class="number">0x5A00</span><span class="operator">,</span> <span class="number">0x4600</span><span class="operator">,</span> <span class="number">0x4200</span><span class="operator">,</span> <span class="number">0x4E00</span><span class="operator">,</span> <span class="number">0x4A00</span><span class="operator">,</span> <span class="number">0x7600</span><span class="operator">,</span> <span class="number">0x7200</span><span class="operator">,</span> <span class="number">0x7E00</span><span class="operator">,</span> <span class="number">0x7A00</span><span class="operator">,</span> <span class="number">0x6600</span><span class="operator">,</span> <span class="number">0x6200</span><span class="operator">,</span> <span class="number">0x6E00</span><span class="operator">,</span> <span class="number">0x6A00</span><span class="operator">,</span>
     <span class="number">0x2B00</span><span class="operator">,</span> <span class="number">0x2900</span><span class="operator">,</span> <span class="number">0x2F00</span><span class="operator">,</span> <span class="number">0x2D00</span><span class="operator">,</span> <span class="number">0x2300</span><span class="operator">,</span> <span class="number">0x2100</span><span class="operator">,</span> <span class="number">0x2700</span><span class="operator">,</span> <span class="number">0x2500</span><span class="operator">,</span> <span class="number">0x3B00</span><span class="operator">,</span> <span class="number">0x3900</span><span class="operator">,</span> <span class="number">0x3F00</span><span class="operator">,</span> <span class="number">0x3D00</span><span class="operator">,</span> <span class="number">0x3300</span><span class="operator">,</span> <span class="number">0x3100</span><span class="operator">,</span> <span class="number">0x3700</span><span class="operator">,</span> <span class="number">0x3500</span><span class="operator">,</span>
     <span class="number">0x0158</span><span class="operator">,</span> <span class="number">0x0148</span><span class="operator">,</span> <span class="number">0x0178</span><span class="operator">,</span> <span class="number">0x0168</span><span class="operator">,</span> <span class="number">0x0118</span><span class="operator">,</span> <span class="number">0x0108</span><span class="operator">,</span> <span class="number">0x0138</span><span class="operator">,</span> <span class="number">0x0128</span><span class="operator">,</span> <span class="number">0x01D8</span><span class="operator">,</span> <span class="number">0x01C8</span><span class="operator">,</span> <span class="number">0x01F8</span><span class="operator">,</span> <span class="number">0x01E8</span><span class="operator">,</span> <span class="number">0x0198</span><span class="operator">,</span> <span class="number">0x0188</span><span class="operator">,</span> <span class="number">0x01B8</span><span class="operator">,</span> <span class="number">0x01A8</span><span class="operator">,</span>
     <span class="number">0x0058</span><span class="operator">,</span> <span class="number">0x0048</span><span class="operator">,</span> <span class="number">0x0078</span><span class="operator">,</span> <span class="number">0x0068</span><span class="operator">,</span> <span class="number">0x0018</span><span class="operator">,</span> <span class="number">0x0008</span><span class="operator">,</span> <span class="number">0x0038</span><span class="operator">,</span> <span class="number">0x0028</span><span class="operator">,</span> <span class="number">0x00D8</span><span class="operator">,</span> <span class="number">0x00C8</span><span class="operator">,</span> <span class="number">0x00F8</span><span class="operator">,</span> <span class="number">0x00E8</span><span class="operator">,</span> <span class="number">0x0098</span><span class="operator">,</span> <span class="number">0x0088</span><span class="operator">,</span> <span class="number">0x00B8</span><span class="operator">,</span> <span class="number">0x00A8</span><span class="operator">,</span>
     <span class="number">0x0560</span><span class="operator">,</span> <span class="number">0x0520</span><span class="operator">,</span> <span class="number">0x05E0</span><span class="operator">,</span> <span class="number">0x05A0</span><span class="operator">,</span> <span class="number">0x0460</span><span class="operator">,</span> <span class="number">0x0420</span><span class="operator">,</span> <span class="number">0x04E0</span><span class="operator">,</span> <span class="number">0x04A0</span><span class="operator">,</span> <span class="number">0x0760</span><span class="operator">,</span> <span class="number">0x0720</span><span class="operator">,</span> <span class="number">0x07E0</span><span class="operator">,</span> <span class="number">0x07A0</span><span class="operator">,</span> <span class="number">0x0660</span><span class="operator">,</span> <span class="number">0x0620</span><span class="operator">,</span> <span class="number">0x06E0</span><span class="operator">,</span> <span class="number">0x06A0</span><span class="operator">,</span>
     <span class="number">0x02B0</span><span class="operator">,</span> <span class="number">0x0290</span><span class="operator">,</span> <span class="number">0x02F0</span><span class="operator">,</span> <span class="number">0x02D0</span><span class="operator">,</span> <span class="number">0x0230</span><span class="operator">,</span> <span class="number">0x0210</span><span class="operator">,</span> <span class="number">0x0270</span><span class="operator">,</span> <span class="number">0x0250</span><span class="operator">,</span> <span class="number">0x03B0</span><span class="operator">,</span> <span class="number">0x0390</span><span class="operator">,</span> <span class="number">0x03F0</span><span class="operator">,</span> <span class="number">0x03D0</span><span class="operator">,</span> <span class="number">0x0330</span><span class="operator">,</span> <span class="number">0x0310</span><span class="operator">,</span> <span class="number">0x0370</span><span class="operator">,</span> <span class="number">0x0350</span>
 };

 <span class="keyword">static</span> <span class="type">unsigned</span> <span class="type">short</span> g_drwavMulawTable<span class="operator">[</span><span class="number">256</span><span class="operator">]</span> <span class="operator">=</span> {
     <span class="number">0x8284</span><span class="operator">,</span> <span class="number">0x8684</span><span class="operator">,</span> <span class="number">0x8A84</span><span class="operator">,</span> <span class="number">0x8E84</span><span class="operator">,</span> <span class="number">0x9284</span><span class="operator">,</span> <span class="number">0x9684</span><span class="operator">,</span> <span class="number">0x9A84</span><span class="operator">,</span> <span class="number">0x9E84</span><span class="operator">,</span> <span class="number">0xA284</span><span class="operator">,</span> <span class="number">0xA684</span><span class="operator">,</span> <span class="number">0xAA84</span><span class="operator">,</span> <span class="number">0xAE84</span><span class="operator">,</span> <span class="number">0xB284</span><span class="operator">,</span> <span class="number">0xB684</span><span class="operator">,</span> <span class="number">0xBA84</span><span class="operator">,</span> <span class="number">0xBE84</span><span class="operator">,</span>
     <span class="number">0xC184</span><span class="operator">,</span> <span class="number">0xC384</span><span class="operator">,</span> <span class="number">0xC584</span><span class="operator">,</span> <span class="number">0xC784</span><span class="operator">,</span> <span class="number">0xC984</span><span class="operator">,</span> <span class="number">0xCB84</span><span class="operator">,</span> <span class="number">0xCD84</span><span class="operator">,</span> <span class="number">0xCF84</span><span class="operator">,</span> <span class="number">0xD184</span><span class="operator">,</span> <span class="number">0xD384</span><span class="operator">,</span> <span class="number">0xD584</span><span class="operator">,</span> <span class="number">0xD784</span><span class="operator">,</span> <span class="number">0xD984</span><span class="operator">,</span> <span class="number">0xDB84</span><span class="operator">,</span> <span class="number">0xDD84</span><span class="operator">,</span> <span class="number">0xDF84</span><span class="operator">,</span>
     <span class="number">0xE104</span><span class="operator">,</span> <span class="number">0xE204</span><span class="operator">,</span> <span class="number">0xE304</span><span class="operator">,</span> <span class="number">0xE404</span><span class="operator">,</span> <span class="number">0xE504</span><span class="operator">,</span> <span class="number">0xE604</span><span class="operator">,</span> <span class="number">0xE704</span><span class="operator">,</span> <span class="number">0xE804</span><span class="operator">,</span> <span class="number">0xE904</span><span class="operator">,</span> <span class="number">0xEA04</span><span class="operator">,</span> <span class="number">0xEB04</span><span class="operator">,</span> <span class="number">0xEC04</span><span class="operator">,</span> <span class="number">0xED04</span><span class="operator">,</span> <span class="number">0xEE04</span><span class="operator">,</span> <span class="number">0xEF04</span><span class="operator">,</span> <span class="number">0xF004</span><span class="operator">,</span>
     <span class="number">0xF0C4</span><span class="operator">,</span> <span class="number">0xF144</span><span class="operator">,</span> <span class="number">0xF1C4</span><span class="operator">,</span> <span class="number">0xF244</span><span class="operator">,</span> <span class="number">0xF2C4</span><span class="operator">,</span> <span class="number">0xF344</span><span class="operator">,</span> <span class="number">0xF3C4</span><span class="operator">,</span> <span class="number">0xF444</span><span class="operator">,</span> <span class="number">0xF4C4</span><span class="operator">,</span> <span class="number">0xF544</span><span class="operator">,</span> <span class="number">0xF5C4</span><span class="operator">,</span> <span class="number">0xF644</span><span class="operator">,</span> <span class="number">0xF6C4</span><span class="operator">,</span> <span class="number">0xF744</span><span class="operator">,</span> <span class="number">0xF7C4</span><span class="operator">,</span> <span class="number">0xF844</span><span class="operator">,</span>
     <span class="number">0xF8A4</span><span class="operator">,</span> <span class="number">0xF8E4</span><span class="operator">,</span> <span class="number">0xF924</span><span class="operator">,</span> <span class="number">0xF964</span><span class="operator">,</span> <span class="number">0xF9A4</span><span class="operator">,</span> <span class="number">0xF9E4</span><span class="operator">,</span> <span class="number">0xFA24</span><span class="operator">,</span> <span class="number">0xFA64</span><span class="operator">,</span> <span class="number">0xFAA4</span><span class="operator">,</span> <span class="number">0xFAE4</span><span class="operator">,</span> <span class="number">0xFB24</span><span class="operator">,</span> <span class="number">0xFB64</span><span class="operator">,</span> <span class="number">0xFBA4</span><span class="operator">,</span> <span class="number">0xFBE4</span><span class="operator">,</span> <span class="number">0xFC24</span><span class="operator">,</span> <span class="number">0xFC64</span><span class="operator">,</span>
     <span class="number">0xFC94</span><span class="operator">,</span> <span class="number">0xFCB4</span><span class="operator">,</span> <span class="number">0xFCD4</span><span class="operator">,</span> <span class="number">0xFCF4</span><span class="operator">,</span> <span class="number">0xFD14</span><span class="operator">,</span> <span class="number">0xFD34</span><span class="operator">,</span> <span class="number">0xFD54</span><span class="operator">,</span> <span class="number">0xFD74</span><span class="operator">,</span> <span class="number">0xFD94</span><span class="operator">,</span> <span class="number">0xFDB4</span><span class="operator">,</span> <span class="number">0xFDD4</span><span class="operator">,</span> <span class="number">0xFDF4</span><span class="operator">,</span> <span class="number">0xFE14</span><span class="operator">,</span> <span class="number">0xFE34</span><span class="operator">,</span> <span class="number">0xFE54</span><span class="operator">,</span> <span class="number">0xFE74</span><span class="operator">,</span>
     <span class="number">0xFE8C</span><span class="operator">,</span> <span class="number">0xFE9C</span><span class="operator">,</span> <span class="number">0xFEAC</span><span class="operator">,</span> <span class="number">0xFEBC</span><span class="operator">,</span> <span class="number">0xFECC</span><span class="operator">,</span> <span class="number">0xFEDC</span><span class="operator">,</span> <span class="number">0xFEEC</span><span class="operator">,</span> <span class="number">0xFEFC</span><span class="operator">,</span> <span class="number">0xFF0C</span><span class="operator">,</span> <span class="number">0xFF1C</span><span class="operator">,</span> <span class="number">0xFF2C</span><span class="operator">,</span> <span class="number">0xFF3C</span><span class="operator">,</span> <span class="number">0xFF4C</span><span class="operator">,</span> <span class="number">0xFF5C</span><span class="operator">,</span> <span class="number">0xFF6C</span><span class="operator">,</span> <span class="number">0xFF7C</span><span class="operator">,</span>
     <span class="number">0xFF88</span><span class="operator">,</span> <span class="number">0xFF90</span><span class="operator">,</span> <span class="number">0xFF98</span><span class="operator">,</span> <span class="number">0xFFA0</span><span class="operator">,</span> <span class="number">0xFFA8</span><span class="operator">,</span> <span class="number">0xFFB0</span><span class="operator">,</span> <span class="number">0xFFB8</span><span class="operator">,</span> <span class="number">0xFFC0</span><span class="operator">,</span> <span class="number">0xFFC8</span><span class="operator">,</span> <span class="number">0xFFD0</span><span class="operator">,</span> <span class="number">0xFFD8</span><span class="operator">,</span> <span class="number">0xFFE0</span><span class="operator">,</span> <span class="number">0xFFE8</span><span class="operator">,</span> <span class="number">0xFFF0</span><span class="operator">,</span> <span class="number">0xFFF8</span><span class="operator">,</span> <span class="number">0x0000</span><span class="operator">,</span>
     <span class="number">0x7D7C</span><span class="operator">,</span> <span class="number">0x797C</span><span class="operator">,</span> <span class="number">0x757C</span><span class="operator">,</span> <span class="number">0x717C</span><span class="operator">,</span> <span class="number">0x6D7C</span><span class="operator">,</span> <span class="number">0x697C</span><span class="operator">,</span> <span class="number">0x657C</span><span class="operator">,</span> <span class="number">0x617C</span><span class="operator">,</span> <span class="number">0x5D7C</span><span class="operator">,</span> <span class="number">0x597C</span><span class="operator">,</span> <span class="number">0x557C</span><span class="operator">,</span> <span class="number">0x517C</span><span class="operator">,</span> <span class="number">0x4D7C</span><span class="operator">,</span> <span class="number">0x497C</span><span class="operator">,</span> <span class="number">0x457C</span><span class="operator">,</span> <span class="number">0x417C</span><span class="operator">,</span>
     <span class="number">0x3E7C</span><span class="operator">,</span> <span class="number">0x3C7C</span><span class="operator">,</span> <span class="number">0x3A7C</span><span class="operator">,</span> <span class="number">0x387C</span><span class="operator">,</span> <span class="number">0x367C</span><span class="operator">,</span> <span class="number">0x347C</span><span class="operator">,</span> <span class="number">0x327C</span><span class="operator">,</span> <span class="number">0x307C</span><span class="operator">,</span> <span class="number">0x2E7C</span><span class="operator">,</span> <span class="number">0x2C7C</span><span class="operator">,</span> <span class="number">0x2A7C</span><span class="operator">,</span> <span class="number">0x287C</span><span class="operator">,</span> <span class="number">0x267C</span><span class="operator">,</span> <span class="number">0x247C</span><span class="operator">,</span> <span class="number">0x227C</span><span class="operator">,</span> <span class="number">0x207C</span><span class="operator">,</span>
     <span class="number">0x1EFC</span><span class="operator">,</span> <span class="number">0x1DFC</span><span class="operator">,</span> <span class="number">0x1CFC</span><span class="operator">,</span> <span class="number">0x1BFC</span><span class="operator">,</span> <span class="number">0x1AFC</span><span class="operator">,</span> <span class="number">0x19FC</span><span class="operator">,</span> <span class="number">0x18FC</span><span class="operator">,</span> <span class="number">0x17FC</span><span class="operator">,</span> <span class="number">0x16FC</span><span class="operator">,</span> <span class="number">0x15FC</span><span class="operator">,</span> <span class="number">0x14FC</span><span class="operator">,</span> <span class="number">0x13FC</span><span class="operator">,</span> <span class="number">0x12FC</span><span class="operator">,</span> <span class="number">0x11FC</span><span class="operator">,</span> <span class="number">0x10FC</span><span class="operator">,</span> <span class="number">0x0FFC</span><span class="operator">,</span>
     <span class="number">0x0F3C</span><span class="operator">,</span> <span class="number">0x0EBC</span><span class="operator">,</span> <span class="number">0x0E3C</span><span class="operator">,</span> <span class="number">0x0DBC</span><span class="operator">,</span> <span class="number">0x0D3C</span><span class="operator">,</span> <span class="number">0x0CBC</span><span class="operator">,</span> <span class="number">0x0C3C</span><span class="operator">,</span> <span class="number">0x0BBC</span><span class="operator">,</span> <span class="number">0x0B3C</span><span class="operator">,</span> <span class="number">0x0ABC</span><span class="operator">,</span> <span class="number">0x0A3C</span><span class="operator">,</span> <span class="number">0x09BC</span><span class="operator">,</span> <span class="number">0x093C</span><span class="operator">,</span> <span class="number">0x08BC</span><span class="operator">,</span> <span class="number">0x083C</span><span class="operator">,</span> <span class="number">0x07BC</span><span class="operator">,</span>
     <span class="number">0x075C</span><span class="operator">,</span> <span class="number">0x071C</span><span class="operator">,</span> <span class="number">0x06DC</span><span class="operator">,</span> <span class="number">0x069C</span><span class="operator">,</span> <span class="number">0x065C</span><span class="operator">,</span> <span class="number">0x061C</span><span class="operator">,</span> <span class="number">0x05DC</span><span class="operator">,</span> <span class="number">0x059C</span><span class="operator">,</span> <span class="number">0x055C</span><span class="operator">,</span> <span class="number">0x051C</span><span class="operator">,</span> <span class="number">0x04DC</span><span class="operator">,</span> <span class="number">0x049C</span><span class="operator">,</span> <span class="number">0x045C</span><span class="operator">,</span> <span class="number">0x041C</span><span class="operator">,</span> <span class="number">0x03DC</span><span class="operator">,</span> <span class="number">0x039C</span><span class="operator">,</span>
     <span class="number">0x036C</span><span class="operator">,</span> <span class="number">0x034C</span><span class="operator">,</span> <span class="number">0x032C</span><span class="operator">,</span> <span class="number">0x030C</span><span class="operator">,</span> <span class="number">0x02EC</span><span class="operator">,</span> <span class="number">0x02CC</span><span class="operator">,</span> <span class="number">0x02AC</span><span class="operator">,</span> <span class="number">0x028C</span><span class="operator">,</span> <span class="number">0x026C</span><span class="operator">,</span> <span class="number">0x024C</span><span class="operator">,</span> <span class="number">0x022C</span><span class="operator">,</span> <span class="number">0x020C</span><span class="operator">,</span> <span class="number">0x01EC</span><span class="operator">,</span> <span class="number">0x01CC</span><span class="operator">,</span> <span class="number">0x01AC</span><span class="operator">,</span> <span class="number">0x018C</span><span class="operator">,</span>
     <span class="number">0x0174</span><span class="operator">,</span> <span class="number">0x0164</span><span class="operator">,</span> <span class="number">0x0154</span><span class="operator">,</span> <span class="number">0x0144</span><span class="operator">,</span> <span class="number">0x0134</span><span class="operator">,</span> <span class="number">0x0124</span><span class="operator">,</span> <span class="number">0x0114</span><span class="operator">,</span> <span class="number">0x0104</span><span class="operator">,</span> <span class="number">0x00F4</span><span class="operator">,</span> <span class="number">0x00E4</span><span class="operator">,</span> <span class="number">0x00D4</span><span class="operator">,</span> <span class="number">0x00C4</span><span class="operator">,</span> <span class="number">0x00B4</span><span class="operator">,</span> <span class="number">0x00A4</span><span class="operator">,</span> <span class="number">0x0094</span><span class="operator">,</span> <span class="number">0x0084</span><span class="operator">,</span>
     <span class="number">0x0078</span><span class="operator">,</span> <span class="number">0x0070</span><span class="operator">,</span> <span class="number">0x0068</span><span class="operator">,</span> <span class="number">0x0060</span><span class="operator">,</span> <span class="number">0x0058</span><span class="operator">,</span> <span class="number">0x0050</span><span class="operator">,</span> <span class="number">0x0048</span><span class="operator">,</span> <span class="number">0x0040</span><span class="operator">,</span> <span class="number">0x0038</span><span class="operator">,</span> <span class="number">0x0030</span><span class="operator">,</span> <span class="number">0x0028</span><span class="operator">,</span> <span class="number">0x0020</span><span class="operator">,</span> <span class="number">0x0018</span><span class="operator">,</span> <span class="number">0x0010</span><span class="operator">,</span> <span class="number">0x0008</span><span class="operator">,</span> <span class="number">0x0000</span>
 };

 <span class="keyword">static</span> DRWAV_INLINE drwav_int16 drwav__alaw_to_s16(drwav_uint8 sampleIn)
 {
     <span class="keyword">return</span> (<span class="type">short</span>)g_drwavAlawTable<span class="operator">[</span>sampleIn<span class="operator">]</span>;
 }

 <span class="keyword">static</span> DRWAV_INLINE drwav_int16 drwav__mulaw_to_s16(drwav_uint8 sampleIn)
 {
     <span class="keyword">return</span> (<span class="type">short</span>)g_drwavMulawTable<span class="operator">[</span>sampleIn<span class="operator">]</span>;
 }

 <span class="keyword">static</span> <span class="type">void</span> drwav__pcm_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t totalSampleCount<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span> bytesPerSample)
 {
     <span class="comment">// Special case for 8-bit sample data because it's treated as unsigned.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>) {
         drwav_u8_to_s16(pOut<span class="operator">,</span> pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     }

     <span class="comment">// Slightly more optimal implementation for common formats.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">2</span>) {
         <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> totalSampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
            <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> ((<span class="keyword">const</span> drwav_int16<span class="operator">*</span>)pIn)<span class="operator">[</span>i<span class="operator">]</span>;
         }
         <span class="keyword">return</span>;
     }
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">3</span>) {
         drwav_s24_to_s16(pOut<span class="operator">,</span> pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     }
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) {
         drwav_s32_to_s16(pOut<span class="operator">,</span> (<span class="keyword">const</span> drwav_int32<span class="operator">*</span>)pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     }

     <span class="comment">// Anything more than 64 bits per sample is not supported.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">&gt;</span> <span class="number">8</span>) {
         drwav_zero_memory(pOut<span class="operator">,</span> totalSampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pOut));
         <span class="keyword">return</span>;
     }

     <span class="comment">// Generic, slow converter.</span>
     <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> totalSampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         drwav_uint64 sample <span class="operator">=</span> <span class="number">0</span>;
         <span class="type">unsigned</span> <span class="type">int</span> shift  <span class="operator">=</span> (<span class="number">8</span> <span class="operator">-</span> bytesPerSample) <span class="operator">*</span> <span class="number">8</span>;

         <span class="type">unsigned</span> <span class="type">int</span> j;
         <span class="keyword">for</span> (j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> bytesPerSample <span class="operator">&amp;</span><span class="operator">&amp;</span> j <span class="operator">&lt;</span> <span class="number">8</span>; j <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>) {
             sample <span class="operator">|</span><span class="operator">=</span> (drwav_uint64)(pIn<span class="operator">[</span>j<span class="operator">]</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> shift;
             shift  <span class="operator">+</span><span class="operator">=</span> <span class="number">8</span>;
         }

         pIn <span class="operator">+</span><span class="operator">=</span> j;
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (drwav_int16)((drwav_int64)sample <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">48</span>);
     }
 }

 <span class="keyword">static</span> <span class="type">void</span> drwav__ieee_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t totalSampleCount<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span> bytesPerSample)
 {
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) {
         drwav_f32_to_s16(pOut<span class="operator">,</span> (<span class="keyword">const</span> <span class="type">float</span><span class="operator">*</span>)pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     } <span class="keyword">else</span> <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">8</span>) {
         drwav_f64_to_s16(pOut<span class="operator">,</span> (<span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span>)pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     } <span class="keyword">else</span> {
         <span class="comment">// Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float.</span>
         drwav_zero_memory(pOut<span class="operator">,</span> totalSampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pOut));
         <span class="keyword">return</span>;
     }
 }

 drwav_uint64 drwav_read_s16__pcm(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample;

     <span class="comment">// Fast path.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_PCM <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">16</span>) {
         <span class="keyword">return</span> drwav_read(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav__pcm_to_s16(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead<span class="operator">,</span> bytesPerSample);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s16__ieee(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav__ieee_to_s16(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead<span class="operator">,</span> bytesPerSample);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s16__alaw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_alaw_to_s16(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s16__mulaw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_mulaw_to_s16(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s16(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> samplesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pBufferOut <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="comment">// Don't try to read more samples than can potentially fit in the output buffer.</span>
     <span class="keyword">if</span> (samplesToRead <span class="operator">*</span> <span class="keyword">sizeof</span>(drwav_int16) <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         samplesToRead <span class="operator">=</span> DRWAV_SIZE_MAX <span class="operator">/</span> <span class="keyword">sizeof</span>(drwav_int16);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_PCM) {
         <span class="keyword">return</span> drwav_read_s16__pcm(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM) {
         <span class="keyword">return</span> drwav_read_s16__msadpcm(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_IEEE_FLOAT) {
         <span class="keyword">return</span> drwav_read_s16__ieee(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ALAW) {
         <span class="keyword">return</span> drwav_read_s16__alaw(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_MULAW) {
         <span class="keyword">return</span> drwav_read_s16__mulaw(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
         <span class="keyword">return</span> drwav_read_s16__ima(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">return</span> <span class="number">0</span>;
 }

 drwav_uint64 drwav_read_pcm_frames_s16(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> drwav_int16<span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">return</span> drwav_read_s16(pWav<span class="operator">,</span> framesToRead <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels<span class="operator">,</span> pBufferOut) <span class="operator">/</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
 }

 <span class="type">void</span> drwav_u8_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="type">int</span> r;
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="type">int</span> x <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">]</span>;
         r <span class="operator">=</span> x <span class="operator">-</span> <span class="number">128</span>;
         r <span class="operator">=</span> r <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>;
         pOut<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> (<span class="type">short</span>)r;
     }
 }

 <span class="type">void</span> drwav_s24_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="type">int</span> r;
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="type">int</span> x <span class="operator">=</span> ((<span class="type">int</span>)(((<span class="type">unsigned</span> <span class="type">int</span>)(((<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span>)pIn)<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span><span class="operator">+</span><span class="number">0</span><span class="operator">]</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>) <span class="operator">|</span> ((<span class="type">unsigned</span> <span class="type">int</span>)(((<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span>)pIn)<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span><span class="operator">+</span><span class="number">1</span><span class="operator">]</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>) <span class="operator">|</span> ((<span class="type">unsigned</span> <span class="type">int</span>)(((<span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span>)pIn)<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span><span class="operator">+</span><span class="number">2</span><span class="operator">]</span>)) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">24</span>)) <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
         r <span class="operator">=</span> x <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">8</span>;
         pOut<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> (<span class="type">short</span>)r;
     }
 }

 <span class="type">void</span> drwav_s32_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int32<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="type">int</span> r;
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="type">int</span> x <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">]</span>;
         r <span class="operator">=</span> x <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">16</span>;
         pOut<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> (<span class="type">short</span>)r;
     }
 }

 <span class="type">void</span> drwav_f32_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">float</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="type">int</span> r;
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="type">float</span> x <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">]</span>;
         <span class="type">float</span> c;
         c <span class="operator">=</span> ((x <span class="operator">&lt;</span> <span class="operator">-</span><span class="number">1</span>) <span class="operator">?</span> <span class="operator">-</span><span class="number">1</span> : ((x <span class="operator">&gt;</span> <span class="number">1</span>) <span class="operator">?</span> <span class="number">1</span> : x));
         c <span class="operator">=</span> c <span class="operator">+</span> <span class="number">1</span>;
         r <span class="operator">=</span> (<span class="type">int</span>)(c <span class="operator">*</span> <span class="number">32767.5f</span>);
         r <span class="operator">=</span> r <span class="operator">-</span> <span class="number">32768</span>;
         pOut<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> (<span class="type">short</span>)r;
     }
 }

 <span class="type">void</span> drwav_f64_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="type">int</span> r;
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="type">double</span> x <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">]</span>;
         <span class="type">double</span> c;
         c <span class="operator">=</span> ((x <span class="operator">&lt;</span> <span class="operator">-</span><span class="number">1</span>) <span class="operator">?</span> <span class="operator">-</span><span class="number">1</span> : ((x <span class="operator">&gt;</span> <span class="number">1</span>) <span class="operator">?</span> <span class="number">1</span> : x));
         c <span class="operator">=</span> c <span class="operator">+</span> <span class="number">1</span>;
         r <span class="operator">=</span> (<span class="type">int</span>)(c <span class="operator">*</span> <span class="number">32767.5</span>);
         r <span class="operator">=</span> r <span class="operator">-</span> <span class="number">32768</span>;
         pOut<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> (<span class="type">short</span>)r;
     }
 }

 <span class="type">void</span> drwav_alaw_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         pOut<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> drwav__alaw_to_s16(pIn<span class="operator">[</span>i<span class="operator">]</span>);
     }
 }

 <span class="type">void</span> drwav_mulaw_to_s16(drwav_int16<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         pOut<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> drwav__mulaw_to_s16(pIn<span class="operator">[</span>i<span class="operator">]</span>);
     }
 }

 <span class="keyword">static</span> <span class="type">void</span> drwav__pcm_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span> bytesPerSample)
 {
     <span class="comment">// Special case for 8-bit sample data because it's treated as unsigned.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>) {
         drwav_u8_to_f32(pOut<span class="operator">,</span> pIn<span class="operator">,</span> sampleCount);
         <span class="keyword">return</span>;
     }

     <span class="comment">// Slightly more optimal implementation for common formats.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">2</span>) {
         drwav_s16_to_f32(pOut<span class="operator">,</span> (<span class="keyword">const</span> drwav_int16<span class="operator">*</span>)pIn<span class="operator">,</span> sampleCount);
         <span class="keyword">return</span>;
     }
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">3</span>) {
         drwav_s24_to_f32(pOut<span class="operator">,</span> pIn<span class="operator">,</span> sampleCount);
         <span class="keyword">return</span>;
     }
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) {
         drwav_s32_to_f32(pOut<span class="operator">,</span> (<span class="keyword">const</span> drwav_int32<span class="operator">*</span>)pIn<span class="operator">,</span> sampleCount);
         <span class="keyword">return</span>;
     }

     <span class="comment">// Anything more than 64 bits per sample is not supported.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">&gt;</span> <span class="number">8</span>) {
         drwav_zero_memory(pOut<span class="operator">,</span> sampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pOut));
         <span class="keyword">return</span>;
     }

     <span class="comment">// Generic, slow converter.</span>
     <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         drwav_uint64 sample <span class="operator">=</span> <span class="number">0</span>;
         <span class="type">unsigned</span> <span class="type">int</span> shift  <span class="operator">=</span> (<span class="number">8</span> <span class="operator">-</span> bytesPerSample) <span class="operator">*</span> <span class="number">8</span>;

         <span class="type">unsigned</span> <span class="type">int</span> j;
         <span class="keyword">for</span> (j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> bytesPerSample <span class="operator">&amp;</span><span class="operator">&amp;</span> j <span class="operator">&lt;</span> <span class="number">8</span>; j <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>) {
             sample <span class="operator">|</span><span class="operator">=</span> (drwav_uint64)(pIn<span class="operator">[</span>j<span class="operator">]</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> shift;
             shift  <span class="operator">+</span><span class="operator">=</span> <span class="number">8</span>;
         }

         pIn <span class="operator">+</span><span class="operator">=</span> j;
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (<span class="type">float</span>)((drwav_int64)sample <span class="operator">/</span> <span class="number">9223372036854775807.0</span>);
     }
 }

 <span class="keyword">static</span> <span class="type">void</span> drwav__ieee_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span> bytesPerSample)
 {
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) {
         <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
             <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> ((<span class="keyword">const</span> <span class="type">float</span><span class="operator">*</span>)pIn)<span class="operator">[</span>i<span class="operator">]</span>;
         }
         <span class="keyword">return</span>;
     } <span class="keyword">else</span> <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">8</span>) {
         drwav_f64_to_f32(pOut<span class="operator">,</span> (<span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span>)pIn<span class="operator">,</span> sampleCount);
         <span class="keyword">return</span>;
     } <span class="keyword">else</span> {
         <span class="comment">// Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float.</span>
         drwav_zero_memory(pOut<span class="operator">,</span> sampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pOut));
         <span class="keyword">return</span>;
     }
 }

 drwav_uint64 drwav_read_f32__pcm(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav__pcm_to_f32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead<span class="operator">,</span> bytesPerSample);
         pBufferOut <span class="operator">+</span><span class="operator">=</span> samplesRead;

         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_f32__msadpcm(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     <span class="comment">// We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't</span>
     <span class="comment">// want to duplicate that code.</span>
     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     drwav_int16 samples16<span class="operator">[</span><span class="number">2048</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read_s16(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="number">2048</span>)<span class="operator">,</span> samples16);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_s16_to_f32(pBufferOut<span class="operator">,</span> samples16<span class="operator">,</span> (size_t)samplesRead);   <span class="comment">// &lt;-- Safe cast because we're clamping to 2048.</span>

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_f32__ima(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     <span class="comment">// We're just going to borrow the implementation from the drwav_read_s16() since IMA-ADPCM is a little bit more complicated than other formats and I don't</span>
     <span class="comment">// want to duplicate that code.</span>
     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     drwav_int16 samples16<span class="operator">[</span><span class="number">2048</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read_s16(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="number">2048</span>)<span class="operator">,</span> samples16);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_s16_to_f32(pBufferOut<span class="operator">,</span> samples16<span class="operator">,</span> (size_t)samplesRead);   <span class="comment">// &lt;-- Safe cast because we're clamping to 2048.</span>

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_f32__ieee(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample;

     <span class="comment">// Fast path.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_IEEE_FLOAT <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">32</span>) {
         <span class="keyword">return</span> drwav_read(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav__ieee_to_f32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead<span class="operator">,</span> bytesPerSample);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_f32__alaw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_alaw_to_f32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_f32__mulaw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_mulaw_to_f32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_f32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> samplesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pBufferOut <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="comment">// Don't try to read more samples than can potentially fit in the output buffer.</span>
     <span class="keyword">if</span> (samplesToRead <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>) <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         samplesToRead <span class="operator">=</span> DRWAV_SIZE_MAX <span class="operator">/</span> <span class="keyword">sizeof</span>(<span class="type">float</span>);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_PCM) {
         <span class="keyword">return</span> drwav_read_f32__pcm(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM) {
         <span class="keyword">return</span> drwav_read_f32__msadpcm(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_IEEE_FLOAT) {
         <span class="keyword">return</span> drwav_read_f32__ieee(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ALAW) {
         <span class="keyword">return</span> drwav_read_f32__alaw(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_MULAW) {
         <span class="keyword">return</span> drwav_read_f32__mulaw(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
         <span class="keyword">return</span> drwav_read_f32__ima(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">return</span> <span class="number">0</span>;
 }

 drwav_uint64 drwav_read_pcm_frames_f32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> <span class="type">float</span><span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">return</span> drwav_read_f32(pWav<span class="operator">,</span> framesToRead <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels<span class="operator">,</span> pBufferOut) <span class="operator">/</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
 }

 <span class="type">void</span> drwav_u8_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

 <span class="preprocessor">#ifdef DR_WAV_LIBSNDFILE_COMPAT</span>
     <span class="comment">// It appears libsndfile uses slightly different logic for the u8 -&gt; f32 conversion to dr_wav, which in my opinion is incorrect. It appears</span>
     <span class="comment">// libsndfile performs the conversion something like &quot;f32 = (u8 / 256) * 2 - 1&quot;, however I think it should be &quot;f32 = (u8 / 255) * 2 - 1&quot; (note</span>
     <span class="comment">// the divisor of 256 vs 255). I use libsndfile as a benchmark for testing, so I'm therefore leaving this block here just for my automated</span>
     <span class="comment">// correctness testing. This is disabled by default.</span>
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (pIn<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">/</span> <span class="number">256.0f</span>) <span class="operator">*</span> <span class="number">2</span> <span class="operator">-</span> <span class="number">1</span>;
     }
 <span class="preprocessor">#else</span>
     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (pIn<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">/</span> <span class="number">255.0f</span>) <span class="operator">*</span> <span class="number">2</span> <span class="operator">-</span> <span class="number">1</span>;
     }
 <span class="preprocessor">#endif</span>
 }

 <span class="type">void</span> drwav_s16_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int16<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">/</span> <span class="number">32768.0f</span>;
     }
 }

 <span class="type">void</span> drwav_s24_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="type">unsigned</span> <span class="type">int</span> s0 <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span> <span class="operator">+</span> <span class="number">0</span><span class="operator">]</span>;
         <span class="type">unsigned</span> <span class="type">int</span> s1 <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>;
         <span class="type">unsigned</span> <span class="type">int</span> s2 <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span> <span class="operator">+</span> <span class="number">2</span><span class="operator">]</span>;

         <span class="type">int</span> sample32 <span class="operator">=</span> (<span class="type">int</span>)((s0 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>) <span class="operator">|</span> (s1 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>) <span class="operator">|</span> (s2 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">24</span>));
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (<span class="type">float</span>)(sample32 <span class="operator">/</span> <span class="number">2147483648.0</span>);
     }
 }

 <span class="type">void</span> drwav_s32_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int32<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (<span class="type">float</span>)(pIn<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">/</span> <span class="number">2147483648.0</span>);
     }
 }

 <span class="type">void</span> drwav_f64_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (<span class="type">float</span>)pIn<span class="operator">[</span>i<span class="operator">]</span>;
     }
 }

 <span class="type">void</span> drwav_alaw_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> drwav__alaw_to_s16(pIn<span class="operator">[</span>i<span class="operator">]</span>) <span class="operator">/</span> <span class="number">32768.0f</span>;
     }
 }

 <span class="type">void</span> drwav_mulaw_to_f32(<span class="type">float</span><span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> drwav__mulaw_to_s16(pIn<span class="operator">[</span>i<span class="operator">]</span>) <span class="operator">/</span> <span class="number">32768.0f</span>;
     }
 }

 <span class="keyword">static</span> <span class="type">void</span> drwav__pcm_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t totalSampleCount<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span> bytesPerSample)
 {
     <span class="comment">// Special case for 8-bit sample data because it's treated as unsigned.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span>) {
         drwav_u8_to_s32(pOut<span class="operator">,</span> pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     }

     <span class="comment">// Slightly more optimal implementation for common formats.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">2</span>) {
         drwav_s16_to_s32(pOut<span class="operator">,</span> (<span class="keyword">const</span> drwav_int16<span class="operator">*</span>)pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     }
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">3</span>) {
         drwav_s24_to_s32(pOut<span class="operator">,</span> pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     }
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) {
         <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> totalSampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
            <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> ((<span class="keyword">const</span> drwav_int32<span class="operator">*</span>)pIn)<span class="operator">[</span>i<span class="operator">]</span>;
         }
         <span class="keyword">return</span>;
     }

     <span class="comment">// Anything more than 64 bits per sample is not supported.</span>
     <span class="keyword">if</span> (bytesPerSample <span class="operator">&gt;</span> <span class="number">8</span>) {
         drwav_zero_memory(pOut<span class="operator">,</span> totalSampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pOut));
         <span class="keyword">return</span>;
     }

     <span class="comment">// Generic, slow converter.</span>
     <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> totalSampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         drwav_uint64 sample <span class="operator">=</span> <span class="number">0</span>;
         <span class="type">unsigned</span> <span class="type">int</span> shift  <span class="operator">=</span> (<span class="number">8</span> <span class="operator">-</span> bytesPerSample) <span class="operator">*</span> <span class="number">8</span>;

         <span class="type">unsigned</span> <span class="type">int</span> j;
         <span class="keyword">for</span> (j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> bytesPerSample <span class="operator">&amp;</span><span class="operator">&amp;</span> j <span class="operator">&lt;</span> <span class="number">8</span>; j <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span>) {
             sample <span class="operator">|</span><span class="operator">=</span> (drwav_uint64)(pIn<span class="operator">[</span>j<span class="operator">]</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> shift;
             shift  <span class="operator">+</span><span class="operator">=</span> <span class="number">8</span>;
         }

         pIn <span class="operator">+</span><span class="operator">=</span> j;
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (drwav_int32)((drwav_int64)sample <span class="operator">&gt;</span><span class="operator">&gt;</span> <span class="number">32</span>);
     }
 }

 <span class="keyword">static</span> <span class="type">void</span> drwav__ieee_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">char</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t totalSampleCount<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span> bytesPerSample)
 {
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">4</span>) {
         drwav_f32_to_s32(pOut<span class="operator">,</span> (<span class="keyword">const</span> <span class="type">float</span><span class="operator">*</span>)pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     } <span class="keyword">else</span> <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">8</span>) {
         drwav_f64_to_s32(pOut<span class="operator">,</span> (<span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span>)pIn<span class="operator">,</span> totalSampleCount);
         <span class="keyword">return</span>;
     } <span class="keyword">else</span> {
         <span class="comment">// Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float.</span>
         drwav_zero_memory(pOut<span class="operator">,</span> totalSampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="operator">*</span>pOut));
         <span class="keyword">return</span>;
     }
 }

 drwav_uint64 drwav_read_s32__pcm(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample;

     <span class="comment">// Fast path.</span>
     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_PCM <span class="operator">&amp;</span><span class="operator">&amp;</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>bitsPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">32</span>) {
         <span class="keyword">return</span> drwav_read(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav__pcm_to_s32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead<span class="operator">,</span> bytesPerSample);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s32__msadpcm(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     <span class="comment">// We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't</span>
     <span class="comment">// want to duplicate that code.</span>
     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     drwav_int16 samples16<span class="operator">[</span><span class="number">2048</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read_s16(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="number">2048</span>)<span class="operator">,</span> samples16);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_s16_to_s32(pBufferOut<span class="operator">,</span> samples16<span class="operator">,</span> (size_t)samplesRead);   <span class="comment">// &lt;-- Safe cast because we're clamping to 2048.</span>

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s32__ima(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     <span class="comment">// We're just going to borrow the implementation from the drwav_read_s16() since IMA-ADPCM is a little bit more complicated than other formats and I don't</span>
     <span class="comment">// want to duplicate that code.</span>
     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     drwav_int16 samples16<span class="operator">[</span><span class="number">2048</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read_s16(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="number">2048</span>)<span class="operator">,</span> samples16);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_s16_to_s32(pBufferOut<span class="operator">,</span> samples16<span class="operator">,</span> (size_t)samplesRead);   <span class="comment">// &lt;-- Safe cast because we're clamping to 2048.</span>

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s32__ieee(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav__ieee_to_s32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead<span class="operator">,</span> bytesPerSample);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s32__alaw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_alaw_to_s32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s32__mulaw(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     drwav_uint32 bytesPerSample <span class="operator">=</span> drwav_get_bytes_per_sample(pWav);
     <span class="keyword">if</span> (bytesPerSample <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     drwav_uint64 totalSamplesRead <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">unsigned</span> <span class="type">char</span> sampleData<span class="operator">[</span><span class="number">4096</span><span class="operator">]</span>;
     <span class="keyword">while</span> (samplesToRead <span class="operator">&gt;</span> <span class="number">0</span>) {
         drwav_uint64 samplesRead <span class="operator">=</span> drwav_read(pWav<span class="operator">,</span> drwav_min(samplesToRead<span class="operator">,</span> <span class="keyword">sizeof</span>(sampleData)<span class="operator">/</span>bytesPerSample)<span class="operator">,</span> sampleData);
         <span class="keyword">if</span> (samplesRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
             <span class="keyword">break</span>;
         }

         drwav_mulaw_to_s32(pBufferOut<span class="operator">,</span> sampleData<span class="operator">,</span> (size_t)samplesRead);

         pBufferOut       <span class="operator">+</span><span class="operator">=</span> samplesRead;
         samplesToRead    <span class="operator">-</span><span class="operator">=</span> samplesRead;
         totalSamplesRead <span class="operator">+</span><span class="operator">=</span> samplesRead;
     }

     <span class="keyword">return</span> totalSamplesRead;
 }

 drwav_uint64 drwav_read_s32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 samplesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">if</span> (pWav <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> samplesToRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> pBufferOut <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> <span class="number">0</span>;
     }

     <span class="comment">// Don't try to read more samples than can potentially fit in the output buffer.</span>
     <span class="keyword">if</span> (samplesToRead <span class="operator">*</span> <span class="keyword">sizeof</span>(drwav_int32) <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         samplesToRead <span class="operator">=</span> DRWAV_SIZE_MAX <span class="operator">/</span> <span class="keyword">sizeof</span>(drwav_int32);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_PCM) {
         <span class="keyword">return</span> drwav_read_s32__pcm(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ADPCM) {
         <span class="keyword">return</span> drwav_read_s32__msadpcm(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_IEEE_FLOAT) {
         <span class="keyword">return</span> drwav_read_s32__ieee(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_ALAW) {
         <span class="keyword">return</span> drwav_read_s32__alaw(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_MULAW) {
         <span class="keyword">return</span> drwav_read_s32__mulaw(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">if</span> (pWav<span class="operator">-</span><span class="operator">&gt;</span>translatedFormatTag <span class="operator">=</span><span class="operator">=</span> DR_WAVE_FORMAT_DVI_ADPCM) {
         <span class="keyword">return</span> drwav_read_s32__ima(pWav<span class="operator">,</span> samplesToRead<span class="operator">,</span> pBufferOut);
     }

     <span class="keyword">return</span> <span class="number">0</span>;
 }

 drwav_uint64 drwav_read_pcm_frames_s32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> drwav_uint64 framesToRead<span class="operator">,</span> drwav_int32<span class="operator">*</span> pBufferOut)
 {
     <span class="keyword">return</span> drwav_read_s32(pWav<span class="operator">,</span> framesToRead <span class="operator">*</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels<span class="operator">,</span> pBufferOut) <span class="operator">/</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
 }

 <span class="type">void</span> drwav_u8_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> ((<span class="type">int</span>)pIn<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">-</span> <span class="number">128</span>) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">24</span>;
     }
 }

 <span class="type">void</span> drwav_s16_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_int16<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>;
     }
 }

 <span class="type">void</span> drwav_s24_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="type">unsigned</span> <span class="type">int</span> s0 <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span> <span class="operator">+</span> <span class="number">0</span><span class="operator">]</span>;
         <span class="type">unsigned</span> <span class="type">int</span> s1 <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>;
         <span class="type">unsigned</span> <span class="type">int</span> s2 <span class="operator">=</span> pIn<span class="operator">[</span>i<span class="operator">*</span><span class="number">3</span> <span class="operator">+</span> <span class="number">2</span><span class="operator">]</span>;

         drwav_int32 sample32 <span class="operator">=</span> (drwav_int32)((s0 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">8</span>) <span class="operator">|</span> (s1 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>) <span class="operator">|</span> (s2 <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">24</span>));
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> sample32;
     }
 }

 <span class="type">void</span> drwav_f32_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">float</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (drwav_int32)(<span class="number">2147483648.0</span> <span class="operator">*</span> pIn<span class="operator">[</span>i<span class="operator">]</span>);
     }
 }

 <span class="type">void</span> drwav_f64_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> <span class="type">double</span><span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> (drwav_int32)(<span class="number">2147483648.0</span> <span class="operator">*</span> pIn<span class="operator">[</span>i<span class="operator">]</span>);
     }
 }

 <span class="type">void</span> drwav_alaw_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> ((drwav_int32)drwav__alaw_to_s16(pIn<span class="operator">[</span>i<span class="operator">]</span>)) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>;
     }
 }

 <span class="type">void</span> drwav_mulaw_to_s32(drwav_int32<span class="operator">*</span> pOut<span class="operator">,</span> <span class="keyword">const</span> drwav_uint8<span class="operator">*</span> pIn<span class="operator">,</span> size_t sampleCount)
 {
     <span class="keyword">if</span> (pOut <span class="operator">=</span><span class="operator">=</span> NULL <span class="operator">|</span><span class="operator">|</span> pIn <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span>;
     }

     <span class="keyword">for</span> (size_t i<span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> sampleCount; <span class="operator">+</span><span class="operator">+</span>i) {
         <span class="operator">*</span>pOut<span class="operator">+</span><span class="operator">+</span> <span class="operator">=</span> ((drwav_int32)drwav__mulaw_to_s16(pIn<span class="operator">[</span>i<span class="operator">]</span>)) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">16</span>;
     }
 }

 drwav_int16<span class="operator">*</span> drwav__read_and_close_s16(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     drwav_assert(pWav <span class="operator">!</span><span class="operator">=</span> NULL);

     drwav_uint64 sampleDataSize <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(drwav_int16);
     <span class="keyword">if</span> (sampleDataSize <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// File's too big.</span>
     }

     drwav_int16<span class="operator">*</span> pSampleData <span class="operator">=</span> (drwav_int16<span class="operator">*</span>)DRWAV_MALLOC((size_t)sampleDataSize);    <span class="comment">// &lt;-- Safe cast due to the check above.</span>
     <span class="keyword">if</span> (pSampleData <span class="operator">=</span><span class="operator">=</span> NULL) {
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// Failed to allocate memory.</span>
     }

     drwav_uint64 samplesRead <span class="operator">=</span> drwav_read_s16(pWav<span class="operator">,</span> (size_t)pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount<span class="operator">,</span> pSampleData);
     <span class="keyword">if</span> (samplesRead <span class="operator">!</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
         DRWAV_FREE(pSampleData);
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// There was an error reading the samples.</span>
     }

     drwav_uninit(pWav);

     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>sampleRate;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount;
     <span class="keyword">return</span> pSampleData;
 }

 <span class="type">float</span><span class="operator">*</span> drwav__read_and_close_f32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     drwav_assert(pWav <span class="operator">!</span><span class="operator">=</span> NULL);

     drwav_uint64 sampleDataSize <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(<span class="type">float</span>);
     <span class="keyword">if</span> (sampleDataSize <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// File's too big.</span>
     }

     <span class="type">float</span><span class="operator">*</span> pSampleData <span class="operator">=</span> (<span class="type">float</span><span class="operator">*</span>)DRWAV_MALLOC((size_t)sampleDataSize);    <span class="comment">// &lt;-- Safe cast due to the check above.</span>
     <span class="keyword">if</span> (pSampleData <span class="operator">=</span><span class="operator">=</span> NULL) {
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// Failed to allocate memory.</span>
     }

     drwav_uint64 samplesRead <span class="operator">=</span> drwav_read_f32(pWav<span class="operator">,</span> (size_t)pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount<span class="operator">,</span> pSampleData);
     <span class="keyword">if</span> (samplesRead <span class="operator">!</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
         DRWAV_FREE(pSampleData);
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// There was an error reading the samples.</span>
     }

     drwav_uninit(pWav);

     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>sampleRate;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount;
     <span class="keyword">return</span> pSampleData;
 }

 drwav_int32<span class="operator">*</span> drwav__read_and_close_s32(drwav<span class="operator">*</span> pWav<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     drwav_assert(pWav <span class="operator">!</span><span class="operator">=</span> NULL);

     drwav_uint64 sampleDataSize <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount <span class="operator">*</span> <span class="keyword">sizeof</span>(drwav_int32);
     <span class="keyword">if</span> (sampleDataSize <span class="operator">&gt;</span> DRWAV_SIZE_MAX) {
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// File's too big.</span>
     }

     drwav_int32<span class="operator">*</span> pSampleData <span class="operator">=</span> (drwav_int32<span class="operator">*</span>)DRWAV_MALLOC((size_t)sampleDataSize);    <span class="comment">// &lt;-- Safe cast due to the check above.</span>
     <span class="keyword">if</span> (pSampleData <span class="operator">=</span><span class="operator">=</span> NULL) {
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// Failed to allocate memory.</span>
     }

     drwav_uint64 samplesRead <span class="operator">=</span> drwav_read_s32(pWav<span class="operator">,</span> (size_t)pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount<span class="operator">,</span> pSampleData);
     <span class="keyword">if</span> (samplesRead <span class="operator">!</span><span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount) {
         DRWAV_FREE(pSampleData);
         drwav_uninit(pWav);
         <span class="keyword">return</span> NULL;    <span class="comment">// There was an error reading the samples.</span>
     }

     drwav_uninit(pWav);

     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>sampleRate;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>channels;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> pWav<span class="operator">-</span><span class="operator">&gt;</span>totalSampleCount;
     <span class="keyword">return</span> pSampleData;
 }

 drwav_int16<span class="operator">*</span> drwav_open_and_read_s16(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init(<span class="operator">&amp;</span>wav<span class="operator">,</span> onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_s16(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 drwav_int16<span class="operator">*</span> drwav_open_and_read_pcm_frames_s16(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     drwav_int16<span class="operator">*</span> result <span class="operator">=</span> drwav_open_and_read_s16(onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }

 <span class="type">float</span><span class="operator">*</span> drwav_open_and_read_f32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init(<span class="operator">&amp;</span>wav<span class="operator">,</span> onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_f32(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 <span class="type">float</span><span class="operator">*</span> drwav_open_and_read_pcm_frames_f32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     <span class="type">float</span><span class="operator">*</span> result <span class="operator">=</span> drwav_open_and_read_f32(onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }

 drwav_int32<span class="operator">*</span> drwav_open_and_read_s32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init(<span class="operator">&amp;</span>wav<span class="operator">,</span> onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_s32(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 drwav_int32<span class="operator">*</span> drwav_open_and_read_pcm_frames_s32(drwav_read_proc onRead<span class="operator">,</span> drwav_seek_proc onSeek<span class="operator">,</span> <span class="type">void</span><span class="operator">*</span> pUserData<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     drwav_int32<span class="operator">*</span> result <span class="operator">=</span> drwav_open_and_read_s32(onRead<span class="operator">,</span> onSeek<span class="operator">,</span> pUserData<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }

 <span class="preprocessor">#ifndef DR_WAV_NO_STDIO</span>
 drwav_int16<span class="operator">*</span> drwav_open_file_and_read_s16(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_file(<span class="operator">&amp;</span>wav<span class="operator">,</span> filename)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_s16(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 drwav_int16<span class="operator">*</span> drwav_open_file_and_read_pcm_frames_s16(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     drwav_int16<span class="operator">*</span> result <span class="operator">=</span> drwav_open_file_and_read_s16(filename<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }

 <span class="type">float</span><span class="operator">*</span> drwav_open_file_and_read_f32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_file(<span class="operator">&amp;</span>wav<span class="operator">,</span> filename)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_f32(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 <span class="type">float</span><span class="operator">*</span> drwav_open_file_and_read_pcm_frames_f32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     <span class="type">float</span><span class="operator">*</span> result <span class="operator">=</span> drwav_open_file_and_read_f32(filename<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }

 drwav_int32<span class="operator">*</span> drwav_open_file_and_read_s32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_file(<span class="operator">&amp;</span>wav<span class="operator">,</span> filename)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_s32(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 drwav_int32<span class="operator">*</span> drwav_open_file_and_read_pcm_frames_s32(<span class="keyword">const</span> <span class="type">char</span><span class="operator">*</span> filename<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     drwav_int32<span class="operator">*</span> result <span class="operator">=</span> drwav_open_file_and_read_s32(filename<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }
 <span class="preprocessor">#endif</span>

 drwav_int16<span class="operator">*</span> drwav_open_memory_and_read_s16(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_memory(<span class="operator">&amp;</span>wav<span class="operator">,</span> data<span class="operator">,</span> dataSize)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_s16(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 drwav_int16<span class="operator">*</span> drwav_open_memory_and_read_pcm_frames_s16(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     drwav_int16<span class="operator">*</span> result <span class="operator">=</span> drwav_open_memory_and_read_s16(data<span class="operator">,</span> dataSize<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }

 <span class="type">float</span><span class="operator">*</span> drwav_open_memory_and_read_f32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_memory(<span class="operator">&amp;</span>wav<span class="operator">,</span> data<span class="operator">,</span> dataSize)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_f32(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 <span class="type">float</span><span class="operator">*</span> drwav_open_memory_and_read_pcm_frames_f32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     <span class="type">float</span><span class="operator">*</span> result <span class="operator">=</span> drwav_open_memory_and_read_f32(data<span class="operator">,</span> dataSize<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }

 drwav_int32<span class="operator">*</span> drwav_open_memory_and_read_s32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channels<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRate<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalSampleCount)
 {
     <span class="keyword">if</span> (sampleRate) <span class="operator">*</span>sampleRate <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (channels) <span class="operator">*</span>channels <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalSampleCount) <span class="operator">*</span>totalSampleCount <span class="operator">=</span> <span class="number">0</span>;

     drwav wav;
     <span class="keyword">if</span> (<span class="operator">!</span>drwav_init_memory(<span class="operator">&amp;</span>wav<span class="operator">,</span> data<span class="operator">,</span> dataSize)) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">return</span> drwav__read_and_close_s32(<span class="operator">&amp;</span>wav<span class="operator">,</span> channels<span class="operator">,</span> sampleRate<span class="operator">,</span> totalSampleCount);
 }

 drwav_int32<span class="operator">*</span> drwav_open_memory_and_read_pcm_frames_s32(<span class="keyword">const</span> <span class="type">void</span><span class="operator">*</span> data<span class="operator">,</span> size_t dataSize<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> channelsOut<span class="operator">,</span> <span class="type">unsigned</span> <span class="type">int</span><span class="operator">*</span> sampleRateOut<span class="operator">,</span> drwav_uint64<span class="operator">*</span> totalFrameCountOut)
 {
     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> <span class="number">0</span>;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> <span class="number">0</span>;

     <span class="type">unsigned</span> <span class="type">int</span> channels;
     <span class="type">unsigned</span> <span class="type">int</span> sampleRate;
     drwav_uint64 totalSampleCount;
     drwav_int32<span class="operator">*</span> result <span class="operator">=</span> drwav_open_memory_and_read_s32(data<span class="operator">,</span> dataSize<span class="operator">,</span> <span class="operator">&amp;</span>channels<span class="operator">,</span> <span class="operator">&amp;</span>sampleRate<span class="operator">,</span> <span class="operator">&amp;</span>totalSampleCount);
     <span class="keyword">if</span> (result <span class="operator">=</span><span class="operator">=</span> NULL) {
         <span class="keyword">return</span> NULL;
     }

     <span class="keyword">if</span> (channelsOut) <span class="operator">*</span>channelsOut <span class="operator">=</span> channels;
     <span class="keyword">if</span> (sampleRateOut) <span class="operator">*</span>sampleRateOut <span class="operator">=</span> sampleRate;
     <span class="keyword">if</span> (totalFrameCountOut) <span class="operator">*</span>totalFrameCountOut <span class="operator">=</span> totalSampleCount <span class="operator">/</span> channels;

     <span class="keyword">return</span> result;
 }
 <span class="preprocessor">#endif  //DR_WAV_NO_CONVERSION_API</span>

 <span class="type">void</span> drwav_free(<span class="type">void</span><span class="operator">*</span> pDataReturnedByOpenAndRead)
 {
     DRWAV_FREE(pDataReturnedByOpenAndRead);
 }

 <span class="preprocessor">#endif  //DR_WAV_IMPLEMENTATION</span>

 <span class="comment">// REVISION HISTORY</span>
 <span class="comment">//</span>
 <span class="comment">// v0.9.0 - 2018-12-16</span>
 <span class="comment">//   - API CHANGE: Add new reading APIs for reading by PCM frames instead of samples. Old APIs have been deprecated and</span>
 <span class="comment">//     will be removed in v0.10.0. Deprecated APIs and their replacements:</span>
 <span class="comment">//       drwav_read()                     -&gt; drwav_read_pcm_frames()</span>
 <span class="comment">//       drwav_read_s16()                 -&gt; drwav_read_pcm_frames_s16()</span>
 <span class="comment">//       drwav_read_f32()                 -&gt; drwav_read_pcm_frames_f32()</span>
 <span class="comment">//       drwav_read_s32()                 -&gt; drwav_read_pcm_frames_s32()</span>
 <span class="comment">//       drwav_seek_to_sample()           -&gt; drwav_seek_to_pcm_frame()</span>
 <span class="comment">//       drwav_write()                    -&gt; drwav_write_pcm_frames()</span>
 <span class="comment">//       drwav_open_and_read_s16()        -&gt; drwav_open_and_read_pcm_frames_s16()</span>
 <span class="comment">//       drwav_open_and_read_f32()        -&gt; drwav_open_and_read_pcm_frames_f32()</span>
 <span class="comment">//       drwav_open_and_read_s32()        -&gt; drwav_open_and_read_pcm_frames_s32()</span>
 <span class="comment">//       drwav_open_file_and_read_s16()   -&gt; drwav_open_file_and_read_pcm_frames_s16()</span>
 <span class="comment">//       drwav_open_file_and_read_f32()   -&gt; drwav_open_file_and_read_pcm_frames_f32()</span>
 <span class="comment">//       drwav_open_file_and_read_s32()   -&gt; drwav_open_file_and_read_pcm_frames_s32()</span>
 <span class="comment">//       drwav_open_memory_and_read_s16() -&gt; drwav_open_memory_and_read_pcm_frames_s16()</span>
 <span class="comment">//       drwav_open_memory_and_read_f32() -&gt; drwav_open_memory_and_read_pcm_frames_f32()</span>
 <span class="comment">//       drwav_open_memory_and_read_s32() -&gt; drwav_open_memory_and_read_pcm_frames_s32()</span>
 <span class="comment">//       drwav::totalSampleCount          -&gt; drwav::totalPCMFrameCount</span>
 <span class="comment">//   - API CHANGE: Rename drwav_open_and_read_file_*() to drwav_open_file_and_read_*().</span>
 <span class="comment">//   - API CHANGE: Rename drwav_open_and_read_memory_*() to drwav_open_memory_and_read_*().</span>
 <span class="comment">//   - Add built-in support for smpl chunks.</span>
 <span class="comment">//   - Add support for firing a callback for each chunk in the file at initialization time.</span>
 <span class="comment">//     - This is enabled through the drwav_init_ex(), etc. family of APIs.</span>
 <span class="comment">//   - Handle invalid FMT chunks more robustly.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.8.5 - 2018-09-11</span>
 <span class="comment">//   - Const correctness.</span>
 <span class="comment">//   - Fix a potential stack overflow.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.8.4 - 2018-08-07</span>
 <span class="comment">//   - Improve 64-bit detection.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.8.3 - 2018-08-05</span>
 <span class="comment">//   - Fix C++ build on older versions of GCC.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.8.2 - 2018-08-02</span>
 <span class="comment">//   - Fix some big-endian bugs.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.8.1 - 2018-06-29</span>
 <span class="comment">//   - Add support for sequential writing APIs.</span>
 <span class="comment">//   - Disable seeking in write mode.</span>
 <span class="comment">//   - Fix bugs with Wave64.</span>
 <span class="comment">//   - Fix typos.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.8 - 2018-04-27</span>
 <span class="comment">//   - Bug fix.</span>
 <span class="comment">//   - Start using major.minor.revision versioning.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.7f - 2018-02-05</span>
 <span class="comment">//   - Restrict ADPCM formats to a maximum of 2 channels.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.7e - 2018-02-02</span>
 <span class="comment">//   - Fix a crash.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.7d - 2018-02-01</span>
 <span class="comment">//   - Fix a crash.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.7c - 2018-02-01</span>
 <span class="comment">//   - Set drwav.bytesPerSample to 0 for all compressed formats.</span>
 <span class="comment">//   - Fix a crash when reading 16-bit floating point WAV files. In this case dr_wav will output silence for</span>
 <span class="comment">//     all format conversion reading APIs (*_s16, *_s32, *_f32 APIs).</span>
 <span class="comment">//   - Fix some divide-by-zero errors.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.7b - 2018-01-22</span>
 <span class="comment">//   - Fix errors with seeking of compressed formats.</span>
 <span class="comment">//   - Fix compilation error when DR_WAV_NO_CONVERSION_API</span>
 <span class="comment">//</span>
 <span class="comment">// v0.7a - 2017-11-17</span>
 <span class="comment">//   - Fix some GCC warnings.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.7 - 2017-11-04</span>
 <span class="comment">//   - Add writing APIs.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.6 - 2017-08-16</span>
 <span class="comment">//   - API CHANGE: Rename dr_* types to drwav_*.</span>
 <span class="comment">//   - Add support for custom implementations of malloc(), realloc(), etc.</span>
 <span class="comment">//   - Add support for Microsoft ADPCM.</span>
 <span class="comment">//   - Add support for IMA ADPCM (DVI, format code 0x11).</span>
 <span class="comment">//   - Optimizations to drwav_read_s16().</span>
 <span class="comment">//   - Bug fixes.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5g - 2017-07-16</span>
 <span class="comment">//   - Change underlying type for booleans to unsigned.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5f - 2017-04-04</span>
 <span class="comment">//   - Fix a minor bug with drwav_open_and_read_s16() and family.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5e - 2016-12-29</span>
 <span class="comment">//   - Added support for reading samples as signed 16-bit integers. Use the _s16() family of APIs for this.</span>
 <span class="comment">//   - Minor fixes to documentation.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5d - 2016-12-28</span>
 <span class="comment">//   - Use drwav_int*/drwav_uint* sized types to improve compiler support.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5c - 2016-11-11</span>
 <span class="comment">//   - Properly handle JUNK chunks that come before the FMT chunk.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5b - 2016-10-23</span>
 <span class="comment">//   - A minor change to drwav_bool8 and drwav_bool32 types.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5a - 2016-10-11</span>
 <span class="comment">//   - Fixed a bug with drwav_open_and_read() and family due to incorrect argument ordering.</span>
 <span class="comment">//   - Improve A-law and mu-law efficiency.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.5 - 2016-09-29</span>
 <span class="comment">//   - API CHANGE. Swap the order of &quot;channels&quot; and &quot;sampleRate&quot; parameters in drwav_open_and_read*(). Rationale for this is to</span>
 <span class="comment">//     keep it consistent with dr_audio and dr_flac.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.4b - 2016-09-18</span>
 <span class="comment">//   - Fixed a typo in documentation.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.4a - 2016-09-18</span>
 <span class="comment">//   - Fixed a typo.</span>
 <span class="comment">//   - Change date format to ISO 8601 (YYYY-MM-DD)</span>
 <span class="comment">//</span>
 <span class="comment">// v0.4 - 2016-07-13</span>
 <span class="comment">//   - API CHANGE. Make onSeek consistent with dr_flac.</span>
 <span class="comment">//   - API CHANGE. Rename drwav_seek() to drwav_seek_to_sample() for clarity and consistency with dr_flac.</span>
 <span class="comment">//   - Added support for Sony Wave64.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.3a - 2016-05-28</span>
 <span class="comment">//   - API CHANGE. Return drwav_bool32 instead of int in onSeek callback.</span>
 <span class="comment">//   - Fixed a memory leak.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.3 - 2016-05-22</span>
 <span class="comment">//   - Lots of API changes for consistency.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.2a - 2016-05-16</span>
 <span class="comment">//   - Fixed Linux/GCC build.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.2 - 2016-05-11</span>
 <span class="comment">//   - Added support for reading data as signed 32-bit PCM for consistency with dr_flac.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.1a - 2016-05-07</span>
 <span class="comment">//   - Fixed a bug in drwav_open_file() where the file handle would not be closed if the loader failed to initialize.</span>
 <span class="comment">//</span>
 <span class="comment">// v0.1 - 2016-05-04</span>
 <span class="comment">//   - Initial versioned release.</span>

 <span class="comment">/*
 This is free and unencumbered software released into the public domain.

 Anyone is free to copy, modify, publish, use, compile, sell, or
 distribute this software, either in source code form or as a compiled
 binary, for any purpose, commercial or non-commercial, and by any
 means.

 In jurisdictions that recognize copyright laws, the author or authors
 of this software dedicate any and all copyright interest in the
 software to the public domain. We make this dedication for the benefit
 of the public at large and to the detriment of our heirs and
 successors. We intend this dedication to be an overt act of
 relinquishment in perpetuity of all present and future rights to this
 software under copyright law.

 THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

 For more information, please refer to &lt;http://unlicense.org/&gt;
 */</span>
</pre>
