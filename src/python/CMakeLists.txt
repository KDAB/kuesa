# CMakeLists.txt
#
# This file is part of Kuesa.
#
# Copyright (C) 2018-2019 Klar√§lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com
# Author: Mike Krus <mike.krus@kdab.com>
#
# Licensees holding valid proprietary KDAB Kuesa licenses may use this file in
# accordance with the Kuesa Enterprise License Agreement provided with the Software in the
# LICENSE.KUESA.ENTERPRISE file.
#
# Contact info@kdab.com if any conditions of this licensing are not clear to you.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

cmake_minimum_required(VERSION 3.1)
cmake_policy(VERSION 3.1)

# Enable policy to not use RPATH settings for install_name on macOS.
if(POLICY CMP0068)
    cmake_policy(SET CMP0068 NEW)
endif()

# Consider changing the project name to something relevant for you.
project(KuesaBindings)

# ================================ General configuration ======================================

# Set CPP standard to C++11 minimum.
set(CMAKE_CXX_STANDARD 11)

# The name of the generated bindings module (as imported in Python). You can change the name
# to something relevant for your project.
set(bindings_library "Kuesa")

# The header file with all the types and functions for which bindings will be generated.
# Usually it simply includes other headers of the library you are creating bindings for.
set(wrapped_header "${CMAKE_SOURCE_DIR}/bindings.h")

# The typesystem xml file which defines the relationships between the C++ types / functions
# and the corresponding Python equivalents.
set(typesystem_file "${CMAKE_SOURCE_DIR}/bindings.xml")

# Specify which C++ files will be generated by shiboken. This includes the module wrapper
# and a '.cpp' file per C++ type. These are needed for generating the module shared
# library.
set(generated_sources
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_abstractassetcollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_abstractpostprocessingeffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_animationclipcollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_animationmappingcollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_animationplayer_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_armaturecollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_bloomeffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_cameracollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_depthoffieldeffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_directionallight_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_effectcollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_entitycollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_forwardrenderer_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_fullscreenquad_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_gaussianblureffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_gltf2import_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_gltf2importer_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_gltf2import_gltf2options_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_gltf2material_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_gltf2materialproperties_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_layercollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_materialcollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_meshcollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_metallicroughnesseffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_metallicroughnessmaterial_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_metallicroughnessproperties_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_morphcontroller_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_module_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_opacitymask_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_pointlight_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_sceneentity_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_skeletoncollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_skybox_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_spotlight_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_texturecollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_textureimagecollection_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_thresholdeffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_tonemappingandgammacorrectioneffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_unliteffect_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_unlitmaterial_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_unlitproperties_wrapper.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/${bindings_library}/kuesa_wrapper.cpp
)

find_package(Qt5Kuesa REQUIRED)

# ================================== Shiboken detection ======================================
# Use provided python interpreter if given.
if(NOT python_interpreter)
    find_program(python_interpreter "python")
endif()
message(STATUS "Using python interpreter: ${python_interpreter}")

# Macro to get various pyside / python include / link flags and paths.
# Uses the not entirely supported utils/pyside2_config.py file.
macro(pyside2_config option output_var)
    if(${ARGC} GREATER 2)
        set(is_list ${ARGV2})
    else()
        set(is_list "")
    endif()

    execute_process(
      COMMAND ${python_interpreter} "${CMAKE_SOURCE_DIR}/utils/pyside2_config.py"
              ${option}
      OUTPUT_VARIABLE ${output_var}
      OUTPUT_STRIP_TRAILING_WHITESPACE)

    if ("${${output_var}}" STREQUAL "")
        message(FATAL_ERROR "Error: Calling pyside2_config.py ${option} returned no output.")
    endif()
    if(is_list)
        string (REPLACE " " ";" ${output_var} "${${output_var}}")
    endif()
endmacro()

# Query for the shiboken generator path, Python path, include paths and linker flags.
pyside2_config(--shiboken2-module-path shiboken2_module_path)
pyside2_config(--shiboken2-generator-path shiboken2_generator_path)
pyside2_config(--python-include-path python_include_dir)
pyside2_config(--shiboken2-generator-include-path shiboken_include_dir 1)
pyside2_config(--shiboken2-module-shared-libraries-cmake shiboken_shared_libraries 0)
pyside2_config(--python-link-flags-cmake python_linking_data 0)
pyside2_config(--pyside2-path pyside2_path)

set(shiboken_path "${shiboken2_generator_path}/shiboken2${CMAKE_EXECUTABLE_SUFFIX}")
if(NOT EXISTS "${shiboken_path}")
    find_program(shiboken_path_system shiboken2)

    if(NOT EXISTS "${shiboken_path_system}")
        message(FATAL_ERROR "Shiboken executable not found ; tried '${shiboken_path}' and '${shiboken_path_system}'")
    else()
        set(shiboken_path "${shiboken_path_system}")
    endif()
endif()

# ==================================== RPATH configuration ====================================

# Enable rpaths so that the built shared libraries find their dependencies.
set(CMAKE_SKIP_BUILD_RPATH FALSE)
set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
set(CMAKE_INSTALL_RPATH ${shiboken2_module_path} ${CMAKE_CURRENT_SOURCE_DIR})
set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)

# ====================== Shiboken target for generating binding C++ files  ====================

# Set up the options to pass to shiboken.
set(shiboken_options --generator-set=shiboken --enable-parent-ctor-heuristic
    --enable-return-value-heuristic --use-isnull-as-nb_nonzero
    --avoid-protected-hack --enable-pyside-extensions
    "-I${CMAKE_SOURCE_DIR}"
    "-I${Qt53DCore_DIR}/../../../include"
    "-T${CMAKE_SOURCE_DIR}"
    "-T${pyside2_path}/typesystems"
    )

if(EXISTS "/usr/share/PySide2/typesystems")
    list(APPEND shiboken_options "-T/usr/share/PySide2/typesystems")
endif()

foreach(_dir ${Qt5Kuesa_INCLUDE_DIRS})
    list(APPEND shiboken_options "-I${_dir}")
endforeach()
list(APPEND shiboken_options "--output-directory=${CMAKE_CURRENT_BINARY_DIR}")

set(generated_sources_dependencies ${wrapped_header} ${typesystem_file})

# Add custom target to run shiboken to generate the binding cpp files.
add_custom_command(OUTPUT ${generated_sources}
                    COMMAND ${shiboken_path}
                    ${shiboken_options} ${wrapped_header} ${typesystem_file}
                    DEPENDS ${generated_sources_dependencies}
                    IMPLICIT_DEPENDS CXX ${wrapped_header}
                    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
                    COMMENT "Running generator for ${typesystem_file}.")

# =============================== CMake target - bindings_library =============================

# Set the cpp files which will be used for the bindings library.
set(${bindings_library}_sources ${generated_sources})

# Define and build the bindings library.
add_library(${bindings_library} MODULE ${${bindings_library}_sources})

# Apply relevant include and link flags.
target_include_directories(${bindings_library} PRIVATE ${python_include_dir})
target_include_directories(${bindings_library} PRIVATE ${shiboken_include_dir})
target_include_directories(${bindings_library} PRIVATE ${CMAKE_SOURCE_DIR})
if(EXISTS "${pyside2_path}/include")
    set(pyside2_include_path "${pyside2_path}/include")
else()
    find_path(
        pyside2_include_path
        NAMES
            pyside2_global.h
        HINTS
            /usr/include/PySide2
    )
endif()

find_path(
    shiboken2_include_path
    NAMES
        shiboken.h
    HINTS
        /usr/include/shiboken2
)
target_include_directories(${bindings_library} PRIVATE
    ${pyside2_include_path}
    ${pyside2_include_path}/QtCore
    ${pyside2_include_path}/QtGui
    ${pyside2_include_path}/Qt3DCore
    ${pyside2_include_path}/Qt3DRender
    ${pyside2_include_path}/Qt3DAnimation
)

if(shiboken2_include_path)
    target_include_directories(${bindings_library} PRIVATE "${shiboken2_include_path}")
endif()

target_link_libraries(${bindings_library} PRIVATE ${shiboken_shared_libraries})
target_link_libraries(${bindings_library} PRIVATE Qt5::Kuesa)

# Adjust the name of generated module.
set_property(TARGET ${bindings_library} PROPERTY PREFIX "")
set_property(TARGET ${bindings_library} PROPERTY OUTPUT_NAME
             "${bindings_library}${PYTHON_EXTENSION_SUFFIX}")
if(WIN32)
    set_property(TARGET ${bindings_library} PROPERTY SUFFIX ".pyd")
endif()

# Make sure the linker doesn't complain about not finding Python symbols on macOS.
if(APPLE)
    set_target_properties(${bindings_library} PROPERTIES LINK_FLAGS "-undefined dynamic_lookup")
endif(APPLE)

# Find and link to the python import library only on Windows.
# On Linux and macOS, the undefined symbols will get resolved by the dynamic linker
# (the symbols will be picked up in the Python executable).
if (WIN32)
    list(GET python_linking_data 0 python_libdir)
    list(GET python_linking_data 1 python_lib)
    find_library(python_link_flags ${python_lib} PATHS ${python_libdir} HINTS ${python_libdir})
    target_link_libraries(${bindings_library} PRIVATE ${python_link_flags})
endif()

install(TARGETS ${bindings_library}
        LIBRARY DESTINATION ${pyside2_path}/..
        RUNTIME DESTINATION ${pyside2_path}/..
)
