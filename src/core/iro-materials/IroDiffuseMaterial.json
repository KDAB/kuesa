{
    "type": "IroDiffuse",
    "doc": "is a simple material in terms of rendering that relies on a 2d spherical environment map and a 2d diffuse map to render semi glossy like finishes like clear coated paint.",
    "properties": [
        { "name": "factors", "type": "vec3", "doc": "Specifies a factor to be applied to the normal." },
        { "name": "disturbation", "type": "vec2", "doc": "Specifies a disturbance factor that will be added to the normal" },
        { "name": "postVertexColor", "type": "float", "doc": "Specifies the factor which controls how much of the per vertex color we want to transmit." },
        { "name": "postGain", "type": "float", "doc": "Specifies the factor to be applied to the vertex color." },
        { "name": "semGain", "type": "float", "doc": "Specifies the gain factor to be applied to the spherical environment map lookup." },
        { "name": "sem", "type": "texture2d", "doc": "Specifies the spherical environment map to use. It is expected to be in sRGB color space." },
        { "name": "semInnerFilter", "type": "vec3", "doc": "Specifies the inner color filter to be applied based on fresnel on the spherical environment map lookup." },
        { "name": "semOuterFilter", "type": "vec3", "doc": "Specifies the outer color filter to be applied based on fresnel on the spherical environment map lookup." },
        { "name": "diffuseInnerFilter", "type": "vec3", "doc": "Specifies the inner color filter to be applied based on fresnel on the diffuse map lookup." },
        { "name": "diffuseOuterFilter", "type": "vec3", "doc": "Specifies the outer color filter to be applied based on fresnel on the diffuse map lookup." },
        { "name": "diffuseMap", "type": "texture2d", "doc": "Specifies the diffuse map to use. It is expected to be in sRGB color space." },
        { "name": "diffuseFactor", "type": "vec3", "doc": "Specifies the diffuse color to use in case no diffuse map was specified." },
        { "name": "usesDiffuseMap", "type": "bool", "doc": "Specifies whether we use a diffuse map or not." }
    ],
    "shaders": [
        {
            "format": { "api": "OpenGLES", "major": 2, "minor": 0 },
            "type": "Vertex",
            "code": "precision highp float;\nprecision highp sampler2D;\nuniform mat4 mvp;\nuniform mat4 modelView;\n\nstruct MaterialProperties {\n    vec3 factors;\n    vec2 disturbation;\n    float postVertexColor;\n    float postGain;\n    sampler2D sem;\n    float semGain;\n    vec3 semInnerFilter;\n    vec3 semOuterFilter;\n    vec3 diffuseInnerFilter;\n    vec3 diffuseOuterFilter;\n    sampler2D diffuseMap;\n    vec3 diffuseFactor;\n    bool usesDiffuseMap;\n};\n\nuniform MaterialProperties properties;\n\nin vec3 vertexPosition;\nin vec3 vertexNormal;\nin vec2 vertexTexCoord;\nin vec4 vertexColor;\n\nout vec3 normalSem;\nout vec2 texCoord;\nout vec4 postColor;\n\nvec3 semNormal()\n{\n    vec3 n = (modelView * vec4(vertexNormal, 0.0)).xyz;\n    n *= properties.factors;\n    n.xy += properties.disturbation;\n    return normalize(n);\n}\n\nvoid main()\n{\n    normalSem = semNormal();\n    texCoord = vertexTexCoord;\n    postColor = mix(vec4(1.0), vertexColor, properties.postVertexColor) * properties.postGain;\n    gl_Position = mvp * vec4(vertexPosition, 1.0);\n}\n"
        },
        {
            "format": { "api": "OpenGLES", "major": 3, "minor": 0 },
            "type": "Vertex",
            "code": "#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nuniform mat4 mvp;\nuniform mat4 modelView;\n\nstruct MaterialProperties {\n    vec3 factors;\n    vec2 disturbation;\n    float postVertexColor;\n    float postGain;\n    sampler2D sem;\n    float semGain;\n    vec3 semInnerFilter;\n    vec3 semOuterFilter;\n    vec3 diffuseInnerFilter;\n    vec3 diffuseOuterFilter;\n    sampler2D diffuseMap;\n    vec3 diffuseFactor;\n    bool usesDiffuseMap;\n};\n\nuniform MaterialProperties properties;\n\nin vec3 vertexPosition;\nin vec3 vertexNormal;\nin vec2 vertexTexCoord;\nin vec4 vertexColor;\n\nout vec3 normalSem;\nout vec2 texCoord;\nout vec4 postColor;\n\nvec3 semNormal()\n{\n    vec3 n = (modelView * vec4(vertexNormal, 0.0)).xyz;\n    n *= properties.factors;\n    n.xy += properties.disturbation;\n    return normalize(n);\n}\n\nvoid main()\n{\n    normalSem = semNormal();\n    texCoord = vertexTexCoord;\n    postColor = mix(vec4(1.0), vertexColor, properties.postVertexColor) * properties.postGain;\n    gl_Position = mvp * vec4(vertexPosition, 1.0);\n}\n"
        },
        {
            "format": { "api": "OpenGL", "major": 3, "minor": 2 },
            "type": "Vertex",
            "code": "#version 150 core\n\nuniform mat4 mvp;\nuniform mat4 modelView;\n\nstruct MaterialProperties {\n    vec3 factors;\n    vec2 disturbation;\n    float postVertexColor;\n    float postGain;\n    sampler2D sem;\n    float semGain;\n    vec3 semInnerFilter;\n    vec3 semOuterFilter;\n    vec3 diffuseInnerFilter;\n    vec3 diffuseOuterFilter;\n    sampler2D diffuseMap;\n    vec3 diffuseFactor;\n    bool usesDiffuseMap;\n};\n\nuniform MaterialProperties properties;\n\nin vec3 vertexPosition;\nin vec3 vertexNormal;\nin vec2 vertexTexCoord;\nin vec4 vertexColor;\n\nout vec3 normalSem;\nout vec2 texCoord;\nout vec4 postColor;\n\nvec3 semNormal()\n{\n    vec3 n = (modelView * vec4(vertexNormal, 0.0)).xyz;\n    n *= properties.factors;\n    n.xy += properties.disturbation;\n    return normalize(n);\n}\n\nvoid main()\n{\n    normalSem = semNormal();\n    texCoord = vertexTexCoord;\n    postColor = mix(vec4(1.0), vertexColor, properties.postVertexColor) * properties.postGain;\n    gl_Position = mvp * vec4(vertexPosition, 1.0);\n}\n"
        },
        {
            "format": { "api": "OpenGLES", "major": 2, "minor": 0 },
            "type": "Fragment",
            "code": "precision highp float;\nprecision highp sampler2D;\nvec4 sRGBToLinear(vec4 color)  { return vec4(pow(color.rgb, vec3(2.2)), color.a); }\n\nstruct MaterialProperties {\n    vec3 factors;\n    vec2 disturbation;\n    float postVertexColor;\n    float postGain;\n    sampler2D sem;\n    float semGain;\n    vec3 semInnerFilter;\n    vec3 semOuterFilter;\n    vec3 diffuseInnerFilter;\n    vec3 diffuseOuterFilter;\n    sampler2D diffuseMap;\n    vec3 diffuseFactor;\n    bool usesDiffuseMap;\n};\n\nuniform MaterialProperties properties;\n\nin vec3 normalSem;\nin vec4 postColor;\nin vec2 texCoord;\n\nout vec4 fragColor;\n\nfloat semFresnel(vec3 normalSem_)\n{\n    float fresnel = 1.0 - dot(normalSem_, vec3(0.0, 0.0, 1.0));\n    fresnel *= fresnel;\n    return fresnel;\n}\n\nvec2 semS(vec3 normalSem_)\n{\n    vec2 s = normalSem_.xy;\n    s = s * 0.5 + vec2(0.5);\n    return s;\n}\n\nvoid main()\n{\n    vec3 normalSem_ = normalize(normalSem);\n    float fresnel = semFresnel(normalSem_);\n    vec3 semColor = sRGBToLinear(texture(properties.sem, semS(normalSem_))).xyz * mix(properties.semInnerFilter, properties.semOuterFilter, fresnel) * properties.semGain;\n    vec3 diffuseColor = properties.usesDiffuseMap ? sRGBToLinear(texture(properties.diffuseMap, texCoord)).xyz : properties.diffuseFactor;\n    diffuseColor *= mix(properties.diffuseInnerFilter, properties.diffuseOuterFilter, fresnel);\n    fragColor = postColor * vec4(diffuseColor + semColor, 1.0);\n}"
        },
        {
            "format": { "api": "OpenGLES", "major": 3, "minor": 0 },
            "type": "Fragment",
            "code": "#version 300 es\nprecision highp float;\nprecision highp sampler2D;\nvec4 sRGBToLinear(vec4 color)  { return vec4(pow(color.rgb, vec3(2.2)), color.a); }\n\nstruct MaterialProperties {\n    vec3 factors;\n    vec2 disturbation;\n    float postVertexColor;\n    float postGain;\n    sampler2D sem;\n    float semGain;\n    vec3 semInnerFilter;\n    vec3 semOuterFilter;\n    vec3 diffuseInnerFilter;\n    vec3 diffuseOuterFilter;\n    sampler2D diffuseMap;\n    vec3 diffuseFactor;\n    bool usesDiffuseMap;\n};\n\nuniform MaterialProperties properties;\n\nin vec3 normalSem;\nin vec4 postColor;\nin vec2 texCoord;\n\nout vec4 fragColor;\n\nfloat semFresnel(vec3 normalSem_)\n{\n    float fresnel = 1.0 - dot(normalSem_, vec3(0.0, 0.0, 1.0));\n    fresnel *= fresnel;\n    return fresnel;\n}\n\nvec2 semS(vec3 normalSem_)\n{\n    vec2 s = normalSem_.xy;\n    s = s * 0.5 + vec2(0.5);\n    return s;\n}\n\nvoid main()\n{\n    vec3 normalSem_ = normalize(normalSem);\n    float fresnel = semFresnel(normalSem_);\n    vec3 semColor = sRGBToLinear(texture(properties.sem, semS(normalSem_))).xyz * mix(properties.semInnerFilter, properties.semOuterFilter, fresnel) * properties.semGain;\n    vec3 diffuseColor = properties.usesDiffuseMap ? sRGBToLinear(texture(properties.diffuseMap, texCoord)).xyz : properties.diffuseFactor;\n    diffuseColor *= mix(properties.diffuseInnerFilter, properties.diffuseOuterFilter, fresnel);\n    fragColor = postColor * vec4(diffuseColor + semColor, 1.0);\n}"
        },
        {
            "format": { "api": "OpenGL", "major": 3, "minor": 2 },
            "type": "Fragment",
            "code": "#version 150 core\nvec4 sRGBToLinear(vec4 color)  { return vec4(pow(color.rgb, vec3(2.2)), color.a); }\n\nstruct MaterialProperties {\n    vec3 factors;\n    vec2 disturbation;\n    float postVertexColor;\n    float postGain;\n    sampler2D sem;\n    float semGain;\n    vec3 semInnerFilter;\n    vec3 semOuterFilter;\n    vec3 diffuseInnerFilter;\n    vec3 diffuseOuterFilter;\n    sampler2D diffuseMap;\n    vec3 diffuseFactor;\n    bool usesDiffuseMap;\n};\n\nuniform MaterialProperties properties;\n\nin vec3 normalSem;\nin vec4 postColor;\nin vec2 texCoord;\n\nout vec4 fragColor;\n\nfloat semFresnel(vec3 normalSem_)\n{\n    float fresnel = 1.0 - dot(normalSem_, vec3(0.0, 0.0, 1.0));\n    fresnel *= fresnel;\n    return fresnel;\n}\n\nvec2 semS(vec3 normalSem_)\n{\n    vec2 s = normalSem_.xy;\n    s = s * 0.5 + vec2(0.5);\n    return s;\n}\n\nvoid main()\n{\n    vec3 normalSem_ = normalize(normalSem);\n    float fresnel = semFresnel(normalSem_);\n    vec3 semColor = sRGBToLinear(texture(properties.sem, semS(normalSem_))).xyz * mix(properties.semInnerFilter, properties.semOuterFilter, fresnel) * properties.semGain;\n    vec3 diffuseColor = properties.usesDiffuseMap ? sRGBToLinear(texture(properties.diffuseMap, texCoord)).xyz : properties.diffuseFactor;\n    diffuseColor *= mix(properties.diffuseInnerFilter, properties.diffuseOuterFilter, fresnel);\n    fragColor = postColor * vec4(diffuseColor + semColor, 1.0);\n}"
        }
    ]
}
